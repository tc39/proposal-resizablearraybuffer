<!doctype html>
<meta charset="utf8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<title>Resizable ArrayBuffer and growable SharedArrayBuffer</title>
<pre class=metadata>
  title: Resizable ArrayBuffer and growable SharedArrayBuffer
  status: proposal
  stage: 3
  location: https://github.com/tc39/proposal-resizablearraybuffer
  copyright: false
  contributors: Shu-yu Guo
  markEffects: true
</pre>
<emu-intro id="intro">
  <h1>Resizable ArrayBuffer and growable SharedArrayBuffer</h1>
  <p>We extend the `ArrayBuffer` and `SharedArrayBuffer` constructors to take an additional maximum byte length, which would construct dynamically resizable and growable array buffers, respectively.</p>
</emu-intro>

<emu-clause id="sec-arraybuffer-objects-mods">
  <h1>Modifications to ArrayBuffer Objects</h1>

  <emu-clause id="sec-abstract-operations-for-arraybuffer-objects-mods">
    <h1>Modifications to Abstract Operations for ArrayBuffer Objects</h1>

    <emu-clause id="sec-detacharraybuffer" type="abstract operation">
      <h1>
        DetachArrayBuffer (
          _arrayBuffer_: an ArrayBuffer,
          optional _key_: anything,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Assert: IsSharedArrayBuffer(_arrayBuffer_) is *false*.
        1. If _key_ is not present, set _key_ to *undefined*.
        1. If _arrayBuffer_.[[ArrayBufferDetachKey]] is not _key_, throw a *TypeError* exception.
        1. Set _arrayBuffer_.[[ArrayBufferData]] to *null*.
        1. Set _arrayBuffer_.[[ArrayBufferByteLength]] to 0.
        1. Return ~unused~.
      </emu-alg>
      <emu-note>
        <p>Detaching an ArrayBuffer instance disassociates the Data Block used as its backing store from the instance and sets the byte length of the buffer to 0. <del>No operations defined by this specification use the DetachArrayBuffer abstract operation. However, an ECMAScript host or implementation may define such operations.</del></p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-allocatearraybuffer" type="abstract operation">
      <h1>
        AllocateArrayBuffer (
          _constructor_: a constructor,
          _byteLength_: a non-negative integer,
          <ins>optional _maxByteLength_: a non-negative integer or ~empty~,</ins>
        ): either a normal completion containing an ArrayBuffer or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It is used to create an ArrayBuffer.</dd>
      </dl>
      <emu-alg>
        1. <ins>Let _slots_ be &laquo; [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] &raquo;.</ins>
        1. <ins>If _maxByteLength_ is present and not ~empty~, then</ins>
          1. <ins>If _byteLength_ &gt; _maxByteLength_, throw a *RangeError* exception.</ins>
          1. <ins>Append [[ArrayBufferMaxByteLength]] to _slots_.</ins>
        1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *"%ArrayBuffer.prototype%"*, <del>&laquo; [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] &raquo;</del><ins>_slots_</ins>).
        1. Let _block_ be ? CreateByteDataBlock(_byteLength_).
        1. Set _obj_.[[ArrayBufferData]] to _block_.
        1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
        1. <ins>If _maxByteLength_ is present and not ~empty~, then</ins>
          1. <ins>If it is not possible to create a Data Block _block_ consisting of _maxByteLength_ bytes, throw a *RangeError* exception.</ins>
          1. <ins>NOTE: Resizable ArrayBuffers are designed to be implementable with in-place growth. Implementations reserve the right to throw if, for example, virtual memory cannot be reserved up front.</ins>
          1. <ins>Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.</ins>
        1. Return _obj_.
      </emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-arraybufferlength" type="abstract operation">
      <h1>
        ArrayBufferByteLength (
          _arrayBuffer_: an ArrayBuffer,
          _order_: ~SeqCst~ or ~Unordered~,
        ): a non-negative integer
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If IsSharedArrayBuffer(_arrayBuffer_) is *true* and _arrayBuffer_ has an [[ArrayBufferByteLengthData]] internal slot, then
          1. Let _bufferByteLengthBlock_ be _arrayBuffer_.[[ArrayBufferByteLengthData]].
          1. Return ‚Ñù(GetValueFromBuffer(_bufferByteLengthBlock_, 0, ~BigUint64~, *true*, _order_)).
        1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
        1. Return _arrayBuffer_.[[ArrayBufferByteLength]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makeidempotentarraybufferbytelengthgetter" type="abstract operation">
      <h1>
        MakeIdempotentArrayBufferByteLengthGetter (
          _order_: ~SeqCst~ or ~Unordered~,
        ): an Abstract Closure with one parameter
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned Abstract Closure helps ensure that there there is a single shared memory read event of the byte length data block in the calling operation.</dd>
      </dl>
      <emu-alg>
        1. NOTE: The [[ArrayBuffer]] slot is used for editorial clarity only, that a getter should only be used with a single ArrayBuffer.
        1. Let _lengthStorage_ be { [[ArrayBuffer]]: ~empty~, [[ByteLength]]: ~empty~ }.
        1. Let _getter_ be a new Abstract Closure with parameters (_buffer_) that captures _lengthStorage_ and _order_ and performs the following steps when called:
          1. If _lengthStorage_.[[ByteLength]] is ~empty~, then
            1. Assert: _lengthStorage_.[[ArrayBuffer]] is ~empty~.
            1. Set _lengthStorage_.[[ArrayBuffer]] to _buffer_.
            1. Set _lengthStorage_.[[ByteLength]] to ArrayBufferByteLength(_buffer_, _order_).
          1. Assert: SameValue(_lengthStorage_.[[ArrayBuffer]], _buffer_) is *true*.
          1. Return _lengthStorage_.[[ByteLength]].
        1. Return _getter_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isresizablearraybuffer" type="abstract operation">
      <h1>
        IsResizableArrayBuffer (
          _arrayBuffer_: an ArrayBuffer,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _arrayBuffer_ has an [[ArrayBufferMaxByteLength]] internal slot, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getarraybuffermaxbytelengthoption" type="abstract operation">
      <h1>
        GetArrayBufferMaxByteLengthOption (
          _options_: an ECMAScript language value,
        ): a normal completion containing either a non-negative integer or ~empty~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If Type(_options_) is not Object, return ~empty~.
        1. Let _maxByteLength_ be ? Get(_options_, `"maxByteLength"`).
        1. If _maxByteLength_ is *undefined*, return ~empty~.
        1. Return ? ToIndex(_maxByteLength_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hostresizearraybuffer" type="host-defined abstract operation">
      <h1>
        HostResizeArrayBuffer (
          _buffer_: an ArrayBuffer,
          _newByteLength_: a non-negative integer,
        ): either a normal completion containing either ~handled~ or ~unhandled~, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The host-defined abstract operation HostResizeArrayBuffer takes arguments _buffer_ (an ArrayBuffer object) and _newByteLength_. It gives the host an opportunity to perform implementation-defined resizing of _buffer_. If the host chooses not to handle resizing of _buffer_, it may return ~unhandled~ for the default behaviour.</dd>
      </dl>

      <p>The implementation of HostResizeArrayBuffer must conform to the following requirements:</p>
      <ul>
        <li>The abstract operation must return either NormalCompletion(~handled~), NormalCompletion(~unhandled~), or an abrupt throw completion.</li>
        <li>The abstract operation does not detach _buffer_.</li>
        <li>If the abstract operation completes normally with ~handled~, _buffer_.[[ArrayBufferByteLength]] is _newByteLength_.</li>
      </ul>

      <p>The default implementation of HostResizeArrayBuffer is to return ~unhandled~.</p>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-arraybuffer-constructor">
    <h1>The ArrayBuffer Constructor</h1>

    <emu-clause id="sec-arraybuffer-length">
      <h1>ArrayBuffer ( _length_ <ins>[ , _options_ ]</ins> )</h1>
      <p>When the `ArrayBuffer` function is called with argument _length_<ins> and optional argument _options_</ins>, the following steps are taken:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _byteLength_ be ? ToIndex(_length_).
        1. <ins>Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).</ins>
        1. Return ? AllocateArrayBuffer(NewTarget, _byteLength_<ins>, _requestedMaxByteLength_</ins>).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object-mods">
    <h1>Modifications to the Properties of the ArrayBuffer Prototype Object</h1>

    <emu-clause id="sec-get-arraybuffer-@@species">
      <h1>get ArrayBuffer [ @@species ]</h1>
      <p>`ArrayBuffer[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Return the *this* value.
      </emu-alg>
      <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
      <emu-note>
        <p>ArrayBuffer prototype methods normally use their *this* value's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour <ins>for the <emu-xref href="#sec-arraybuffer.prototype.slice" title></emu-xref> method</ins> by redefining its @@species property.</p>
      </emu-note>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-get-arraybuffer.prototype.maxbytelength">
      <h1>get ArrayBuffer.prototype.maxByteLength</h1>
      <p>`ArrayBuffer.prototype.maxByteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>ùîΩ</sub>.
        1. If IsResizableArrayBuffer(_O_) is *true*, then
          1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].
        1. Else,
          1. Let _length_ be _O_.[[ArrayBufferByteLength]].
        1. Return ùîΩ(_length_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-arraybuffer.prototype.resizable">
      <h1>get ArrayBuffer.prototype.resizable</h1>
      <p>`ArrayBuffer.prototype.resizable` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. Return IsResizableArrayBuffer(_O_).
      </emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-arraybuffer.prototype.slice">
      <h1>ArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. Let _len_ be _O_.[[ArrayBufferByteLength]].
        1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
        1. If _relativeStart_ is -&infin;, let _first_ be 0.
        1. Else if _relativeStart_ &lt; 0, let _first_ be max(_len_ + _relativeStart_, 0).
        1. Else, let _first_ be min(_relativeStart_, _len_).
        1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
        1. If _relativeEnd_ is -&infin;, let _final_ be 0.
        1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
        1. Else, let _final_ be min(_relativeEnd_, _len_).
        1. Let _newLen_ be max(_final_ - _first_, 0).
        1. Let _ctor_ be ? SpeciesConstructor(_O_, %ArrayBuffer%).
        1. Let _new_ be ? Construct(_ctor_, &laquo; ùîΩ(_newLen_) &raquo;).
        1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_new_) is *true*, throw a *TypeError* exception.
        1. If IsDetachedBuffer(_new_) is *true*, throw a *TypeError* exception.
        1. If SameValue(_new_, _O_) is *true*, throw a *TypeError* exception.
        1. If _new_.[[ArrayBufferByteLength]] &lt; _newLen_, throw a *TypeError* exception.
        1. NOTE: Side-effects of the above steps may have detached <ins>or resized </ins>_O_.
        1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. Let _fromBuf_ be _O_.[[ArrayBufferData]].
        1. Let _toBuf_ be _new_.[[ArrayBufferData]].
        1. <ins>If _first_ &lt; _O_.[[ArrayBufferByteLength]], then</ins>
          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, <ins>min(_O_.[[ArrayBufferByteLength]], </ins>_newLen_<ins>)</ins>).
        1. Return _new_.
      </emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-arraybuffer.prototype.resize">
      <h1>ArrayBuffer.prototype.resize ( _newLength_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
        1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. Let _newByteLength_ be ? ToIntegerOrInfinity(_newLength_).
        1. If _newByteLength_ &lt; 0 or _newByteLength_ &gt; _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.
        1. Let _hostHandled_ be ? HostResizeArrayBuffer(_O_, _newByteLength_).
        1. If _hostHandled_ is ~handled~, return *undefined*.
        1. Let _oldBlock_ be _O_.[[ArrayBufferData]].
        1. Let _newBlock_ be ? CreateByteDataBlock(_newByteLength_).
        1. Let _copyLength_ be min(_newByteLength_, _O_.[[ArrayBufferByteLength]]).
        1. Perform CopyDataBlockBytes(_newBlock_, 0, _oldBlock_, 0, _copyLength_).
        1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations reserve the right to implement this method as in-place growth or shrinkage.
        1. Set _O_.[[ArrayBufferData]] to _newBlock_.
        1. Set _O_.[[ArrayBufferByteLength]] to _newLength_.
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-sharedarraybuffer-objects-mods">
  <h1>Modifications to SharedArrayBuffer Objects</h1>

  <emu-clause id="sec-abstract-operations-for-sharedarraybuffer-objects-mods">
    <h1>Modifications to Abstract Operations for SharedArrayBuffer Objects</h1>

    <emu-clause id="sec-allocatesharedarraybuffer" type="abstract operation">
      <h1>
        AllocateSharedArrayBuffer (
          _constructor_: a constructor,
          _byteLength_: a non-negative integer,
          <ins>optional _maxByteLength_: a non-negative integer or ~empty~,</ins>
        ): either a normal completion containing a SharedArrayBuffer or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It is used to create a SharedArrayBuffer.</dd>
      </dl>
      <emu-alg>
        1. <ins>Let _slots_ be &laquo; [[ArrayBufferData]] &raquo;.</ins>
        1. <ins>If _maxByteLength_ is present and not ~empty~, then</ins>
          1. <ins>If _byteLength_ &gt; _maxByteLength_, throw a *RangeError* exception.</ins>
          1. <ins>Append [[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to _slots_.</ins>
        1. <ins>Else, append [[ArrayBufferByteLength]] to _slots_.</ins>
        1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *"%SharedArrayBuffer.prototype%"*, <del>&laquo; [[ArrayBufferData]], [[ArrayBufferByteLength]] &raquo;</del><ins>_slots_</ins>).
        1. <ins>If _maxByteLength_ is present, let _allocLength_ be _maxByteLength_.</ins>
        1. <ins>Else, let _allocLength_ be _byteLength_.</ins>
        1. Let _block_ be ? CreateSharedByteDataBlock(<del>_byteLength_</del><ins>_allocLength_</ins>).
        1. <ins>NOTE: Growable SharedArrayBuffers must be implemented as in-place growable. Creation of a _maxByteLength_ sized Data Block is a specification mechanism. It may be implemented as committing a _byteLength_ sized buffer while reserving _maxByteLength_ in virtual memory.</ins>
        1. Set _obj_.[[ArrayBufferData]] to _block_.
        1. <ins>If _maxByteLength_ is present and not ~empty~, then</ins>
          1. <ins>Assert: _byteLength_ &le; _maxByteLength_.</ins>
          1. <ins>Let _byteLengthBlock_ be ? CreateSharedByteDataBlock(8).</ins>
          1. <ins>Perform SetValueInBuffer(_byteLengthBlock_, 0, ~BigUint64~, ‚Ñ§(_byteLength_), *true*, ~SeqCst~).</ins>
          1. <ins>Set _obj_.[[ArrayBufferByteLengthData]] to _byteLengthBlock_.</ins>
          1. <ins>Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.</ins>
        1. <ins>Else,</ins>
          1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
        1. Return _obj_.
      </emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-hostgrowsharedarraybuffer" type="host-defined abstract operation">
      <h1>
        HostGrowSharedArrayBuffer (
          _buffer_: a SharedArrayBuffer,
          _newByteLength_: a non-negative integer
        ): either a normal completion containing either ~handled~ or ~unhandled~, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It gives the host an opportunity to perform implementation-defined growing of _buffer_. If the host chooses not to handle resizing of _buffer_, it may return ~unhandled~ for the default behaviour.</dd>
      </dl>
      <p>The implementation of HostGrowSharedArrayBuffer must conform to the following requirements:</p>
      <ul>
         <li>The abstract operation must return either NormalCompletion(~handled~), NormalCompletion(~unhandled~), or an abrupt throw completion.</li>
         <li>If the abstract operation does not complete normally with ~unhandled~, and _newByteLength_ &lt; the current byte length of the _buffer_ or _newByteLength_ &gt; _buffer_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.</li>
         <li>Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record. If the abstract operation completes normally with ~handled~, a WriteSharedMemory or ReadModifyWriteSharedMemory event whose [[Order]] is ~SeqCst~, [[Payload]] is NumericToRawBytes(~BigUint64~, _newByteLength_, _isLittleEndian_), [[Block]] is _buffer_.[[ArrayBufferByteLengthData]], [[ByteIndex]] is 0, and [[ElementSize]] is 8 is added to the surrounding agent's candidate execution such that racing calls to `SharedArrayBuffer.prototype.grow` are not "lost", i.e. silently do nothing.</li>
      </ul>

      <p>The default implementation of HostGrowSharedArrayBuffer is to return ~unhandled~.</p>

      <emu-note>
        <p>The second requirement above is intentionally vague about how or when the current byte length of _buffer_ is read. Because the byte length must be updated via an atomic read-modify-write operation on the underlying hardware, architectures that use load-link/store-conditional or load-exclusive/store-exclusive instruction pairs may wish to keep the paired instructions close in the instruction stream. As such, SharedArrayBuffer.prototype.grow itself does not perform bounds checking on _newByteLength_ before calling HostGrowSharedArrayBuffer, nor is there a requirement on when the current byte length is read.</p>
        <p>This is in contrast with HostResizeArrayBuffer, which is guaranteed that the value of _newByteLength_ is &ge; 0 and &le; _buffer_.[[ArrayBufferMaxByteLength]].</p>
      </emu-note>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer-constructor">
    <h1>The SharedArrayBuffer Constructor</h1>

    <emu-clause id="sec-sharedarraybuffer-length">
      <h1>SharedArrayBuffer ( _length_ <ins>[ , _options_ ]</ins> )</h1>
      <p>When the `SharedArrayBuffer` function is called with argument _length_<ins> and optional argument _options_</ins>, the following steps are taken:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _byteLength_ be ? ToIndex(_length_).
        1. <ins>Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).</ins>
        1. Return ? AllocateSharedArrayBuffer(NewTarget, _byteLength_<ins>, _requestedMaxByteLength_</ins>).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-sharedarraybuffer-prototype-object-mods">
    <h1>Modifications to the Properties of the SharedArrayBuffer Prototype Object</h1>

    <emu-clause id="sec-get-sharedarraybuffer.prototype.bytelength">
      <h1>get SharedArrayBuffer.prototype.byteLength</h1>
      <p>`SharedArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
        1. Let _length_ be <del>_O_.[[ArrayBufferByteLength]]</del><ins>ArrayBufferByteLength(_O_, ~SeqCst~)</ins>.
        1. Return ùîΩ(_length_).
      </emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-get-sharedarraybuffer.prototype.growable">
      <h1>get SharedArrayBuffer.prototype.growable</h1>
      <p>`SharedArrayBuffer.prototype.growable` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
        1. Return IsResizableArrayBuffer(_O_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-sharedarraybuffer.prototype.maxbytelength">
      <h1>get SharedArrayBuffer.prototype.maxByteLength</h1>
      <p>`SharedArrayBuffer.prototype.maxByteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
        1. If IsResizableArrayBuffer(_O_) is *true*, then
          1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].
        1. Else,
          1. Let _length_ be _O_.[[ArrayBufferByteLength]].
        1. Return ùîΩ(_length_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sharedarraybuffer.prototype.grow">
      <h1>SharedArrayBuffer.prototype.grow ( _newLength_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
        1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
        1. Let _newByteLength_ be ? ToIntegerOrInfinity(_newLength_).
        1. Let _hostHandled_ be ? HostGrowSharedArrayBuffer(_O_, _newByteLength_).
        1. If _hostHandled_ is ~handled~, return *undefined*.
        1. Let _rawCurrentByteLengthBytesRead_ be a List of length 8 whose elements are nondeterministically chosen byte values.
        1. NOTE: In implementations, _rawCurrentByteLengthBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
        1. Let _byteLengthBlock_ be _O_.[[ArrayBufferByteLengthData]].
        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
        1. Let _currentByteLength_ be RawBytesToNumeric(~BigUint64~, _rawCurrentByteLengthBytesRead_, _isLittleEndian_).
        1. Let _growFailed_ be *false*.
        1. If _newByteLength_ &lt; _currentByteLength_ or _newByteLength_ &gt; _O_.[[ArrayBufferMaxByteLength]], set _growFailed_ to *true*.
        1. Let _byteLengthDelta_ be _newByteLength_ - _currentByteLength_.
        1. If it is impossible to create a new Shared Data Block value consisting of _byteLengthDelta_ bytes, set _growFailed_ to *true*.
        1. NOTE: No new Shared Data Block is constructed and used here. The observable behaviour of growable SharedArrayBuffers is specified by allocating a max-sized Shared Data Block at construction time, and this step is intended to capture the requirement that implementations that run out of memory must throw a *RangeError*.
        1. NOTE: The above checks help ensure that concurrent calls to SharedArrayBuffer.prototype.grow are totally ordered. For example, consider two racing calls: `sab.grow(10)` and `sab.grow(20)`. One of the two calls is guaranteed to win the race. The call to `sab.grow(10)` will never shrink `sab` even if `sab.grow(20)` happened first.
        1. If _growFailed_ is *false* and _newByteLength_ &ne; _currentByteLength_, then
          1. NOTE: Resizes to the same length explicitly do nothing to avoid gratuitous synchronization.
          1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:
            1. Return _newBytes_.
          1. Let _newByteLengthBytes_ be NumericToRawBytes(~BigUint64~, ‚Ñ§(_newByteLength_), _isLittleEndian_).
          1. Let _event_ be ReadModifyWriteSharedMemory { [[Order]]: ~SeqCst~, [[NoTear]]: *true*, [[Block]]: _byteLengthBlock_, [[ByteIndex]]: 0, [[ElementSize]]: 8, [[Payload]]: _newByteLengthBytes_, [[ModifyOp]]: _second_ }.
          1. NOTE: The new memory is already zeroed, as a _O_.[[ArrayBufferMaxByteLength]] sized Data Block is already allocated. This is a specification mechanism; an implementation is not required to reserve _O_.[[ArrayBufferMaxByteLength]] bytes of physical memory.
        1. Else,
          1. Let _event_ be ReadSharedMemory { [[Order]]: ~SeqCst~, [[NoTear]]: *true*, [[Block]]: _byteLengthBlock_, [[ByteIndex]]: 0, [[ElementSize]]: 8 }.
        1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
        1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
        1. Append _event_ to _eventList_.
        1. Append Chosen Value Record { [[Event]]: _event_, [[ChosenValue]]: _rawCurrentByteLengthBytesRead_ } to _execution_.[[ChosenValues]].
        1. If _growFailed_ is *true*, throw a *RangeError* exception.
        1. Return *undefined*.
      </emu-alg>
      <emu-note>
        <p>Spurious failures of the compare-exchange to update the length are prohibited. If the bounds checking for the new length passes and the implementation is not out of memory, a ReadModifyWriteSharedMemory event (i.e. a successful compare-exchange) is always added into the candidate execution.</p>
        <p>Many of the above steps are shared with the algorithm steps of Atomics.compareExchange and should be refactored when merged into the full specification.</p>
      </emu-note>
    </emu-clause>
    </ins>

    <emu-clause id="sec-sharedarraybuffer.prototype.slice">
      <h1>SharedArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
        1. Let _len_ be <del>_O_.[[ArrayBufferByteLength]]</del><ins>ArrayBufferByteLength(_O_, ~SeqCst~)</ins>.
        1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
        1. If _relativeStart_ is -&infin;, let _first_ be 0.
        1. Else if _relativeStart_ &lt; 0, let _first_ be max(_len_ + _relativeStart_, 0).
        1. Else, let _first_ be min(_relativeStart_, _len_).
        1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
        1. If _relativeEnd_ is -&infin;, let _final_ be 0.
        1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
        1. Else, let _final_ be min(_relativeEnd_, _len_).
        1. Let _newLen_ be max(_final_ - _first_, 0).
        1. Let _ctor_ be ? SpeciesConstructor(_O_, %SharedArrayBuffer%).
        1. Let _new_ be ? Construct(_ctor_, &laquo; ùîΩ(_newLen_) &raquo;).
        1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).
        1. <ins>NOTE: Unlike ArrayBuffers, SharedArrayBuffers cannot shrink, so the length does not need to be reloaded.</ins>
        1. If IsSharedArrayBuffer(_new_) is *false*, throw a *TypeError* exception.
        1. If _new_.[[ArrayBufferData]] and _O_.[[ArrayBufferData]] are the same Shared Data Block values, throw a *TypeError* exception.
        1. If _new_.[[ArrayBufferByteLength]] &lt; _newLen_, throw a *TypeError* exception.
        1. Let _fromBuf_ be _O_.[[ArrayBufferData]].
        1. Let _toBuf_ be _new_.[[ArrayBufferData]].
        1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).
        1. Return _new_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-integer-indexed-exotic-objects-mods">
  <h1>Modifications to Integer-Indexed Exotic Objects</h1>

  <emu-clause id="sec-integer-indexed-exotic-objects-ownpropertykeys" type="internal method">
    <h1>[[OwnPropertyKeys]] ( ): a normal completion containing a List of property keys</h1>
    <dl class="header">
      <dt>for</dt>
      <dd>an Integer-Indexed exotic object _O_</dd>
    </dl>
    <emu-alg>
      1. Let _keys_ be a new empty List.
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. <del>If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *false*, then</del>
        1. <del>For each integer _i_ starting with 0 such that _i_ &lt; _O_.[[ArrayLength]], in ascending order, do</del>
          1. <del>Add ! ToString(ùîΩ(_i_)) as the last element of _keys_.</del>
      1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
      1. <ins>Let _len_ be IntegerIndexedObjectLength(_O_, _getBufferByteLength_).</ins>
      1. <ins>If _len_ is not ~out-of-bounds~, then</ins>
        1. <ins>For each integer _i_ starting with 0 such that _i_ &lt; _len_, in ascending order, do</ins>
          1. <ins>Add ! ToString(ùîΩ(_i_)) as the last element of _keys_.</ins>
      1. For each own property key _P_ of _O_ such that Type(_P_) is String and _P_ is not an integer index, in ascending chronological order of property creation, do
        1. Add _P_ as the last element of _keys_.
      1. For each own property key _P_ of _O_ such that Type(_P_) is Symbol, in ascending chronological order of property creation, do
        1. Add _P_ as the last element of _keys_.
      1. Return _keys_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-isvalidintegerindex" type="abstract operation">
    <h1>
      IsValidIntegerIndex (
        _O_: an Integer-Indexed exotic object,
       _index_: a Number,
      ): a Boolean
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. <del>If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true*, return *false*.</del>
      1. If IsIntegralNumber(_index_) is *false*, return *false*.
      1. If _index_ is *-0*<sub>ùîΩ</sub>, return *false*.
      1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~Unordered~).</ins>
      1. <ins>NOTE: Bounds checking is not a synchronizing operation when _O_'s backing buffer is a growable SharedArrayBuffer.</ins>
      1. <ins>Let _length_ be IntegerIndexedObjectLength(_O_, _getBufferByteLength_).</ins>
      1. If <ins>_length_ is ~out-of-bounds~ or</ins> ‚Ñù(_index_) &lt; 0 or ‚Ñù(_index_) &ge; <del>_O_.[[ArrayLength]]</del><ins>_length_</ins>, return *false*.
      1. Return *true*.
    </emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-integerindexedobjectbytelength" type="abstract operation">
    <h1>
      IntegerIndexedObjectByteLength (
        _O_: an Integer-Indexed exotic object,
        _getBufferByteLength_: an Abstract Closure,
      ): a non-negative integer
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. Let _length_ be IntegerIndexedObjectLength(_O_, _getBufferByteLength_).
      1. If _length_ is ~out-of-bounds~ or _length_ = 0, return 0.
      1. If _O_.[[ByteLength]] is not ~auto~, return _O_.[[ByteLength]].
      1. Let _elementSize_ be TypedArrayElementSize(_O_).
      1. Return _length_ &times; _elementSize_.
    </emu-alg>
    </emu-clause>

  <emu-clause id="sec-integerindexedobjectlength" type="abstract operation">
    <h1>
      IntegerIndexedObjectLength (
        _O_: an Integer-Indexed exotic object,
        _getBufferByteLength_: an Abstract Closure,
      ): a non-negative integer or ~out-of-bounds~
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. If IsIntegerIndexedObjectOutOfBounds(_O_, _getBufferByteLength_) is *true*, return ~out-of-bounds~.
      1. If _O_.[[ArrayLength]] is not ~auto~, return _O_.[[ArrayLength]].
      1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
      1. Let _bufferByteLength_ be _getBufferByteLength_(_buffer_).
      1. Assert: IsResizableArrayBuffer(_buffer_) is *true*.
      1. Let _byteOffset_ be _O_.[[ByteOffset]].
      1. Let _elementSize_ be TypedArrayElementSize(_O_).
      1. Return floor((_bufferByteLength_ - _byteOffset_) / _elementSize_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-isintegerindexedobjectoutofbounds" type="abstract operation">
    <h1>
      IsIntegerIndexedObjectOutOfBounds (
        _O_: an Integer-Indexed exotic object,
        _getBufferByteLength_: an Abstract Closure,
      ): a Boolean
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It checks if any of the object's numeric properties reference a value at an index not contained within the underlying data block's bounds.</dd>
    </dl>
    <emu-alg>
      1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
      1. If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true*, return *true*.
      1. Let _bufferByteLength_ be _getBufferByteLength_(_buffer_).
      1. Let _byteOffsetStart_ be _O_.[[ByteOffset]].
      1. If _O_.[[ArrayLength]] is ~auto~, then
        1. Let _byteOffsetEnd_ be _bufferByteLength_.
      1. Else,
        1. Let _elementSize_ be TypedArrayElementSize(_O_).
        1. Let _byteOffsetEnd_ be _byteOffsetStart_ + _O_.[[ArrayLength]] &times; _elementSize_.
      1. If _byteOffsetStart_ &gt; _bufferByteLength_ or _byteOffsetEnd_ &gt; _bufferByteLength_, return *true*.
      1. NOTE: 0-length TypedArrays are not considered out-of-bounds.
      1. Return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-isarraybufferviewoutofbounds" type="abstract operation">
    <h1>
      IsArrayBufferViewOutOfBounds(
        _O_: an Integer-Indexed exotic object or a DataView,
      ): a Boolean
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It checks if either any of a TypedArray's numeric properties or a DataView object's methods can reference a value at an index not contained within the underlying data block's bounds. This abstract operation exists as a convenience for upstream specifications.</dd>
    </dl>
    <emu-alg>
      1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
      1. If IsDetachedBuffer(_buffer_) is *true*, return *true*.
      1. Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).
      1. If IsSharedArrayBuffer(_buffer_) is *true*, then
        1. Assert: If _O_ has a [[DataView]] internal slot, IsViewOutOfBounds(_O_, _getBufferByteLength_) is *false*. Else, IsIntegerIndexedObjectOutOfBounds(_O_, _getBufferByteLength_) is *false*.
        1. NOTE: SharedArrayBuffers can only grow, and views on it cannot go out of bounds after construction. This is special-cased in this operation to avoid shared memory loads of the buffer's byte length, which are not necessary for this check.
        1. Return *false*.
      1. If _O_ has a [[DataView]] internal slot, return IsViewOutOfBounds(_O_, _getBufferByteLength_).
      1. Return IsIntegerIndexedObjectOutOfBounds(_O_, _getBufferByteLength_).
    </emu-alg>
  </emu-clause>
  </ins>
</emu-clause>

<emu-clause id="sec-typedarray-objects-mods">
  <h1>Modifications to TypedArray Objects</h1>

  <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object-mods">
    <h1>Modifications to Properties of the %TypedArray.prototype% Object</h1>

    <emu-clause id="sec-validatetypedarray" type="abstract operation">
      <h1>
        ValidateTypedArray (
          _O_: an ECMAScript language value,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. <ins>If IsIntegerIndexedObjectOutOfBounds(_O_, _getBufferByteLength_) is *true*, throw a *TypeError* exception.</ins>
        1. Return _buffer_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.bytelength">
      <h1>get %TypedArray%.prototype.byteLength</h1>
      <p>%TypedArray%`.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, return *+0*<sub>ùîΩ</sub></del>.
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. Let _size_ be <del>_O_.[[ByteLength]]</del><ins>IntegerIndexedObjectByteLength(_O_, _getBufferByteLength_)</ins>.
        1. Return ùîΩ(_size_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.byteoffset">
      <h1>get %TypedArray%.prototype.byteOffset</h1>
      <p>%TypedArray%`.prototype.byteOffset` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, return *+0*<sub>ùîΩ</sub>.</del>
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. <ins>If IsIntegerIndexedObjectOutOfBounds(_O_, _getBufferByteLength_) is *true*, return *+0*<sub>ùîΩ</sub>.</ins>
        1. Let _offset_ be _O_.[[ByteOffset]].
        1. Return ùîΩ(_offset_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.length">
      <h1>get %TypedArray%.prototype.length</h1>
      <p>%TypedArray%`.prototype.length` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, return *+0*<sub>ùîΩ</sub>.</del>
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. Let _length_ be <del>_O_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_O_, _getBufferByteLength_)</ins>.
        1. <ins>If _length_ is ~out-of-bounds~, set _length_ to 0.</ins>
        1. Return ùîΩ(_length_).
      </emu-alg>
      <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-%typedarray%.prototype.copywithin">
      <h1>%TypedArray%.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
      <p>The interpretation and use of the arguments of %TypedArray%`.prototype.copyWithin` are the same as for `Array.prototype.copyWithin` as defined in <emu-xref href="#sec-array.prototype.copywithin"></emu-xref>.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? ValidateTypedArray(_O_).
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. Let _len_ be <del>_O_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_O_, _getBufferByteLength_)</ins>.
        1. <ins>Assert: _len_ is not ~out-of-bounds~.</ins>
        1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).
        1. If _relativeTarget_ is -&infin;, let _to_ be 0.
        1. Else if _relativeTarget_ &lt; 0, let _to_ be max(_len_ + _relativeTarget_, 0).
        1. Else, let _to_ be min(_relativeTarget_, _len_).
        1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
        1. If _relativeStart_ is -&infin;, let _from_ be 0.
        1. Else if _relativeStart_ &lt; 0, let _from_ be max(_len_ + _relativeStart_, 0).
        1. Else, let _from_ be min(_relativeStart_, _len_).
        1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
        1. If _relativeEnd_ is -&infin;, let _final_ be 0.
        1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
        1. Else, let _final_ be min(_relativeEnd_, _len_).
        1. Let _count_ be min(_final_ - _from_, _len_ - _to_).
        1. If _count_ &gt; 0, then
          1. NOTE: The copying must be performed in a manner that preserves the bit-level encoding of the source data.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. <ins>Set _getBufferByteLength_ to MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
          1. <ins>Set _len_ to IntegerIndexedObjectLength(_O_, _getBufferByteLength_).</ins>
          1. If <del>IsDetachedBuffer(_buffer_) is *true*</del><ins>_len_ is ~out-of-bounds~</ins>, throw a *TypeError* exception.
          1. Let _typedArrayName_ be the String value of _O_.[[TypedArrayName]].
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _typedArrayName_.
          1. <ins>Let _bufferByteLen_ be _len_ &times; _elementSize_.</ins>
          1. Let _byteOffset_ be _O_.[[ByteOffset]].
          1. Let _toByteIndex_ be _to_ &times; _elementSize_ + _byteOffset_.
          1. Let _fromByteIndex_ be _from_ &times; _elementSize_ + _byteOffset_.
          1. Let _countBytes_ be _count_ &times; _elementSize_.
          1. If _fromByteIndex_ &lt; _toByteIndex_ and _toByteIndex_ &lt; _fromByteIndex_ + _countBytes_, then
            1. Let _direction_ be -1.
            1. Set _fromByteIndex_ to _fromByteIndex_ + _countBytes_ - 1.
            1. Set _toByteIndex_ to _toByteIndex_ + _countBytes_ - 1.
          1. Else,
            1. Let _direction_ be 1.
          1. Repeat, while _countBytes_ &gt; 0,
            1. <ins>If _fromByteIndex_ &lt; _bufferByteLen_ and _toByteIndex_ &lt; _bufferByteLen_, then</ins>
              1. Let _value_ be GetValueFromBuffer(_buffer_, _fromByteIndex_, ~Uint8~, *true*, ~Unordered~).
              1. Perform SetValueInBuffer(_buffer_, _toByteIndex_, ~Uint8~, _value_, *true*, ~Unordered~).
              1. Set _fromByteIndex_ to _fromByteIndex_ + _direction_.
              1. Set _toByteIndex_ to _toByteIndex_ + _direction_.
            1. Set _countBytes_ to _countBytes_ - 1.
        1. Return _O_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-%typedarray%.prototype.fill">
      <h1>%TypedArray%.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
      <p>The interpretation and use of the arguments of %TypedArray%`.prototype.fill` are the same as for `Array.prototype.fill` as defined in <emu-xref href="#sec-array.prototype.fill"></emu-xref>.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? ValidateTypedArray(_O_).
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. Let _len_ be <del>_O_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_O_, _getBufferByteLength_)</ins>.
        1. <ins>Assert: _len_ is not ~out-of-bounds~.</ins>
        1. If _O_.[[ContentType]] is ~BigInt~, set _value_ to ? ToBigInt(_value_).
        1. Otherwise, set _value_ to ? ToNumber(_value_).
        1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
        1. If _relativeStart_ is -&infin;, let _k_ be 0.
        1. Else if _relativeStart_ &lt; 0, let _k_ be max(_len_ + _relativeStart_, 0).
        1. Else, let _k_ be min(_relativeStart_, _len_).
        1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
        1. If _relativeEnd_ is -&infin;, let _final_ be 0.
        1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
        1. Else, let _final_ be min(_relativeEnd_, _len_).
        1. <del>If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Set _getBufferByteLength_ to MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. <ins>Set _len_ to IntegerIndexedObjectLength(_O_, _getBufferByteLength_).</ins>
        1. <ins>If _len_ is ~out-of-bounds~, throw a *TypeError* exception.</ins>
        1. <ins>Set _final_ to min(_final_, _len_).</ins>
        1. Repeat, while _k_ &lt; _final_,
          1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
          1. Perform ! Set(_O_, _Pk_, _value_, *true*).
          1. Set _k_ to _k_ + 1.
        1. Return _O_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-%typedarray%.prototype.slice">
      <h1>%TypedArray%.prototype.slice ( _start_, _end_ )</h1>
      <p>The interpretation and use of the arguments of %TypedArray%`.prototype.slice` are the same as for `Array.prototype.slice` as defined in <emu-xref href="#sec-array.prototype.slice"></emu-xref>. The following steps are taken:</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? ValidateTypedArray(_O_).
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. Let _len_ be <del>_O_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_O_, _getBufferByteLength_)</ins>.
        1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
        1. If _relativeStart_ is -&infin;, let _k_ be 0.
        1. Else if _relativeStart_ &lt; 0, let _k_ be max(_len_ + _relativeStart_, 0).
        1. Else, let _k_ be min(_relativeStart_, _len_).
        1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
        1. If _relativeEnd_ is -&infin;, let _final_ be 0.
        1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
        1. Else, let _final_ be min(_relativeEnd_, _len_).
        1. Let _count_ be max(_final_ - _k_, 0).
        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_count_) &raquo;).
        1. If _count_ &gt; 0, then
          1. <del>If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true*, throw a *TypeError* exception.</del>
          1. <ins>Set _getBufferByteLength_ to MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
          1. <ins>Set _len_ to IntegerIndexedObjectLength(_O_, _getBufferByteLength_).</ins>
          1. <ins>If _len_ is ~out-of-bounds~, throw a *TypeError* exception.</ins>
          1. <ins>Set _final_ to min(_final_, _len_).</ins>
          1. Let _srcName_ be the String value of _O_.[[TypedArrayName]].
          1. Let _srcType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
          1. Let _targetName_ be the String value of _A_.[[TypedArrayName]].
          1. Let _targetType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _targetName_.
          1. If _srcType_ is different from _targetType_, then
            1. Let _n_ be 0.
            1. Repeat, while _k_ &lt; _final_,
              1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
              1. Let _kValue_ be ! Get(_O_, _Pk_).
              1. Perform ! Set(_A_, ! ToString(ùîΩ(_n_)), _kValue_, *true*).
              1. Set _k_ to _k_ + 1.
              1. Set _n_ to _n_ + 1.
          1. Else,
            1. Let _srcBuffer_ be _O_.[[ViewedArrayBuffer]].
            1. Let _targetBuffer_ be _A_.[[ViewedArrayBuffer]].
            1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _srcType_.
            1. NOTE: If _srcType_ and _targetType_ are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
            1. Let _srcByteOffset_ be _O_.[[ByteOffset]].
            1. Let _targetByteIndex_ be _A_.[[ByteOffset]].
            1. Let _srcByteIndex_ be (_k_ &times; _elementSize_) + _srcByteOffset_.
            1. Let _limit_ be <ins>min(</ins>_targetByteIndex_ + _count_ &times; _elementSize_<ins>, _len_ &times; _elementSize_)</ins>.
            1. Repeat, while _targetByteIndex_ &lt; _limit_,
              1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~Uint8~, *true*, ~Unordered~).
              1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~Uint8~, _value_, *true*, ~Unordered~).
              1. Set _srcByteIndex_ to _srcByteIndex_ + 1.
              1. Set _targetByteIndex_ to _targetByteIndex_ + 1.
        1. Return _A_.
      </emu-alg>
      <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-%typedarray%.prototype.subarray">
      <h1>%TypedArray%.prototype.subarray ( _begin_, _end_ )</h1>
      <p>Returns a new _TypedArray_ whose element type is the same as this _TypedArray_ and whose ArrayBuffer is the same as the ArrayBuffer of this _TypedArray_, referencing the elements at _begin_, inclusive, up to _end_, exclusive. If either _begin_ or _end_ is negative, it refers to an index from the end of the array, as opposed to from the beginning.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. <ins>Let _getSrcBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. Let _srcLength_ be <del>_O_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_O_, _getSrcBufferByteLength_)</ins>.
        1. <ins>If _srcLength_ is ~out-of-bounds~, set _srcLength_ to 0.</ins>
        1. Let _relativeBegin_ be ? ToIntegerOrInfinity(_begin_).
        1. If _relativeBegin_ is -&infin;, let _beginIndex_ be 0.
        1. Else if _relativeBegin_ &lt; 0, let _beginIndex_ be max(_srcLength_ + _relativeBegin_, 0).
        1. Else, let _beginIndex_ be min(_relativeBegin_, _srcLength_).
        1. <ins>If _O_.[[ArrayLength]] is ~auto~ and _end_ is *undefined*, then</ins>
          1. <ins>Let _newLength_ be *undefined*.</ins>
        1. <ins>Else,</ins>
          1. If _end_ is *undefined*, let _relativeEnd_ be _srcLength_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ is -&infin;, let _endIndex_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _endIndex_ be max(_srcLength_ + _relativeEnd_, 0).
          1. Else, let _endIndex_ be min(_relativeEnd_, _srcLength_).
          1. Let _newLength_ be max(_endIndex_ - _beginIndex_, 0).
        1. Let _constructorName_ be the String value of _O_.[[TypedArrayName]].
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _constructorName_.
        1. Let _srcByteOffset_ be _O_.[[ByteOffset]].
        1. Let _beginByteOffset_ be _srcByteOffset_ + _beginIndex_ &times; _elementSize_.
        1. <ins>If _newLength_ is *undefined*, then</ins>
          1. <ins>Let _argumentsList_ be &laquo; _buffer_, ùîΩ(_beginByteOffset_) &raquo;.</ins>
        1. <ins>Else,</ins>
          1. Let _argumentsList_ be &laquo; _buffer_, ùîΩ(_beginByteOffset_), ùîΩ(_newLength_) &raquo;.
        1. Return ? TypedArraySpeciesCreate(_O_, _argumentsList_).
      </emu-alg>
      <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-settypedarrayfromtypedarray" type="abstract operation" oldids="sec-%typedarray%.prototype.set-typedarray-offset">
      <h1>
        SetTypedArrayFromTypedArray (
          _target_: a TypedArray,
          _targetOffset_: a non-negative integer or +&infin;,
          _source_: a TypedArray,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It sets multiple values in _target_, starting at index _targetOffset_, reading the values from _source_.</dd>
      </dl>
      <emu-alg>
        1. Assert: _source_ is an Object that has a [[TypedArrayName]] internal slot.
        1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getTargetBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. Let _targetLength_ be <del>_target_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_target_, _getTargetBufferByteLength_)</ins>.
        1. <ins>If _targetLength_ is ~out-of-bounds~, throw a *TypeError* exception.</ins>
        1. Let _srcBuffer_ be _source_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.</del>
        1. Let _targetType_ be TypedArrayElementType(_target_).
        1. Let _targetElementSize_ be TypedArrayElementSize(_target_).
        1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
        1. Let _srcType_ be TypedArrayElementType(_source_).
        1. Let _srcElementSize_ be TypedArrayElementSize(_source_).
        1. <ins>Let _getSrcBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. Let _srcLength_ be <del>_source_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_source_, _getSrcBufferByteLength_)</ins>.
        1. <ins>If _srcLength_ is ~out-of-bounds~, throw a *TypeError* exception.</ins>
        1. Let _srcByteOffset_ be _source_.[[ByteOffset]].
        1. If _targetOffset_ is +&infin;, throw a *RangeError* exception.
        1. If _srcLength_ + _targetOffset_ &gt; _targetLength_, throw a *RangeError* exception.
        1. If _target_.[[ContentType]] &ne; _source_.[[ContentType]], throw a *TypeError* exception.
        1. If both IsSharedArrayBuffer(_srcBuffer_) and IsSharedArrayBuffer(_targetBuffer_) are *true*, then
          1. If _srcBuffer_.[[ArrayBufferData]] and _targetBuffer_.[[ArrayBufferData]] are the same Shared Data Block values, let _same_ be *true*; else let _same_ be *false*.
        1. Else, let _same_ be SameValue(_srcBuffer_, _targetBuffer_).
        1. If _same_ is *true*, then
          1. Let _srcByteLength_ be <del>_source_.[[ByteLength]]</del><ins>IntegerIndexedObjectByteLength(_source_, _getSrcBufferByteLength_)</ins>.
          1. Set _srcBuffer_ to ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_).
          1. Let _srcByteIndex_ be 0.
        1. Else, let _srcByteIndex_ be _srcByteOffset_.
        1. Let _targetByteIndex_ be _targetOffset_ &times; _targetElementSize_ + _targetByteOffset_.
        1. Let _limit_ be _targetByteIndex_ + _targetElementSize_ &times; _srcLength_.
        1. If _srcType_ is the same as _targetType_, then
          1. NOTE: If _srcType_ and _targetType_ are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
          1. Repeat, while _targetByteIndex_ &lt; _limit_,
            1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~Uint8~, *true*, ~Unordered~).
            1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~Uint8~, _value_, *true*, ~Unordered~).
            1. Set _srcByteIndex_ to _srcByteIndex_ + 1.
            1. Set _targetByteIndex_ to _targetByteIndex_ + 1.
        1. Else,
          1. Repeat, while _targetByteIndex_ &lt; _limit_,
            1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, ~Unordered~).
            1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~Unordered~).
            1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
            1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-constructors-mods">
    <h1>Modifications to the _TypedArray_ Constructors</h1>

    <emu-clause id="sec-initializetypedarrayfromtypedarray" type="abstract operation" oldids="sec-typedarray-typedarray">
      <h1>
        InitializeTypedArrayFromTypedArray (
          _O_: a TypedArray,
          _srcArray_: a TypedArray,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _srcData_ be _srcArray_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.</del>
        1. Let _elementType_ be TypedArrayElementType(_O_).
        1. Let _elementSize_ be TypedArrayElementSize(_O_).
        1. <ins>Let _getSrcBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. Let _elementLength_ be <del>_srcArray_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_srcArray_, _getSrcBufferByteLength_)</ins>.
        1. <ins>If _elementLength_ is ~out-of-bounds~, throw a *TypeError* exception.</ins>
        1. Let _srcType_ be TypedArrayElementType(_srcArray_).
        1. Let _srcElementSize_ be TypedArrayElementSize(_srcArray_).
        1. Let _srcByteOffset_ be _srcArray_.[[ByteOffset]].
        1. Let _byteLength_ be _elementSize_ &times; _elementLength_.
        1. If _elementType_ is the same as _srcType_, then
          1. Let _data_ be ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_).
        1. Else,
          1. Let _data_ be ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>.
          1. If _srcArray_.[[ContentType]] ‚â† _O_.[[ContentType]], throw a *TypeError* exception.
          1. Let _srcByteIndex_ be _srcByteOffset_.
          1. Let _targetByteIndex_ be 0.
          1. Let _count_ be _elementLength_.
          1. Repeat, while _count_ > 0,
            1. Let _value_ be GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, ~Unordered~).
            1. Perform SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, ~Unordered~).
            1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
            1. Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_.
            1. Set _count_ to _count_ - 1.
        1. Set _O_.[[ViewedArrayBuffer]] to _data_.
        1. Set _O_.[[ByteLength]] to _byteLength_.
        1. Set _O_.[[ByteOffset]] to 0.
        1. Set _O_.[[ArrayLength]] to _elementLength_.
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-initializetypedarrayfromarraybuffer" type="abstract operation" oldids="sec-typedarray-buffer-byteoffset-length">
      <h1>
        InitializeTypedArrayFromArrayBuffer (
          _O_: a TypedArray,
          _buffer_: an ArrayBuffer or a SharedArrayBuffer,
          _byteOffset_: an ECMAScript language value,
          _length_: an ECMAScript language value,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _elementSize_ be TypedArrayElementSize(_O_).
        1. Let _offset_ be ? ToIndex(_byteOffset_).
        1. If _offset_ modulo _elementSize_ &ne; 0, throw a *RangeError* exception.
        1. <ins>Let _bufferIsResizable_ be IsResizableArrayBuffer(_buffer_).</ins>
        1. If _length_ is not *undefined*, then
          1. Let _newLength_ be ? ToIndex(_length_).
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. Let _bufferByteLength_ be <del>_buffer_.[[ArrayBufferByteLength]]</del><ins>ArrayBufferByteLength(_buffer_, ~SeqCst~)</ins>.
        1. <ins>If _length_ is *undefined* and _bufferIsResizable_ is *true*, then</ins>
          1. <ins>If _offset_ &gt; _bufferByteLength_, throw a *RangeError* exception.</ins>
          1. <ins>Set _O_.[[ByteLength]] to ~auto~.</ins>
          1. <ins>Set _O_.[[ArrayLength]] to ~auto~.</ins>
        1. <ins>Else,</ins>
          1. If _length_ is *undefined*, then
            1. If _bufferByteLength_ modulo _elementSize_ &ne; 0, throw a *RangeError* exception.
            1. Let _newByteLength_ be _bufferByteLength_ - _offset_.
            1. If _newByteLength_ &lt; 0, throw a *RangeError* exception.
          1. Else,
            1. Let _newByteLength_ be _newLength_ &times; _elementSize_.
            1. If _offset_ + _newByteLength_ &gt; _bufferByteLength_, throw a *RangeError* exception.
          1. <del>Set _O_.[[ViewedArrayBuffer]] to _buffer_.</del>
          1. Set _O_.[[ByteLength]] to _newByteLength_.
          1. <del>Set _O_.[[ByteOffset]] to _offset_.</del>
          1. Set _O_.[[ArrayLength]] to _newByteLength_ / _elementSize_.
        1. <ins>Set _O_.[[ViewedArrayBuffer]] to _buffer_.</ins>
        1. <ins>Set _O_.[[ByteOffset]] to _offset_.</ins>
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-dataview-objects-mods">
  <h1>Modifications to DataView Objects</h1>

  <emu-clause id="sec-abstract-operations-for-dataview-objects-mods">
    <h1>Modifications to Abstract Operations For DataView Objects</h1>

    <ins class="block">
    <emu-clause id="sec-getviewbytelength" type="abstract operation">
      <h1>
        GetViewByteLength (
          _view_: a DataView,
          _getBufferByteLength_: an Abstract Closure,
        )
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Assert: Type(_view_) is Object and _view_ has a [[DataView]] internal slot.
        1. If _view_.[[ByteLength]] is not ~auto~, return _view_.[[ByteLength]].
        1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
        1. Let _bufferByteLength_ be _getBufferByteLength_(_buffer_).
        1. Return _bufferByteLength_ - _view_.[[ByteOffset]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isviewoutofbounds" type="abstract operation">
      <h1>
        IsViewOutOfBounds (
          _view_: a DataView,
          _getBufferByteLength_: an Abstract Closure,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Assert: Type(_view_) is Object and _view_ has a [[DataView]] internal slot.
        1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_buffer_) is *true*, return *true*.
        1. Let _byteLength_ be GetViewByteLength(_view_, _getBufferByteLength_).
        1. If _byteLength_ &lt; 0, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-getviewvalue" type="abstract operation">
      <h1>
        GetViewValue (
          _view_: an ECMAScript language value,
          _requestIndex_: an ECMAScript language value,
          _isLittleEndian_: an ECMAScript language value,
          _type_: a TypedArray element type,
        ): either a normal completion containing either a Number or a BigInt, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It is used by functions on DataView instances to retrieve values from the view's buffer.</dd>
      </dl>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
        1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _getIndex_ be ? ToIndex(_requestIndex_).
        1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).
        1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~Unordered~).</ins>
        1. <ins>NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.</ins>
        1. <ins>If IsViewOutOfBounds(_view_, _getBufferByteLength_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _viewOffset_ be _view_.[[ByteOffset]].
        1. Let _viewSize_ be <del>_view_.[[ByteLength]]</del><ins>GetViewByteLength(_view_, _getBufferByteLength_)</ins>.
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
        1. If _getIndex_ + _elementSize_ &gt; _viewSize_, throw a *RangeError* exception.
        1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.
        1. Return GetValueFromBuffer(_buffer_, _bufferIndex_, _type_, *false*, ~Unordered~, _isLittleEndian_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setviewvalue" type="abstract operation">
      <h1>
        SetViewValue (
          _view_: an ECMAScript language value,
          _requestIndex_: an ECMAScript language value,
          _isLittleEndian_: an ECMAScript language value,
          _type_: a TypedArray element type,
          _value_: an ECMAScript language value,
        ): either a normal completion containing *undefined* or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It is used by functions on DataView instances to store values into the view's buffer.</dd>
      </dl>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
        1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _getIndex_ be ? ToIndex(_requestIndex_).
        1. If IsBigIntElementType(_type_) is *true*, let _numberValue_ be ? ToBigInt(_value_).
        1. Otherwise, let _numberValue_ be ? ToNumber(_value_).
        1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).
        1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~Unordered~).</ins>
        1. <ins>NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.</ins>
        1. <ins>If IsViewOutOfBounds(_view_, _getBufferByteLength_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _viewOffset_ be _view_.[[ByteOffset]].
        1. Let _viewSize_ be <del>_view_.[[ByteLength]]</del><ins>GetViewByteLength(_view_, _getBufferByteLength_)</ins>.
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
        1. If _getIndex_ + _elementSize_ &gt; _viewSize_, throw a *RangeError* exception.
        1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.
        1. Perform SetValueInBuffer(_buffer_, _bufferIndex_, _type_, _numberValue_, *false*, ~Unordered~, _isLittleEndian_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-constructor-mods">
    <h1>Modifications to the DataView Constructor</h1>

    <emu-clause id="sec-dataview-buffer-byteoffset-bytelength">
      <h1>DataView ( _buffer_ [ , _byteOffset_ [ , _byteLength_ ] ] )</h1>
      <p>When the `DataView` function is called with at least one argument _buffer_, the following steps are taken:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Perform ? RequireInternalSlot(_buffer_, [[ArrayBufferData]]).
        1. Let _offset_ be ? ToIndex(_byteOffset_).
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. Let _bufferByteLength_ be <del>_buffer_.[[ArrayBufferByteLength]]</del><ins>ArrayBufferByteLength(_buffer_, ~SeqCst~)</ins>.
        1. If _offset_ &gt; _bufferByteLength_, throw a *RangeError* exception.
        1. <ins>Let _bufferIsResizable_ be IsResizableArrayBuffer(_buffer_).</ins>
        1. <ins>Let _byteLengthChecked_ be ~empty~.</ins>
        1. <ins>If _bufferIsResizable_ is *true* and _byteLength_ is *undefined*, then</ins>
          1. <ins>Let _viewByteLength_ be ~auto~.</ins>
        1. <del>If</del><ins>Else if</ins> _byteLength_ is *undefined*, then
          1. Let _viewByteLength_ be _bufferByteLength_ - _offset_.
        1. Else,
          1. <ins>Set _byteLengthChecked_ to ? ToIndex(_byteLength_)</ins>.
          1. Let _viewByteLength_ be <del>? ToIndex(_byteLength_)</del><ins>_byteLengthChecked_</ins>.
          1. If _offset_ + _viewByteLength_ &gt; _bufferByteLength_, throw a *RangeError* exception.
        1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%DataView.prototype%"*, &laquo; [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] &raquo;).
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. <ins>Set _bufferByteLength_ be _getBufferByteLength_(_buffer_).</ins>
        1. <ins>If _offset_ &gt; _bufferByteLength_, throw a *RangeError* exception.</ins>
        1. <ins>If _byteLengthChecked_ is not ~empty~, then</ins>
          1. <ins>If _offset_ + _viewByteLength_ &gt; _bufferByteLength_, throw a *RangeError* exception.</ins>
        1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.
        1. Set _O_.[[ByteLength]] to _viewByteLength_.
        1. Set _O_.[[ByteOffset]] to _offset_.
        1. Return _O_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-dataview-prototype-object-mods">
    <h1>Modifications to Properties of the DataView Prototype Object</h1>

    <emu-clause id="sec-get-dataview.prototype.bytelength">
      <h1>get DataView.prototype.byteLength</h1>
      <p>`DataView.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. <ins>If IsViewOutOfBounds(_O_, _getBufferByteLength_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _size_ be <del>_O_.[[ByteLength]]</del><ins>GetViewByteLength(_O_, _getBufferByteLength_)</ins>.
        1. Return ùîΩ(_size_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-dataview.prototype.byteoffset">
      <h1>get DataView.prototype.byteOffset</h1>
      <p>`DataView.prototype.byteOffset` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. <ins>If IsViewOutOfBounds(_O_, _getBufferByteLength_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _offset_ be _O_.[[ByteOffset]].
        1. Return ùîΩ(_offset_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-atomics-mods">
  <h1>Modifications to Atomics</h1>

  <emu-clause id="sec-properties-of-the-atomics-object-mods">
    <h1>Modifications to Properties of the Atomics Object</h1>

    <emu-clause id="sec-atomics.compareexchange">
      <h1>Atomics.compareExchange ( _typedArray_, _index_, _expectedValue_, _replacementValue_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateIntegerTypedArray(_typedArray_).
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. Let _indexedPosition_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. If _typedArray_.[[ContentType]] is ~BigInt~, then
          1. Let _expected_ be ? ToBigInt(_expectedValue_).
          1. Let _replacement_ be ? ToBigInt(_replacementValue_).
        1. Else,
          1. Let _expected_ be ùîΩ(? ToIntegerOrInfinity(_expectedValue_)).
          1. Let _replacement_ be ùîΩ(? ToIntegerOrInfinity(_replacementValue_)).
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~Unordered~).</ins>
        1. <ins>NOTE: Bounds checking is not a synchronizing operation when _typedArray_'s backing buffer is a growable SharedArrayBuffer.</ins>
        1. <ins>Let _length_ be IntegerIndexedObjectLength(_typedArray_, _getBufferByteLength_).</ins>
        1. <ins>If ~length~ is ~out-of-bounds~, throw a *TypeError* exception.</ins>
        1. <ins>If _indexedPosition_ &ge; _length_, throw a *RangeError* exception.</ins>
        1. NOTE: The above check<ins>s</ins> <del>is</del><ins>are</ins> not redundant with the check<ins>s</ins> in ValidateIntegerTypedArray <ins>and ValidateAtomicAccess</ins> because the call to ToBigInt or ToIntegerOrInfinity on the preceding lines can have arbitrary side effects, which could cause the buffer to become detached. <ins>These checks are only needed when _typedArray_'s backing buffer is an ArrayBuffer.</ins>
        1. Let _elementType_ be TypedArrayElementType(_typedArray_).
        1. Let _elementSize_ be TypedArrayElementSize(_typedArray_).
        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
        1. Let _expectedBytes_ be NumericToRawBytes(_elementType_, _expected_, _isLittleEndian_).
        1. Let _replacementBytes_ be NumericToRawBytes(_elementType_, _replacement_, _isLittleEndian_).
        1. If IsSharedArrayBuffer(_buffer_) is *true*, then
          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
          1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
          1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.
          1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
          1. NOTE: The comparison of the expected value and the read value is performed outside of the read-modify-write modification function to avoid needlessly strong synchronization when the expected value is not equal to the read value.
          1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then
            1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:
              1. Return _newBytes_.
            1. Let _event_ be ReadModifyWriteSharedMemory { [[Order]]: ~SeqCst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _indexedPosition_, [[ElementSize]]: _elementSize_, [[Payload]]: _replacementBytes_, [[ModifyOp]]: _second_ }.
          1. Else,
            1. Let _event_ be ReadSharedMemory { [[Order]]: ~SeqCst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _indexedPosition_, [[ElementSize]]: _elementSize_ }.
          1. Append _event_ to _eventList_.
          1. Append Chosen Value Record { [[Event]]: _event_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].
        1. Else,
          1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_indexedPosition_].
          1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then
            1. Store the individual bytes of _replacementBytes_ into _block_, starting at _block_[_indexedPosition_].
        1. Return RawBytesToNumeric(_elementType_, _rawBytesRead_, _isLittleEndian_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.store">
      <h1>Atomics.store ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateIntegerTypedArray(_typedArray_).
        1. Let _indexedPosition_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. If _typedArray_.[[ContentType]] is ~BigInt~, let _v_ be ? ToBigInt(_value_).
        1. Otherwise, let _v_ be ùîΩ(? ToIntegerOrInfinity(_value_)).
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~Unordered~).</ins>
        1. <ins>NOTE: Bounds checking is not a synchronizing operation when _typedArray_'s backing buffer is a growable SharedArrayBuffer.</ins>
        1. <ins>Let _length_ be IntegerIndexedObjectLength(_typedArray_, _getBufferByteLength_).</ins>
        1. <ins>If ~length~ is ~out-of-bounds~, throw a *TypeError* exception.</ins>
        1. <ins>If _indexedPosition_ &ge; _length_, throw a *RangeError* exception.</ins>
        1. Let _elementType_ be TypedArrayElementType(_typedArray_).
        1. Perform SetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _v_, *true*, ~SeqCst~).
        1. Return _v_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-abstract-operations-for-atomics-mods">
    <h1>Modifications to Abstract Operations for Atomics</h1>

    <emu-clause id="sec-atomicreadmodifywrite" type="abstract operation">
      <h1>
        AtomicReadModifyWrite (
          _typedArray_: an ECMAScript language value,
          _index_: an ECMAScript language value,
          _value_: an ECMAScript language value,
          _op_: a read-modify-write modification function,
        ): either a normal completion containing either a Number or a BigInt, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_op_ takes two List of byte values arguments and returns a List of byte values. This operation atomically loads a value, combines it with another value, and stores the result of the combination. It returns the loaded value.</dd>
      </dl>
      <emu-alg>
        1. Let _buffer_ be ? ValidateIntegerTypedArray(_typedArray_).
        1. Let _indexedPosition_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. If _typedArray_.[[ContentType]] is ~BigInt~, let _v_ be ? ToBigInt(_value_).
        1. Otherwise, let _v_ be ùîΩ(? ToIntegerOrInfinity(_value_)).
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~Unordered~).</ins>
        1. <ins>NOTE: Bounds checking is not a synchronizing operation when _typedArray_'s backing buffer is a growable SharedArrayBuffer.</ins>
        1. <ins>Let _length_ be IntegerIndexedObjectLength(_typedArray_, _getBufferByteLength_).</ins>
        1. <ins>If ~length~ is ~out-of-bounds~, throw a *TypeError* exception.</ins>
        1. <ins>If _indexedPosition_ &ge; _length_, throw a *RangeError* exception.</ins>
        1. NOTE: The above check<ins>s</ins> <del>is</del><ins>are</ins> not redundant with the check<ins>s</ins> in ValidateIntegerTypedArray <ins>and ValidateAtomicAccess</ins> because the call to ToBigInt or ToIntegerOrInfinity on the preceding lines can have arbitrary side effects, which could cause the buffer to become detached. <ins>These checks are only needed when _typedArray_'s backing buffer is an ArrayBuffer.</ins>
        1. Let _elementType_ be TypedArrayElementType(_typedArray_).
        1. Return GetModifySetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _v_, _op_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-validateatomicaccess" type="abstract operation">
      <h1>
        ValidateAtomicAccess (
          _typedArray_: a TypedArray,
          _requestIndex_: an ECMAScript language value,
        ): either a normal completion containing an integer or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. <ins>Let _getBufferByteLength_ be MakeIdempotentArrayBufferByteLengthGetter(~Unordered~).</ins>
        1. Let _length_ be <del>_typedArray_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_typedArray_, _getBufferByteLength_)</ins>.
        1. <ins>Assert: _length_ is not ~out-of-bounds~.</ins>
        1. Let _accessIndex_ be ? ToIndex(_requestIndex_).
        1. Assert: _accessIndex_ &ge; 0.
        1. If _accessIndex_ &ge; _length_, throw a *RangeError* exception.
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Return (_accessIndex_ &times; _elementSize_) + _offset_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-maxbytelength-guidelines">
  <h1>Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines</h1>
  <emu-note>
    <p>The following are guidelines for ECMAScript programmers working with resizable ArrayBuffer and growable SharedArrayBuffer.</p>
    <p>We recommend that programs be tested in their deployment environments where possible. The amount of available physical memory differ greatly between hardware devices. Similarly, virtual memory subsystems also differ greatly between hardware devices as well as operating systems. An application that runs without out-of-memory errors on a 64-bit desktop web browser could run out of memory on a 32-bit mobile web browser.</p>
    <p>When choosing a value for the `"maxByteLength"` option for resizable ArrayBuffer and growable SharedArrayBuffer, we recommend that the smallest possible size for the application be chosen. We recommend that `"maxByteLength"` does not exceed 1073741824, or 1GiB.</p>
    <p>Please note that successfully constructing a ResizableArrayBuffer or a growable SharedArrayBuffer for a particular maximum size does not guarantee that future resizes and grows will succeed.</p>
  </emu-note>

  <emu-note>
    <p>The following are guidelines for ECMAScript implementers implementing resizable ArrayBuffer.</p>
    <p>Resizable ArrayBuffer can be implemented as copying upon resize, as in-place growth via reserving virtual memory up front, or as a combination of both for different values of the constructor's `"maxByteLength"` option.</p>
    <p>If a host is multi-tenanted (i.e. it runs many JavaScript applications simultaneously), such as a web browser, and its implementations choose to implement in-place growth by reserving virtual memory, we recommend that both 32-bit and 64-bit implementations throw for values of `"maxByteLength"` &ge; 1GiB to 1.5GiB. This is to reduce the likelihood a single application can exhaust the virtual memory address space and to reduce interoperability risks.</p>
    <p>If a host does not have virtual memory, such as those running on embedded devices without an MMU, or if a host only implements resizing by copying, it may accept any Number value for the `"maxByteLength"` option. However, we recommend a *RangeError* be thrown if a memory block of the requested size can never be allocated. For example, if the requested size is greater than the maximium amount of usable memory on the device.</p>
  </emu-note>

  <emu-note>
    <p>The following are guidelines for ECMAScript implementers implementing growable SharedArrayBuffer.</p>
    <p>We recommend growable SharedArrayBuffer be implemented as in-place growth via reserving virtual memory up front.</p>
    <p>Because grow operations can be concurrent with memory accesses on a growable SharedArrayBuffer, the constraints of the memory model require that even unordered accesses do not "tear" (bits of their values will not be mixed). In practice, this means the underlying data block of a growable SharedArrayBuffer cannot be grown by being copied without stopping the world. We do not recommend stopping the world as an implementation strategy because it introduces a serialization point and is slow.</p>
    <p>Grown memory must appear zeroed from the moment of its creation, including to any racy concurrent accesses. This can be accomplished via zero-filled-on-demand virtual memory pages, or careful synchronization if manually zeroing memory.</p>
    <p>In practice it is difficult to implement growable SharedArrayBuffer by copying on hosts that do not have virtual memory, such as those running on embedded devices without an MMU. Memory usage behaviour of growable SharedArrayBuffers on such hosts may significantly differ from that of hosts with virtual memory. Such hosts should clearly communicate memory usage expectations to users.</p>
  </emu-note>
</emu-clause>

<emu-clause id="omitted-for-brevity">
  <h1>Mechanical Changes Omitted for Brevity</h1>
  <ul>
    <li><p>Uses of [[ArrayLength]] on Integer-Indexed exotic objects are replaced with calls to IntegerIndexedObjectLength.</p></li>
    <li><p>Uses of [[ByteLength]] on Integer-Indexed exotic objects are replaced with calls to IntegerIndexedByteLength.</p></li>
    <li><p>Uses of [[ArrayBufferByteLength]] on buffer objects that may be growable SharedArrayBuffers are replaced with calls to ArrayBufferByteLength.</p></li>
  </ul>
</emu-clause>
