<!doctype html>
<meta charset="utf8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<title>Resizable ArrayBuffer and growable SharedArrayBuffer</title>
<pre class=metadata>
  title: Resizable ArrayBuffer and growable SharedArrayBuffer
  status: proposal
  stage: 3
  location: https://github.com/tc39/proposal-resizablearraybuffer
  copyright: false
  contributors: Shu-yu Guo
</pre>
<emu-intro id="intro">
  <h1>Resizable ArrayBuffer and growable SharedArrayBuffer</h1>
  <p>We extend the `ArrayBuffer` and `SharedArrayBuffer` constructors to take an additional maximum byte length, which would construct dynamically resizable and growable array buffers, respectively. In addition, a `transfer` method is added to the `ArrayBuffer` prototype.</p>
</emu-intro>

<emu-clause id="sec-arraybuffer-objects-mods">
  <h1>Modifications to ArrayBuffer Objects</h1>

  <emu-clause id="sec-abstract-operations-for-arraybuffer-objects-mods">
    <h1>Modifications to Abstract Operations for ArrayBuffer Objects</h1>

    <emu-clause id="sec-detacharraybuffer" aoid="DetachArrayBuffer">
      <h1>DetachArrayBuffer ( _arrayBuffer_ [ , _key_ ] )</h1>
      <p>The abstract operation DetachArrayBuffer takes argument _arrayBuffer_ and optional argument _key_. It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: Type(_arrayBuffer_) is Object and it has [[ArrayBufferData]], [[ArrayBufferByteLength]], and [[ArrayBufferDetachKey]] internal slots.
        1. Assert: IsSharedArrayBuffer(_arrayBuffer_) is *false*.
        1. If _key_ is not present, set _key_ to *undefined*.
        1. If SameValue(_arrayBuffer_.[[ArrayBufferDetachKey]], _key_) is *false*, throw a *TypeError* exception.
        1. Set _arrayBuffer_.[[ArrayBufferData]] to *null*.
        1. Set _arrayBuffer_.[[ArrayBufferByteLength]] to 0.
        1. Return NormalCompletion(*null*).
      </emu-alg>
      <emu-note>
        <p>Detaching an ArrayBuffer instance disassociates the Data Block used as its backing store from the instance and sets the byte length of the buffer to 0. <del>No operations defined by this specification use the DetachArrayBuffer abstract operation. However, an ECMAScript host or implementation may define such operations.</del></p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-allocatearraybuffer" aoid="AllocateArrayBuffer">
      <h1>AllocateArrayBuffer ( _constructor_, _byteLength_<ins>[ , _maxByteLength_ ]</ins> )</h1>
      <p>The abstract operation AllocateArrayBuffer takes arguments _constructor_<del> and</del><ins>,</ins> _byteLength_<ins>, and _maxByteLength_</ins>. It is used to create an ArrayBuffer object. It performs the following steps when called:</p>
      <emu-alg>
        1. <ins>Let _slots_ be &laquo; [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] &raquo;.</ins>
        1. <ins>If _maxByteLength_ is present, append [[ArrayBufferMaxByteLength]] to _slots_.</ins>
        1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *"%ArrayBuffer.prototype%"*, <del>&laquo; [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] &raquo;</del><ins>_slots_</ins>).
        1. Let _block_ be ? CreateByteDataBlock(_byteLength_).
        1. Set _obj_.[[ArrayBufferData]] to _block_.
        1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
        1. <ins>If _maxByteLength_ is present, then</ins>
          1. <ins>Assert: _byteLength_ &le; _maxByteLength_.</ins>
          1. <ins>If it is not possible to create a Data Block _block_ consisting of _maxByteLength_ bytes, throw a *RangeError* exception.</ins>
          1. <ins>NOTE: Resizable ArrayBuffers are designed to be implementable with in-place growth. Implementations reserve the right to throw if, for example, virtual memory cannot be reserved up front.</ins>
          1. <ins>Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.</ins>
        1. Return _obj_.
      </emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-arraybufferlength" aoid="ArrayBufferByteLength">
      <h1>ArrayBufferByteLength ( _arrayBuffer_, _order_ )</h1>
      <p>The abstract operation ArrayBufferByteLength takes arguments _arrayBuffer_ and _order_ (either ~SeqCst~ or ~Unordered~). It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: Type(_arrayBuffer_) is Object and _arrayBuffer_ has an [[ArrayBufferData]] internal slot.
        1. If IsSharedArrayBuffer(_arrayBuffer_) is *true* and _arrayBuffer_ has an [[ArrayBufferByteLengthData]] internal slot, then
          1. Let _bufferByteLengthBlock_ be _O_.[[ArrayBufferByteLengthData]].
          1. Return ‚Ñù(GetValueFromBuffer(_bufferByteLengthBlock_, 0, ~BigUint64~, *true*, _order_)).
        1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
        1. Return _arrayBuffer_.[[ArrayBufferByteLength]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makeidempotentarraybufferbytelengthgetter" aoid="MakeIdempotentArrayBufferByteLengthGetter">
      <h1>MakeIdempotentArrayBufferByteLengthGetter ( _order_ )</h1>
      <p>The abstract operation MakeIdempotentArrayBufferByteLengthGetter takes argument _order_ (either ~SeqCst~ or ~Unordered~). The returned Abstract Closure helps ensure that there there is a single shared memory read event of the byte length data block in the calling operation. It performs the following steps when called:</p>
      <emu-alg>
        1. NOTE: The [[ArrayBuffer]] slot is used for editorial clarity only, that a getter should only be used with a single ArrayBuffer.
        1. Let _lengthStorage_ be { [[ArrayBuffer]]: ~empty~, [[ByteLength]]: ~empty~ }.
        1. Let _getter_ be a new Abstract Closure with parameters (_buffer_) that captures _lengthStorage_ and _order_ and performs the following steps when called:
          1. If _lengthStorage_.[[ByteLength]] is ~empty~, then
            1. Assert: _lengthStorage_.[[ArrayBuffer]] is ~empty~.
            1. Set _lengthStorage_.[[ArrayBuffer]] to _buffer_.
            1. Set _lengthStorage_.[[ByteLength]] to ArrayBufferByteLength(_buffer_, _order_).
          1. Assert: SameValue(_lengthStorage_.[[ArrayBuffer]], _buffer_) is *true*.
          1. Return _lengthStorage_.[[ByteLength]].
        1. Return _getter_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isresizablearraybuffer" aoid="IsResizableArrayBuffer">
      <h1>IsResizableArrayBuffer ( _arrayBuffer_ )</h1>
      <p>The abstract operation IsResizableArrayBuffer takes argument _arrayBuffer_. It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: Type(_arrayBuffer_) is Object and _arrayBuffer_ has an [[ArrayBufferData]] internal slot.
        1. If _buffer_ has an [[ArrayBufferMaxByteLength]] internal slot, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getarraybuffermaxbytelengthoption" aoid="GetArrayBufferMaxByteLengthOption">
      <h1>GetArrayBufferMaxByteLengthOption ( _options_ )</h1>
      <p>The abstract operation GetArrayBufferMaxByteLengthOption takes argument _options_. It performs the following steps when called:</p>
      <emu-alg>
        1. If Type(_options_) is not Object, return ~empty~.
        1. Let _maxByteLength_ be ? Get(_options_, `"maxByteLength"`).
        1. If _maxByteLength_ is *undefined*, return ~empty~.
        1. Return ? ToIndex(_maxByteLength_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hostresizearraybuffer" aoid="HostResizeArrayBuffer">
      <h1>HostResizeArrayBuffer ( _buffer_, _newByteLength_ )</h1>
      <p>The host-defined abstract operation HostResizeArrayBuffer takes arguments _buffer_ (an ArrayBuffer object) and _newByteLength_. It gives the host an opportunity to perform implementation-defined resizing of _buffer_. If the host chooses not to handle resizing of _buffer_, it may return ~unhandled~ for the default behavior.</p>

      <p>The implementation of HostResizeArrayBuffer must conform to the following requirements:</p>
      <ul>
        <li>The abstract operation must return either NormalCompletion(~handled~), NormalCompletion(~unhandled~), or an abrupt throw completion.</li>
        <li>The abstract operation does not detach _buffer_.</li>
        <li>If the abstract operation completes normally with ~handled~, _buffer_.[[ArrayBufferByteLength]] is _newByteLength_.</li>
      </ul>

      <p>The default implementation of HostResizeArrayBuffer is to return ~unhandled~.</p>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-arraybuffer-constructor">
    <h1>The ArrayBuffer Constructor</h1>

    <emu-clause id="sec-arraybuffer-length">
      <h1>ArrayBuffer ( _length_ [ , _options_ ] )</h1>
      <p>When the `ArrayBuffer` function is called with argument _length_<ins> and optional argument _options_</ins>, the following steps are taken:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _byteLength_ be ? ToIndex(_length_).
        1. <ins>Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).</ins>
        1. <ins>If _requestedMaxByteLength_ is ~empty~, then</ins>
          1. <ins>Return ? AllocateArrayBuffer(NewTarget, _byteLength_).</ins>
        1. <ins>If _byteLength_ &gt; _requestedMaxByteLength_, throw a *RangeError* exception.</ins>
        1. Return ? AllocateArrayBuffer(NewTarget, _byteLength_<ins>, _requestedMaxByteLength_</ins>).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object-mods">
    <h1>Modifications to the Properties of the ArrayBuffer Prototype Object</h1>

    <emu-clause id="sec-get-arraybuffer-@@species">
      <h1>get ArrayBuffer [ @@species ]</h1>
      <p>`ArrayBuffer[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Return the *this* value.
      </emu-alg>
      <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
      <emu-note>
        <p>ArrayBuffer prototype methods normally use their *this* value's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour <ins>for the <emu-xref href="#sec-arraybuffer.prototype.slice" title></emu-xref> method</ins> by redefining its @@species property.</p>
      </emu-note>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-get-arraybuffer.prototype.maxbytelength">
      <h1>get ArrayBuffer.prototype.maxByteLength</h1>
      <p>`ArrayBuffer.prototype.maxByteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>ùîΩ</sub>.
        1. If IsResizableArrayBuffer(_O_) is *true*, then
          1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].
        1. Else,
          1. Let _length_ be _O_.[[ArrayBufferByteLength]].
        1. Return ùîΩ(_length_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-arraybuffer.prototype.resizable">
      <h1>get ArrayBuffer.prototype.resizable</h1>
      <p>`ArrayBuffer.prototype.resizable` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. Return IsResizableArrayBuffer(_O_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arraybuffer.prototype.resize">
      <h1>ArrayBuffer.prototype.resize ( _newLength_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
        1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. Let _newByteLength_ be ? ToIntegerOrInfinity(_newLength_).
        1. If _newByteLength_ &lt; 0 or _newByteLength_ &gt; _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.
        1. Let _hostHandled_ be ? HostResizeArrayBuffer(_O_, _newByteLength_).
        1. If _hostHandled_ is ~handled~, return *undefined*.
        1. Let _oldBlock_ be _O_.[[ArrayBufferData]].
        1. Let _newBlock_ be ? CreateByteDataBlock(_newByteLength_).
        1. Let _copyLength_ be min(_newByteLength_, _O_.[[ArrayBufferByteLength]]).
        1. Perform CopyDataBlockBytes(_newBlock_, 0, _oldBlock_, 0, _copyLength_).
        1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations reserve the right to implement this method as in-place growth or shrinkage.
        1. Set _O_.[[ArrayBufferData]] to _newBlock_.
        1. Set _O_.[[ArrayBufferByteLength]] to _newLength_.
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-arraybuffer.prototype.transfer">
      <h1>ArrayBuffer.prototype.transfer ( [ _newLength_ ] )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. If _newLength_ is *undefined*, let _newByteLength_ be _O_.[[ArrayBufferByteLength]].
        1. Else, let _newByteLength_ be ? ToIntegerOrInfinity(_newLength_).
        1. Let _new_ be ? Construct(%ArrayBuffer%, &laquo; ùîΩ(_newByteLength_) &raquo;).
        1. NOTE: This method returns a fixed-length ArrayBuffer.
        1. Let _copyLength_ be min(_newByteLength_, _O_.[[ArrayBufferByteLength]]).
        1. Let _fromBlock_ be _O_.[[ArrayBufferData]].
        1. Let _toBlock_ be _new_.[[ArrayBufferData]].
        1. Perform CopyDataBlockBytes(_toBlock_, 0, _fromBlock_, 0, _copyLength_).
        1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations reserve the right to implement this method as a zero-copy move or a `realloc`.
        1. Perform ! DetachArrayBuffer(_O_).
        1. Return _new_.
      </emu-alg>
      <emu-note>
        <p>The `transfer` method intentionally does not honor the @@species property when creating derived objects.</p>
      </emu-note>
    </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-sharedarraybuffer-objects-mods">
  <h1>Modifications to SharedArrayBuffer Objects</h1>

  <emu-clause id="sec-abstract-operations-for-sharedarraybuffer-objects-mods">
    <h1>Modifications to Abstract Operations for SharedArrayBuffer Objects</h1>

    <emu-clause id="sec-allocatesharedarraybuffer" aoid="AllocateSharedArrayBuffer">
      <h1>AllocateSharedArrayBuffer ( _constructor_, _byteLength_<ins>[ , _maxByteLength_ ]</ins> )</h1>
      <p>The abstract operation AllocateSharedArrayBuffer takes arguments _constructor_<del> and</del><ins>,</ins> _byteLength_<ins>, and optional argument _maxByteLength_</ins>. It is used to create a SharedArrayBuffer object. It performs the following steps when called:</p>
      <emu-alg>
        1. <ins>Let _slots_ be &laquo; [[ArrayBufferData]] &raquo;.</ins>
        1. <ins>If _maxByteLength_ is present, append [[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to _slots_.</ins>
        1. <ins>Else, append [[ArrayBufferByteLength]] to _slots_.</ins>
        1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *"%SharedArrayBuffer.prototype%"*, <del>&laquo; [[ArrayBufferData]], [[ArrayBufferByteLength]] &raquo;</del><ins>_slots_</ins>).
        1. <ins>If _maxByteLength_ is present, then let _allocLength_ be _maxByteLength_.</ins>
        1. <ins>Else, let _allocLength_ be _byteLength_</ins>
        1. Let _block_ be ? CreateSharedByteDataBlock(<del>_byteLength_</del><ins>_allocLength_</ins>).
        1. <ins>NOTE: Growable SharedArrayBuffers must be implemented as in-place growable. Creation of a _maxByteLength_ sized Data Block is a specification mechanism. It may be implemented as committing a _byteLength_ sized buffer while reserving _maxByteLength_ in virtual memory.</ins>
        1. Set _obj_.[[ArrayBufferData]] to _block_.
        1. <ins>If _maxByteLength_ is present, then</ins>
          1. <ins>Assert: _byteLength_ &le; _maxByteLength_.</ins>
          1. <ins>Let _byteLengthBlock_ be ? CreateSharedByteDataBlock(8).</ins>
          1. <ins>Perform SetValueInBuffer(_byteLengthBlock_, 0, ~BigUint64~, ‚Ñ§(_byteLength_), *true*, ~SeqCst~).</ins>
          1. <ins>Set _obj_.[[ArrayBufferByteLengthData]] to _byteLengthBlock_.</ins>
          1. <ins>Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.</ins>
        1. <ins>Else,</ins>
          1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
        1. Return _obj_.
      </emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-hostgrowsharedarraybuffer" aoid="HostGrowSharedArrayBuffer">
      <h1>HostGrowSharedArrayBuffer ( _buffer_, _newByteLength_ )</h1>
      <p>The host-defined abstract operation HostGrowSharedArrayBuffer takes arguments _buffer_ (a growable SharedArrayBuffer object) and _newByteLength_. It gives the host an opportunity to perform implementation-defined growing of _buffer_. If the host chooses not to handle resizing of _buffer_, it may return ~unhandled~ for the default behavior.</p>

      <p>The implementation of HostGrowSharedArrayBuffer must conform to the following requirements:</p>
      <ul>
         <li>The abstract operation must return either NormalCompletion(~handled~), NormalCompletion(~unhandled~), or an abrupt throw completion.</li>
         <li>If the abstract operation does not complete normally with ~unhandled~, and _newByteLength_ &lt; the current byte length of the _buffer_ or _newByteLength_ &gt; _buffer_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.</li>
         <li>Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record. If the abstract operation completes normally with ~handled~, a WriteSharedMemory or ReadModifyWriteSharedMemory event whose [[Order]] is ~SeqCst~, [[Payload]] is NumericToRawBytes(~BigUint64~, _newByteLength_, _isLittleEndian_), [[Block]] is _buffer_.[[ArrayBufferByteLengthData]], [[ByteIndex]] is 0, and [[ElementSize]] is 8 is added to the surrounding agent's candidate execution such that racing calls to `SharedArrayBuffer.prototype.grow` are not "lost", i.e. silently do nothing.</li>
      </ul>

      <p>The default implementation of HostGrowSharedArrayBuffer is to return ~unhandled~.</p>

      <emu-note>
        <p>The second requirement above is intentionally vague about how or when the current byte length of _buffer_ is read. Because the byte length must be updated via an atomic read-modify-write operation on the underlying hardware, architectures that use load-link/store-conditional or load-exclusive/store-exclusive instruction pairs may wish to keep the paired instructions close in the instruction stream. As such, SharedArrayBuffer.prototype.grow itself does not perform bounds checking on _newByteLength_ before calling HostGrowSharedArrayBuffer, nor is there a requirement on when the current byte length is read.</p>
        <p>This is in contrast with HostResizeArrayBuffer, which is guaranteed that the value of _newByteLength_ is &ge; 0 and &le; _buffer_.[[ArrayBufferMaxByteLength]].</p>
      </emu-note>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer-constructor">
    <h1>The SharedArrayBuffer Constructor</h1>

    <emu-clause id="sec-sharedarraybuffer-length">
      <h1>SharedArrayBuffer ( [ _length_ [ , _options_ ] ] )</h1>
      <p>When the `SharedArrayBuffer` function is called with optional arguments _length_ and _options_, the following steps are taken:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _byteLength_ be ? ToIndex(_length_).
        1. <ins>Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).</ins>
        1. <ins>If _requestedMaxByteLength_ is ~empty~, then</ins>
          1. <ins>Return ? AllocateSharedArrayBuffer(NewTarget, _byteLength_).</ins>
        1. <ins>If _byteLength_ &gt; _requestedMaxByteLength_, throw a *RangeError* exception.</ins>
        1. Return ? AllocateSharedArrayBuffer(NewTarget, _byteLength_<ins>, _requestedMaxByteLength_</ins>).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-sharedarraybuffer-prototype-object-mods">
    <h1>Modifications to the Properties of the SharedArrayBuffer Prototype Object</h1>

    <emu-clause id="sec-get-sharedarraybuffer.prototype.bytelength">
      <h1>get SharedArrayBuffer.prototype.byteLength</h1>
      <p>`SharedArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
        1. <del>Let _length_ be _O_.[[ArrayBufferByteLength]].</del>
        1. <ins>Let _length_ be ArrayBufferByteLength(_O_, ~SeqCst~).</ins>
        1. Return ùîΩ(_length_).
      </emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-get-sharedarraybuffer.prototype.growable">
      <h1>get SharedArrayBuffer.prototype.growable</h1>
      <p>`SharedArrayBuffer.prototype.growable` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
        1. Return IsResizableArrayBuffer(_O_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-sharedarraybuffer.prototype.maxbytelength">
      <h1>get SharedArrayBuffer.prototype.maxByteLength</h1>
      <p>`SharedArrayBuffer.prototype.maxByteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
        1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
        1. If IsResizableArrayBuffer(_O_) is *true*, then
          1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].
        1. Else,
          1. Let _length_ be _O_.[[ArrayBufferByteLength]].
        1. Return ùîΩ(_length_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sharedarraybuffer.prototype.grow">
      <h1>SharedArrayBuffer.prototype.grow ( _newLength_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
        1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
        1. Let _newByteLength_ to ? ToIntegerOrInfinity(_newLength_).
        1. Let _hostHandled_ be ? HostGrowSharedArrayBuffer(_O_, _newByteLength_).
        1. If _hostHandled_ is ~handled~, return *undefined*.
        1. Let _rawCurrentByteLengthBytesRead_ be a List of length 8 whose elements are nondeterministically chosen byte values.
        1. NOTE: In implementations, _rawCurrentByteLengthBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
        1. Let _byteLengthBlock_ be _O_.[[ArrayBufferByteLengthData]].
        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
        1. Let _currentByteLength_ be RawBytesToNumeric(~BigUint64~, _rawCurrentByteLengthBytesRead_, _isLittleEndian_).
        1. Let _growFailed_ be *false*.
        1. If _newByteLength_ &lt; _currentByteLength_ or _newByteLength_ &gt; _O_.[[ArrayBufferMaxByteLength]], set _growFailed_ to *true*.
        1. Let _byteLengthDelta_ be _newByteLength_ - _currentByteLength_.
        1. If it is impossible to create a new Shared Data Block value consisting of _byteLengthDelta_ bytes, set _growFailed_ to *true*.
        1. NOTE: No new Shared Data Block is constructed and used here. The observable behaviour of growable SharedArrayBuffers is specified by allocating a max-sized Shared Data Block at construction time, and this step is intended to capture the requirement that implementations that run out of memory must throw a *RangeError*.
        1. NOTE: The above checks help ensure that concurrent calls to SharedArrayBuffer.prototype.grow are totally ordered. For example, consider two racing calls: `sab.grow(10)` and `sab.grow(20)`. One of the two calls is guaranteed to win the race. The call to `sab.grow(10)` will never shrink `sab` even if `sab.grow(20)` happened first.
        1. If _growFailed_ is *false* and _newByteLength_ &ne; _currentByteLength_, then
          1. NOTE: Resizes to the same length explicitly do nothing to avoid gratuitous synchronization.
          1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:
            1. Return _newBytes_.
          1. Let _newByteLengthBytes_ be NumericToRawBytes(~BigUint64~, ‚Ñ§(_newByteLength_), _isLittleEndian_).
          1. Let _event_ be ReadModifyWriteSharedMemory { [[Order]]: ~SeqCst~, [[NoTear]]: *true*, [[Block]]: _byteLengthBlock_, [[ByteIndex]]: 0, [[ElementSize]]: 8, [[Payload]]: _newByteLengthBytes_, [[ModifyOp]]: _second_ }.
          1. NOTE: The new memory is already zeroed, as a _O_.[[ArrayBufferMaxByteLength]] sized Data Block is already allocated. This is a specification mechanism, an implementation is not required to reserve _O_.[[ArrayBufferMaxByteLength]] bytes of physical memory.
        1. Else,
          1. Let _event_ be ReadSharedMemory { [[Order]]: ~SeqCst~, [[NoTear]]: *true*, [[Block]]: _byteLengthBlock_, [[ByteIndex]]: 0, [[ElementSize]]: 8 }.
        1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
        1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
        1. Append _event_ to _eventList_.
        1. Append Chosen Value Record { [[Event]]: _event_, [[ChosenValue]]: _rawCurrentBytesLengthBytesRead_ } to _execution_.[[ChosenValues]].
        1. If _growFailed_ is *true*, throw a *RangeError* exception.
        1. Return *undefined*.
      </emu-alg>
      <emu-note>
        <p>Spurious failures of the compare-exchange to update the length are prohibited. If the bounds checking for the new length passes and the implementation is not out of memory, a ReadModifyWriteSharedMemory event (i.e. a successful compare-exchange) is always added into the candidate execution.</p>
        <p>Many of the above steps are shared with the algorithm steps of Atomics.compareExchange and should be refactored when merged into the full specification.</p>
      </emu-note>
    </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-integer-indexed-exotic-objects-mods">
  <h1>Modifications to Integer-Indexed Exotic Objects</h1>

  <emu-clause id="sec-integer-indexed-exotic-objects-ownpropertykeys">
    <h1>[[OwnPropertyKeys]] ( )</h1>
    <p>The [[OwnPropertyKeys]] internal method of an Integer-Indexed exotic object _O_ takes no arguments. It performs the following steps when called:</p>
    <emu-alg>
      1. Let _keys_ be a new empty List.
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. <del>If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *false*, then</del>
        1. <del>For each integer _i_ starting with 0 such that _i_ &lt; _O_.[[ArrayLength]], in ascending order, do</del>
          1. <del>Add ! ToString(ùîΩ(_i_)) as the last element of _keys_.</del>
      1. <ins>Let _getBufferByteLength_ be ! MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
      1. <ins>Let _len_ be IntegerIndexedObjectLength(_O_, _getBufferByteLength_).</ins>
      1. <ins>For each integer _i_ starting with 0 such that _i_ &lt; _len_, in ascending order, do</ins>
        1. <ins>Add ! ToString(ùîΩ(_i_)) as the last element of _keys_.</ins>
      1. For each own property key _P_ of _O_ such that Type(_P_) is String and _P_ is not an integer index, in ascending chronological order of property creation, do
        1. Add _P_ as the last element of _keys_.
      1. For each own property key _P_ of _O_ such that Type(_P_) is Symbol, in ascending chronological order of property creation, do
        1. Add _P_ as the last element of _keys_.
      1. Return _keys_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-isvalidintegerindex" aoid="IsValidIntegerIndex">
    <h1>IsValidIntegerIndex ( _O_, _index_ )</h1>
    <p>The abstract operation IsValidIntegerIndex takes arguments _O_, _getBufferByteLength_, and _index_. It performs the following steps when called:</p>
    <emu-alg>
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. <del>If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true*, return *false*.</del>
      1. If ! IsIntegralNumber(_index_) is *false*, return *false*.
      1. If _index_ is *-0*<sub>ùîΩ</sub>, return *false*.
      1. <ins>Let _getBufferByteLength_ be ! MakeIdempotentArrayBufferByteLengthGetter(~Unordered~).</ins>
      1. <ins>NOTE: Bounds checking is not a synchronizing operation when _O_'s backing buffer is a growable SharedArrayBuffer.</ins>
      1. If ‚Ñù(_index_) &lt; 0 or ‚Ñù(_index_) &ge; <del>_O_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_O_, _getBufferByteLength_)</ins>, return *false*.
      1. Return *true*.
    </emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-integerindexedobjectbytelength" aoid="IntegerIndexedObjectByteLength">
    <h1>IntegerIndexedObjectByteLength ( _O_, _getBufferByteLength_ )</h1>
    <p>The abstract operation IntegerIndexedObjectByteLength takes arguments _O_ and _getBufferByteLength_. It performs the following steps when called:</p>
    <emu-alg>
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. Let _length_ be IntegerIndexedObjectLength(_O_, _getBufferByteLength_).
      1. If _length_ = 0, return 0.
      1. If _O_.[[ByteLength]] is not ~auto~, return _O_.[[ByteLength]].
      1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _O_.[[TypedArrayName]].
      1. Return _length_ &times; _elementSize_.
    </emu-alg>
    </emu-clause>

  <emu-clause id="sec-integerindexedobjectlength" aoid="IntegerIndexedObjectLength">
    <h1>IntegerIndexedObjectLength ( _O_, _getBufferByteLength_ )</h1>
    <p>The abstract operation IntegerIndexedObjectLength takes arguments _O_ and _getBufferByteLength_. It performs the following steps when called:</p>
    <emu-alg>
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. If IsIntegerIndexedObjectOutOfBounds(_O_, _getBufferByteLength_) is *true*, return 0.
      1. If _O_.[[ArrayLength]] is not ~auto~, return _O_.[[ArrayLength]].
      1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
      1. Let _bufferByteLength_ be _getBufferByteLength_(_buffer_).
      1. Assert: IsResizableArrayBuffer(_buffer_) is *true*.
      1. Let _byteOffset_ be _O_.[[ByteOffset]].
      1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _O_.[[TypedArrayName]].
      1. Let _length_ be floor((_bufferByteLength_ - _byteOffset_) / _elementSize_).
      1. Return _length_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-isintegerindexedobjectoutofbounds" aoid="IsIntegerIndexedObjectOutOfBounds">
    <h1>IsIntegerIndexedObjectOutOfBounds ( _O_, _getBufferByteLength_ )</h1>
    <p>The abstract operation IsIntegerIndexedObjectOutOfBounds takes arguments _O_ and _getBufferByteLength_. It checks if any part of the underlying viewed buffer is out of bounds. It performs the following steps when called:</p>
    <emu-alg>
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
      1. If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true*, return *true*.
      1. Let _bufferByteLength_ be _getBufferByteLength_(_buffer_).
      1. Let _byteOffsetStart_ be _O_.[[ByteOffset]].
      1. If _O_.[[ArrayLength]] is ~auto~, then
        1. Let _byteOffsetEnd_ be _bufferByteLength_.
      1. Else,
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _O_.[[TypedArrayName]].
        1. Let _byteOffsetEnd_ be _byteOffsetStart_ + _O_.[[ArrayLength]] &times; _elementSize_.
      1. If _byteOffsetStart_ &ge; _bufferByteLength_ or _byteOffsetEnd_ &gt; _bufferByteLength_, then return *true*.
      1. Return *false*.
    </emu-alg>
  </emu-clause>
  </ins>
</emu-clause>

<emu-clause id="sec-typedarray-objects-mods">
  <h1>Modifications to TypedArray Objects</h1>

  <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object-mods">
    <h1>Modifications to Properties of the %TypedArray.prototype% Object</h1>

    <emu-clause id="sec-validatetypedarray" aoid="ValidateTypedArray">
      <h1>Runtime Semantics: ValidateTypedArray ( _O_ )</h1>
      <p>The abstract operation ValidateTypedArray takes argument _O_. It performs the following steps when called:</p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getBufferByteLength_ be ! MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. <ins>If IsIntegerIndexedObjectOutOfBounds(_O_, _getBufferByteLength_) is *true*, throw a *TypeError* exception.</ins>
        1. Return _buffer_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.bytelength">
      <h1>get %TypedArray%.prototype.byteLength</h1>
      <p>%TypedArray%`.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_buffer_) is *true*, return *+0*<sub>ùîΩ</sub>.
        1. <ins>Let _getBufferByteLength_ be ! MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. Let _size_ be <del>_O_.[[ByteLength]]</del><ins>IntegerIndexedObjectByteLength(_O_, _getBufferByteLength_)</ins>.
        1. Return ùîΩ(_size_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.byteoffset">
      <h1>get %TypedArray%.prototype.byteOffset</h1>
      <p>%TypedArray%`.prototype.byteOffset` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, return *+0*<sub>ùîΩ</sub>.</del>
        1. <ins>Let _getBufferByteLength_ be ! MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. <ins>If IsIntegerIndexedObjectOutOfBounds(_O_, _getBufferByteLength_) is *true*, return *+0*<sub>ùîΩ</sub>.</ins>
        1. Let _offset_ be _O_.[[ByteOffset]].
        1. Return ùîΩ(_offset_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.length">
      <h1>get %TypedArray%.prototype.length</h1>
      <p>%TypedArray%`.prototype.length` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, return *+0*<sub>ùîΩ</sub>.</del>
        1. <ins>Let _getBufferByteLength_ be ! MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. Let _length_ be <del>_O_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_O_, _getBufferByteLength_)</ins>.
        1. Return ùîΩ(_length_).
      </emu-alg>
      <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-settypedarrayfromtypedarray" aoid="SetTypedArrayFromTypedArray" oldids="sec-%typedarray%.prototype.set-typedarray-offset">
      <h1>SetTypedArrayFromTypedArray ( _target_, _targetOffset_, _source_ )</h1>
      <p>The abstract operation SetTypedArrayFromTypedArray takes arguments _target_ (a TypedArray object), _targetOffset_ (a non-negative integer or +&infin;), and _source_ (a TypedArray object). It sets multiple values in _target_, starting at index _targetOffset_, reading the values from _source_. It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: _source_ is an Object that has a [[TypedArrayName]] internal slot.
        1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
        1. <ins>Let _getSrcBufferByteLength_ be ! MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. Let _targetLength_ be <del>_target_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_target_, _getBufferByteLength_)</ins>.
        1. Let _srcBuffer_ be _source_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>If IsIntegerIndexedObjectOutOfBounds(_target_, _getSrcBufferByteLength_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _targetName_ be the String value of _target_.[[TypedArrayName]].
        1. Let _targetType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _targetName_.
        1. Let _targetElementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _targetName_.
        1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
        1. Let _srcName_ be the String value of _source_.[[TypedArrayName]].
        1. Let _srcType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
        1. Let _srcElementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
        1. Let _srcLength_ be _source_.[[ArrayLength]].
        1. Let _srcByteOffset_ be _source_.[[ByteOffset]].
        1. If _targetOffset_ is +&infin;, throw a *RangeError* exception.
        1. If _srcLength_ + _targetOffset_ &gt; _targetLength_, throw a *RangeError* exception.
        1. If _target_.[[ContentType]] &ne; _source_.[[ContentType]], throw a *TypeError* exception.
        1. If both IsSharedArrayBuffer(_srcBuffer_) and IsSharedArrayBuffer(_targetBuffer_) are *true*, then
          1. If _srcBuffer_.[[ArrayBufferData]] and _targetBuffer_.[[ArrayBufferData]] are the same Shared Data Block values, let _same_ be *true*; else let _same_ be *false*.
        1. Else, let _same_ be SameValue(_srcBuffer_, _targetBuffer_).
        1. If _same_ is *true*, then
          1. Let _srcByteLength_ be <del>_source_.[[ByteLength]]</del><ins>IntegerIndexedObjectByteLength(_source_, _getSrcBufferByteLength_)</ins>.
          1. Set _srcBuffer_ to ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_, %ArrayBuffer%).
          1. NOTE: %ArrayBuffer% is used to clone _srcBuffer_ because is it known to not have any observable side-effects.
          1. Let _srcByteIndex_ be 0.
        1. Else, let _srcByteIndex_ be _srcByteOffset_.
        1. Let _targetByteIndex_ be _targetOffset_ &times; _targetElementSize_ + _targetByteOffset_.
        1. Let _limit_ be _targetByteIndex_ + _targetElementSize_ &times; _srcLength_.
        1. If _srcType_ is the same as _targetType_, then
          1. NOTE: If _srcType_ and _targetType_ are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
          1. Repeat, while _targetByteIndex_ &lt; _limit_,
            1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~Uint8~, *true*, ~Unordered~).
            1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~Uint8~, _value_, *true*, ~Unordered~).
            1. Set _srcByteIndex_ to _srcByteIndex_ + 1.
            1. Set _targetByteIndex_ to _targetByteIndex_ + 1.
        1. Else,
          1. Repeat, while _targetByteIndex_ &lt; _limit_,
            1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, ~Unordered~).
            1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~Unordered~).
            1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
            1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-constructors-mods">
    <h1>Modifications to the _TypedArray_ Constructors</h1>

    <emu-clause id="sec-initializetypedarrayfromtypedarray" aoid="InitializeTypedArrayFromTypedArray" oldids="sec-typedarray-typedarray">
      <h1>InitializeTypedArrayFromTypedArray ( _O_, _srcArray_ )</h1>
      <p>The abstract operation InitializeTypedArrayFromTypedArray takes arguments _O_ (a TypedArray object) and _srcArray_ (a TypedArray object). It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: _O_ is an Object that has a [[TypedArrayName]] internal slot.
        1. Assert: _srcArray_ is an Object that has a [[TypedArrayName]] internal slot.
        1. Let _srcData_ be _srcArray_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.
        1. Let _constructorName_ be the String value of _O_.[[TypedArrayName]].
        1. Let _elementType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _constructorName_.
        1. <ins>Let _getSrcBufferByteLength_ be ! MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. Let _elementLength_ be <del>_srcArray_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_srcArray_, _getSrcBufferByteLength_)</ins>.
        1. Let _srcName_ be the String value of _srcArray_.[[TypedArrayName]].
        1. Let _srcType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
        1. Let _srcElementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
        1. Let _srcByteOffset_ be _srcArray_.[[ByteOffset]].
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _constructorName_.
        1. Let _byteLength_ be _elementSize_ &times; _elementLength_.
        1. If IsSharedArrayBuffer(_srcData_) is *false*, then
          1. Let _bufferConstructor_ be ? SpeciesConstructor(_srcData_, %ArrayBuffer%).
        1. Else,
          1. Let _bufferConstructor_ be %ArrayBuffer%.
        1. If _elementType_ is the same as _srcType_, then
          1. Let _data_ be ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_, _bufferConstructor_).
        1. Else,
          1. Let _data_ be ? AllocateArrayBuffer(_bufferConstructor_, _byteLength_).
          1. <del>If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.</del>
          1. <ins>If IsIntegerIndexedObjectOutOfBounds(_srcArray_, _getSrcBufferByteLength_) is *true*, throw a *TypeError* exception.</ins>
          1. If _srcArray_.[[ContentType]] &ne; _O_.[[ContentType]], throw a *TypeError* exception.
          1. Let _srcByteIndex_ be _srcByteOffset_.
          1. Let _targetByteIndex_ be 0.
          1. Let _count_ be _elementLength_.
          1. Repeat, while _count_ &gt; 0,
            1. Let _value_ be GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, ~Unordered~).
            1. Perform SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, ~Unordered~).
            1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
            1. Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_.
            1. Set _count_ to _count_ - 1.
        1. Set _O_.[[ViewedArrayBuffer]] to _data_.
        1. Set _O_.[[ByteLength]] to _byteLength_.
        1. Set _O_.[[ByteOffset]] to 0.
        1. Set _O_.[[ArrayLength]] to _elementLength_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-initializetypedarrayfromarraybuffer" aoid="InitializeTypedArrayFromArrayBuffer" oldids="sec-typedarray-buffer-byteoffset-length">
      <h1>InitializeTypedArrayFromArrayBuffer ( _O_, _buffer_, _byteOffset_, _length_ )</h1>
      <p>The abstract operation InitializeTypedArrayFromArrayBuffer takes arguments _O_ (a TypedArray object), _buffer_ (an ArrayBuffer object), _byteOffset_ (an ECMAScript language value), and _length_ (an ECMAScript language value). It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: _O_ is an Object that has a [[TypedArrayName]] internal slot.
        1. Assert: _buffer_ is an Object that has an [[ArrayBufferData]] internal slot.
        1. Let _constructorName_ be the String value of _O_.[[TypedArrayName]].
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _constructorName_.
        1. Let _offset_ be ? ToIndex(_byteOffset_).
        1. If _offset_ modulo _elementSize_ &ne; 0, throw a *RangeError* exception
        1. <ins>Let _bufferIsResizable_ be IsResizableArrayBuffer(_buffer_).</ins>.
        1. If _length_ is not *undefined*, then
          1. Let _newLength_ be ? ToIndex(_length_).
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. Let _bufferByteLength_ be <del>_buffer_.[[ArrayBufferByteLength]]</del><ins>ArrayBufferByteLength(_buffer_, ~SeqCst~).</ins>.
        1. <ins>If _length_ is *undefined* and _bufferIsResizable_ is *true*, then</ins>
          1. <ins>If _offset_ &gt; _bufferByteLength_, throw a *RangeError* exception.</ins>
          1. <ins>Set _O_.[[ByteLength]] to ~auto~.</ins>
          1. <ins>Set _O_.[[ArrayLength]] to ~auto~.</ins>
        1. <ins>Else,</ins>
          1. If _length_ is *undefined*, then
            1. If _bufferByteLength_ modulo _elementSize_ &ne; 0, throw a *RangeError* exception.
            1. Let _newByteLength_ be _bufferByteLength_ - _offset_.
            1. If _newByteLength_ &lt; 0, throw a *RangeError* exception.
          1. Else,
            1. Let _newByteLength_ be _newLength_ &times; _elementSize_.
            1. If _offset_ + _newByteLength_ &gt; _bufferByteLength_, throw a *RangeError* exception.
          1. <del>Set _O_.[[ViewedArrayBuffer]] to _buffer_.</del>
          1. Set _O_.[[ByteLength]] to _newByteLength_.
          1. <del>Set _O_.[[ByteOffset]] to _offset_.</del>
          1. Set _O_.[[ArrayLength]] to _newByteLength_ / _elementSize_.
        1. <ins>Set _O_.[[ViewedArrayBuffer]] to _buffer_.</ins>
        1. <ins>Set _O_.[[ByteOffset]] to _offset_.</ins>
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-dataview-objects-mods">
  <h1>Modifications to DataView Objects</h1>

  <emu-clause id="sec-abstract-operations-for-dataview-objects-mods">
    <h1>Modifications to Abstract Operations For DataView Objects</h1>

    <ins class="block">
    <emu-clause id="sec-getviewbytelength" aoid="GetViewByteLength">
      <h1>GetViewByteLength ( _view_, _getBufferByteLength_ )</h1>
      <p>The abstract operation GetViewByteLength takes arguments _view_ and _getBufferByteLength_. It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: Type(_view_) is Object and _view_ has a [[DataView]] internal slot.
        1. If _view_.[[ByteLength]] is not ~auto~, then return _view_.[[ByteLength]].
        1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
        1. Return _getBufferByteLength_(_buffer_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isviewoutofbounds" aoid="IsViewOutOfBounds">
      <h1>IsViewOutOfBounds ( _view_, _getBufferByteLength_ )</h1>
      <p>The abstract operation IsViewOutOfBounds takes arguments _view_ and _getBufferByteLength_. It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: Type(_view_) is Object and _view_ has a [[DataView]] internal slot.
        1. Let _byteLength_ be GetViewByteLength(_view_, _getBufferByteLength_).
        1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true*, return *true*.
        1. Let _bufferByteLength_ be _getBufferByteLength_(_buffer_).
        1. If _view_.[[ByteOffset]] + _byteLength_ &gt; _bufferByteLength_, then return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-getviewvalue" aoid="GetViewValue">
      <h1>GetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_ )</h1>
      <p>The abstract operation GetViewValue takes arguments _view_, _requestIndex_, _isLittleEndian_, and _type_. It is used by functions on DataView instances to retrieve values from the view's buffer. It performs the following steps when called:</p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
        1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _getIndex_ be ? ToIndex(_requestIndex_).
        1. Set _isLittleEndian_ to ! ToBoolean(_isLittleEndian_).
        1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getBufferByteLength_ be ! MakeIdempotentArrayBufferByteLengthGetter(~Unordered~).</ins>
        1. <ins>NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.</ins>
        1. <ins>If IsViewOutOfBounds(_view_, _getBufferByteLength_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _viewOffset_ be _view_.[[ByteOffset]].
        1. Let _viewSize_ be <del>_view_.[[ByteLength]]</del><ins>GetViewByteLength(_view_, _getBufferByteLength_)</ins>.
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
        1. If _getIndex_ + _elementSize_ &gt; _viewSize_, throw a *RangeError* exception.
        1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.
        1. Return GetValueFromBuffer(_buffer_, _bufferIndex_, _type_, *false*, ~Unordered~, _isLittleEndian_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setviewvalue" aoid="SetViewValue">
      <h1>SetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_, _value_ )</h1>
      <p>The abstract operation SetViewValue takes arguments _view_, _requestIndex_, _isLittleEndian_, _type_, and _value_. It is used by functions on DataView instances to store values into the view's buffer. It performs the following steps when called:</p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
        1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _getIndex_ be ? ToIndex(_requestIndex_).
        1. If ! IsBigIntElementType(_type_) is *true*, let _numberValue_ be ? ToBigInt(_value_).
        1. Otherwise, let _numberValue_ be ? ToNumber(_value_).
        1. Set _isLittleEndian_ to ! ToBoolean(_isLittleEndian_).
        1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getBufferByteLength_ be ! MakeIdempotentArrayBufferByteLengthGetter(~Unordered~).</ins>
        1. <ins>NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.</ins>
        1. <ins>If IsViewOutOfBounds(_view_, _getBufferByteLength_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _viewOffset_ be _view_.[[ByteOffset]].
        1. Let _viewSize_ be <del>_view_.[[ByteLength]]</del><ins>GetViewByteLength(_view_, _getBufferByteLength_)</ins>.
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
        1. If _getIndex_ + _elementSize_ &gt; _viewSize_, throw a *RangeError* exception.
        1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.
        1. Return SetValueInBuffer(_buffer_, _bufferIndex_, _type_, _numberValue_, *false*, ~Unordered~, _isLittleEndian_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-constructor-mods">
    <h1>Modifications to the DataView Constructor</h1>

    <emu-clause id="sec-dataview-buffer-byteoffset-bytelength">
      <h1>DataView ( _buffer_ [ , _byteOffset_ [ , _byteLength_ ] ] )</h1>
      <p>When the `DataView` function is called with at least one argument _buffer_, the following steps are taken:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Perform ? RequireInternalSlot(_buffer_, [[ArrayBufferData]]).
        1. Let _offset_ be ? ToIndex(_byteOffset_).
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. Let _bufferByteLength_ be <del>_buffer_.[[ArrayBufferByteLength]]</del><ins>ArrayBufferByteLength(_buffer_, ~SeqCst~).</ins>.
        1. If _offset_ &gt; _bufferByteLength_, throw a *RangeError* exception.
        1. <ins>Let _bufferIsResizable_ be IsResizableArrayBuffer(_buffer_).</ins>
        1. <ins>If _bufferIsResizable_ is *true* and _byteLength_ is *undefined*, then</ins>
          1. <ins>Let _viewByteLength_ be ~auto~.</ins>
        1. <del>I</del><ins>Else i</ins>f _byteLength_ is *undefined*, then
          1. Let _viewByteLength_ be _bufferByteLength_ - _offset_.
        1. Else,
          1. Let _viewByteLength_ be ? ToIndex(_byteLength_).
          1. If _offset_ + _viewByteLength_ &gt; _bufferByteLength_, throw a *RangeError* exception.
        1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%DataView.prototype%"*, &laquo; [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] &raquo;).
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.
        1. Set _O_.[[ByteLength]] to _viewByteLength_.
        1. Set _O_.[[ByteOffset]] to _offset_.
        1. Return _O_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-dataview-prototype-object-mods">
    <h1>Modifications to Properties of the DataView Prototype Object</h1>

    <emu-clause id="sec-get-dataview.prototype.bytelength">
      <h1>get DataView.prototype.byteLength</h1>
      <p>`DataView.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getBufferByteLength_ be ! MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. <ins>If IsViewOutOfBounds(_O_, _getBufferByteLength_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _size_ be <del>_O_.[[ByteLength]]</del><ins>GetViewByteLength(_O_, _getBufferByteLength_)</ins>.
        1. Return ùîΩ(_size_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-dataview.prototype.byteoffset">
      <h1>get DataView.prototype.byteOffset</h1>
      <p>`DataView.prototype.byteOffset` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. <del>If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.</del>
        1. <ins>Let _getBufferByteLength_ be ! MakeIdempotentArrayBufferByteLengthGetter(~SeqCst~).</ins>
        1. <ins>If IsViewOutOfBounds(_O_, _getBufferByteLength_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _offset_ be _O_.[[ByteOffset]].
        1. Return ùîΩ(_offset_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations-for-atomics-mods">
  <h1>Modifications to Abstract Operations for Atomics</h1>

  <emu-clause id="sec-validateatomicaccess" aoid="ValidateAtomicAccess">
    <h1>ValidateAtomicAccess ( _typedArray_, _requestIndex_ )</h1>
    <p>The abstract operation ValidateAtomicAccess takes arguments _typedArray_ and _requestIndex_. It performs the following steps when called:</p>
    <emu-alg>
      1. Assert: _typedArray_ is an Object that has a [[ViewedArrayBuffer]] internal slot.
      1. <ins>Let _getBufferByteLength_ be ! MakeIdempotentArrayBufferByteLengthGetter(~Unordered~).</ins>
      1. Let _length_ be <del>_typedArray_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_typedArray_, _getBufferByteLength_)</ins>.
      1. Let _accessIndex_ be ? ToIndex(_requestIndex_).
      1. Assert: _accessIndex_ &ge; 0.
      1. If _accessIndex_ &ge; _length_, throw a *RangeError* exception.
      1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
      1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _arrayTypeName_.
      1. Let _offset_ be _typedArray_.[[ByteOffset]].
      1. Return (_accessIndex_ &times; _elementSize_) + _offset_.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-maxbytelength-guidelines">
  <h1>Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines</h1>
  <emu-note>
    <p>The following are guidelines for ECMAScript programmers working with resizable ArrayBuffer and growable SharedArrayBuffer.</p>
    <p>We recommend that programs be tested in their deployment environments where possible. The amount of available physical memory differ greatly between hardware devices. Similarly, virtual memory subsystems also differ greatly between hardware devices as well as operating systems. An application that runs without out-of-memory errors on a 64-bit desktop web browser could run out of memory on a 32-bit mobile web browser.</p>
    <p>When choosing a value for the `"maxByteLength"` option for resizable ArrayBuffer and growable SharedArrayBuffer, we recommend that the smallest possible size for the application be chosen. We recommend that `"maxByteLength"` does not exceed 1073741824, or 1GiB.</p>
    <p>Please note that successfully constructing a ResizableArrayBuffer or a growable SharedArrayBuffer for a particular maximum size does not guarantee that future resizes and grows will succeed.</p>
  </emu-note>

  <emu-note>
    <p>The following are guidelines for ECMAScript implementers implementing resizable ArrayBuffer.</p>
    <p>Resizable ArrayBuffer can be implemented as copying upon resize, as in-place growth via reserving virtual memory up front, or as a combination of both for different values of the constructor's `"maxByteLength"` option.</p>
    <p>If a host is multi-tenanted (i.e. it runs many JavaScript applications simultaneously), such as a web browser, and its implementations choose to implement in-place growth by reserving virtual memory, we recommend that both 32-bit and 64-bit implementations throw for values of `"maxByteLength"` &ge; 1GiB to 1.5GiB. This is to reduce the likelihood a single application can exhaust the virtual memory address space and to reduce interoperability risks.</p>
    <p>If a host does not have virtual memory, such as those running on embedded devices without an MMU, or if a host only implements resizing by copying, it may accept any Number value for the `"maxByteLength"` option. However, we recommend a *RangeError* be thrown if a memory block of the requested size can never be allocated. For example, if the requested size is greater than the maximium amount of usable memory on the device.</p>
  </emu-note>

  <emu-note>
    <p>The following are guidelines for ECMAScript implementers implementing growable SharedArrayBuffer.</p>
    <p>We recommend growable SharedArrayBuffer be implemented as in-place growth via reserving virtual memory up front.</p>
    <p>Because grow operations can be concurrent with memory accesses on a growable SharedArrayBuffer, the constraints of the memory model require that even unordered accesses do not "tear" (bits of their values will not be mixed). In practice, this means the underlying data block of a growable SharedArrayBuffer cannot be grown by being copied without stopping the world. We do not recommend stopping the world as an implementation strategy because it introduces a serialization point and is slow.</p>
    <p>Grown memory must appear zeroed from the moment of its creation, including to any racy concurrent accesses. This can be accomplished via zero-filled-on-demand virtual memory pages, or careful synchronization if manually zeroing memory.</p>
    <p>In practice it is difficult to implement growable SharedArrayBuffer by copying on hosts that do not have virtual memory, such as those running on embedded devices without an MMU. Memory usage behaviour of growable SharedArrayBuffers on such hosts may significantly differ from that of hosts with virtual memory. Such hosts should clearly communicate memory usage expectations to users.</p>
  </emu-note>
</emu-clause>

<emu-clause id="omitted-for-brevity">
  <h1>Mechanical Changes Omitted for Brevity</h1>
  <ul>
    <li><p>Uses of [[ArrayLength]] on Integer-Indexed exotic objects are replaced with calls to IntegerIndexedObjectLength.</p></li>
    <li><p>Uses of [[ByteLength]] on Integer-Indexed exotic objects are replaced with calls to IntegerIndexedByteLength.</p></li>
    <li><p>Uses of [[ArrayBufferByteLength]] on buffer objects that may be growable SharedArrayBuffers are replaced with calls to ArrayBufferByteLength.</p></li>
  </ul>
</emu-clause>
