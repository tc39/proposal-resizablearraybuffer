<!doctype html>
<head><meta charset="utf-8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/styles/base16/solarized-light.min.css"><link rel="stylesheet" href="ecmarkup.css">
<title>Resizable ArrayBuffer and growable SharedArrayBuffer</title>
</head><body><div id="shortcuts-help">
<ul>
  <li><span>Toggle shortcuts help</span><code>?</code></li>
  <li><span>Toggle "can call user code" annotations</span><code>u</code></li>

  <li><span>Jump to search box</span><code>/</code></li>
</ul></div><div id="menu-toggle"><svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%; stroke:currentColor" viewBox="0 0 120 120">
      <title>Menu</title>
      <path stroke-width="10" stroke-linecap="round" d="M30,60 h60  M30,30 m0,5 h60  M30,90 m0,-5 h60"></path>
    </svg></div><div id="menu-spacer" class="menu-spacer"></div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-pins"><div class="menu-pane-header">Pins</div><ul id="menu-pins-list"></ul></div><div class="menu-pane-header">Table of Contents</div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Resizable ArrayBuffer and growable SharedArrayBuffer">Resizable ArrayBuffer and growable SharedArrayBuffer</a></li><li><span class="item-toggle">◢</span><a href="#sec-arraybuffer-objects-mods" title="Modifications to ArrayBuffer Objects"><span class="secnum">1</span> Modifications to ArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-arraybuffer-objects-mods" title="Modifications to Abstract Operations for ArrayBuffer Objects"><span class="secnum">1.1</span> Modifications to Abstract Operations for ArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-detacharraybuffer" title="DetachArrayBuffer ( arrayBuffer [ , key ] )"><span class="secnum">1.1.1</span> DetachArrayBuffer ( <var>arrayBuffer</var> [ , <var>key</var> ] )</a></li><li><span class="item-toggle-none"></span><a href="#sec-allocatearraybuffer" title="AllocateArrayBuffer ( constructor, byteLength [ , maxByteLength ] )"><span class="secnum">1.1.2</span> AllocateArrayBuffer ( <var>constructor</var>, <var>byteLength</var> [ , <ins><var>maxByteLength</var></ins> ] )</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybufferlength" title="ArrayBufferByteLength ( arrayBuffer, order )"><span class="secnum">1.1.3</span> ArrayBufferByteLength ( <var>arrayBuffer</var>, <var>order</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-makeidempotentarraybufferbytelengthgetter" title="MakeIdempotentArrayBufferByteLengthGetter ( order )"><span class="secnum">1.1.4</span> MakeIdempotentArrayBufferByteLengthGetter ( <var>order</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isresizablearraybuffer" title="IsResizableArrayBuffer ( arrayBuffer )"><span class="secnum">1.1.5</span> IsResizableArrayBuffer ( <var>arrayBuffer</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-getarraybuffermaxbytelengthoption" title="GetArrayBufferMaxByteLengthOption ( options )"><span class="secnum">1.1.6</span> GetArrayBufferMaxByteLengthOption ( <var>options</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-hostresizearraybuffer" title="HostResizeArrayBuffer ( buffer, newByteLength )"><span class="secnum">1.1.7</span> HostResizeArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-arraybuffer-constructor" title="The ArrayBuffer Constructor"><span class="secnum">1.2</span> The ArrayBuffer Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer-length" title="ArrayBuffer ( length [ , options ] )"><span class="secnum">1.2.1</span> ArrayBuffer ( <var>length</var> <ins>[ , <var>options</var> ]</ins> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-arraybuffer-prototype-object-mods" title="Modifications to the Properties of the ArrayBuffer Prototype Object"><span class="secnum">1.3</span> Modifications to the Properties of the ArrayBuffer Prototype Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-arraybuffer-@@species" title="get ArrayBuffer [ @@species ]"><span class="secnum">1.3.1</span> get ArrayBuffer [ @@species ]</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-arraybuffer.prototype.maxbytelength" title="get ArrayBuffer.prototype.maxByteLength"><span class="secnum">1.3.2</span> get ArrayBuffer.prototype.maxByteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-arraybuffer.prototype.resizable" title="get ArrayBuffer.prototype.resizable"><span class="secnum">1.3.3</span> get ArrayBuffer.prototype.resizable</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer.prototype.slice" title="ArrayBuffer.prototype.slice ( start, end )"><span class="secnum">1.3.4</span> ArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer.prototype.resize" title="ArrayBuffer.prototype.resize ( newLength )"><span class="secnum">1.3.5</span> ArrayBuffer.prototype.resize ( <var>newLength</var> )</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-sharedarraybuffer-objects-mods" title="Modifications to SharedArrayBuffer Objects"><span class="secnum">2</span> Modifications to SharedArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-sharedarraybuffer-objects-mods" title="Modifications to Abstract Operations for SharedArrayBuffer Objects"><span class="secnum">2.1</span> Modifications to Abstract Operations for SharedArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-allocatesharedarraybuffer" title="AllocateSharedArrayBuffer ( constructor, byteLength [ , maxByteLength ] )"><span class="secnum">2.1.1</span> AllocateSharedArrayBuffer ( <var>constructor</var>, <var>byteLength</var> [ , <ins><var>maxByteLength</var></ins> ] )</a></li><li><span class="item-toggle-none"></span><a href="#sec-hostgrowsharedarraybuffer" title="HostGrowSharedArrayBuffer ( buffer, newByteLength )"><span class="secnum">2.1.2</span> HostGrowSharedArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-sharedarraybuffer-constructor" title="The SharedArrayBuffer Constructor"><span class="secnum">2.2</span> The SharedArrayBuffer Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-sharedarraybuffer-length" title="SharedArrayBuffer ( length [ , options ] )"><span class="secnum">2.2.1</span> SharedArrayBuffer ( <var>length</var> <ins>[ , <var>options</var> ]</ins> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-sharedarraybuffer-prototype-object-mods" title="Modifications to the Properties of the SharedArrayBuffer Prototype Object"><span class="secnum">2.3</span> Modifications to the Properties of the SharedArrayBuffer Prototype Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-sharedarraybuffer.prototype.bytelength" title="get SharedArrayBuffer.prototype.byteLength"><span class="secnum">2.3.1</span> get SharedArrayBuffer.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-sharedarraybuffer.prototype.growable" title="get SharedArrayBuffer.prototype.growable"><span class="secnum">2.3.2</span> get SharedArrayBuffer.prototype.growable</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-sharedarraybuffer.prototype.maxbytelength" title="get SharedArrayBuffer.prototype.maxByteLength"><span class="secnum">2.3.3</span> get SharedArrayBuffer.prototype.maxByteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-sharedarraybuffer.prototype.grow" title="SharedArrayBuffer.prototype.grow ( newLength )"><span class="secnum">2.3.4</span> SharedArrayBuffer.prototype.grow ( <var>newLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-sharedarraybuffer.prototype.slice" title="SharedArrayBuffer.prototype.slice ( start, end )"><span class="secnum">2.3.5</span> SharedArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-integer-indexed-exotic-objects-mods" title="Modifications to Integer-Indexed Exotic Objects"><span class="secnum">3</span> Modifications to Integer-Indexed Exotic Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-integer-indexed-exotic-objects-ownpropertykeys" title="[[OwnPropertyKeys]] ( )"><span class="secnum">3.1</span> [[OwnPropertyKeys]] ( )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isvalidintegerindex" title="IsValidIntegerIndex ( O, index )"><span class="secnum">3.2</span> IsValidIntegerIndex ( <var>O</var>, <var>index</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-integerindexedobjectbytelength" title="IntegerIndexedObjectByteLength ( O, getBufferByteLength )"><span class="secnum">3.3</span> IntegerIndexedObjectByteLength ( <var>O</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-integerindexedobjectlength" title="IntegerIndexedObjectLength ( O, getBufferByteLength )"><span class="secnum">3.4</span> IntegerIndexedObjectLength ( <var>O</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isintegerindexedobjectoutofbounds" title="IsIntegerIndexedObjectOutOfBounds ( O, getBufferByteLength )"><span class="secnum">3.5</span> IsIntegerIndexedObjectOutOfBounds ( <var>O</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isarraybufferviewoutofbounds" title="IsArrayBufferViewOutOfBounds ( O )"><span class="secnum">3.6</span> IsArrayBufferViewOutOfBounds ( <var>O</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-typedarray-objects-mods" title="Modifications to TypedArray Objects"><span class="secnum">4</span> Modifications to TypedArray Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-%typedarrayprototype%-object-mods" title="Modifications to Properties of the %TypedArray.prototype% Object"><span class="secnum">4.1</span> Modifications to Properties of the %TypedArray.prototype% Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-validatetypedarray" title="ValidateTypedArray ( O )"><span class="secnum">4.1.1</span> ValidateTypedArray ( <var>O</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-%typedarray%.prototype.bytelength" title="get %TypedArray%.prototype.byteLength"><span class="secnum">4.1.2</span> get %TypedArray%.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-%typedarray%.prototype.byteoffset" title="get %TypedArray%.prototype.byteOffset"><span class="secnum">4.1.3</span> get %TypedArray%.prototype.byteOffset</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-%typedarray%.prototype.length" title="get %TypedArray%.prototype.length"><span class="secnum">4.1.4</span> get %TypedArray%.prototype.length</a></li><li><span class="item-toggle-none"></span><a href="#sec-%typedarray%.prototype.copywithin" title="%TypedArray%.prototype.copyWithin ( target, start [ , end ] )"><span class="secnum">4.1.5</span> %TypedArray%.prototype.copyWithin ( <var>target</var>, <var>start</var> [ , <var>end</var> ] )</a></li><li><span class="item-toggle-none"></span><a href="#sec-%typedarray%.prototype.fill" title="%TypedArray%.prototype.fill ( value [ , start [ , end ] ] )"><span class="secnum">4.1.6</span> %TypedArray%.prototype.fill ( <var>value</var> [ , <var>start</var> [ , <var>end</var> ] ] )</a></li><li><span class="item-toggle-none"></span><a href="#sec-%typedarray%.prototype.slice" title="%TypedArray%.prototype.slice ( start, end )"><span class="secnum">4.1.7</span> %TypedArray%.prototype.slice ( <var>start</var>, <var>end</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-%typedarray%.prototype.subarray" title="%TypedArray%.prototype.subarray ( begin, end )"><span class="secnum">4.1.8</span> %TypedArray%.prototype.subarray ( <var>begin</var>, <var>end</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-settypedarrayfromtypedarray" title="SetTypedArrayFromTypedArray ( target, targetOffset, source )"><span class="secnum">4.1.9</span> SetTypedArrayFromTypedArray ( <var>target</var>, <var>targetOffset</var>, <var>source</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-typedarray-constructors-mods" title="Modifications to the TypedArray Constructors"><span class="secnum">4.2</span> Modifications to the <var>TypedArray</var> Constructors</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-initializetypedarrayfromtypedarray" title="InitializeTypedArrayFromTypedArray ( O, srcArray )"><span class="secnum">4.2.1</span> InitializeTypedArrayFromTypedArray ( <var>O</var>, <var>srcArray</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-initializetypedarrayfromarraybuffer" title="InitializeTypedArrayFromArrayBuffer ( O, buffer, byteOffset, length )"><span class="secnum">4.2.2</span> InitializeTypedArrayFromArrayBuffer ( <var>O</var>, <var>buffer</var>, <var>byteOffset</var>, <var>length</var> )</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-dataview-objects-mods" title="Modifications to DataView Objects"><span class="secnum">5</span> Modifications to DataView Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-dataview-objects-mods" title="Modifications to Abstract Operations For DataView Objects"><span class="secnum">5.1</span> Modifications to Abstract Operations For DataView Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-getviewbytelength" title="GetViewByteLength ( view, getBufferByteLength )"><span class="secnum">5.1.1</span> GetViewByteLength ( <var>view</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isviewoutofbounds" title="IsViewOutOfBounds ( view, getBufferByteLength )"><span class="secnum">5.1.2</span> IsViewOutOfBounds ( <var>view</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-getviewvalue" title="GetViewValue ( view, requestIndex, isLittleEndian, type )"><span class="secnum">5.1.3</span> GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-setviewvalue" title="SetViewValue ( view, requestIndex, isLittleEndian, type, value )"><span class="secnum">5.1.4</span> SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-dataview-constructor-mods" title="Modifications to the DataView Constructor"><span class="secnum">5.2</span> Modifications to the DataView Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-dataview-buffer-byteoffset-bytelength" title="DataView ( buffer [ , byteOffset [ , byteLength ] ] )"><span class="secnum">5.2.1</span> DataView ( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>byteLength</var> ] ] )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-dataview-prototype-object-mods" title="Modifications to Properties of the DataView Prototype Object"><span class="secnum">5.3</span> Modifications to Properties of the DataView Prototype Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-dataview.prototype.bytelength" title="get DataView.prototype.byteLength"><span class="secnum">5.3.1</span> get DataView.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-dataview.prototype.byteoffset" title="get DataView.prototype.byteOffset"><span class="secnum">5.3.2</span> get DataView.prototype.byteOffset</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-atomics-mods" title="Modifications to Atomics"><span class="secnum">6</span> Modifications to Atomics</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-atomics-object-mods" title="Modifications to Properties of the Atomics Object"><span class="secnum">6.1</span> Modifications to Properties of the Atomics Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-atomics.compareexchange" title="Atomics.compareExchange ( typedArray, index, expectedValue, replacementValue )"><span class="secnum">6.1.1</span> Atomics.compareExchange ( <var>typedArray</var>, <var>index</var>, <var>expectedValue</var>, <var>replacementValue</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-atomics.store" title="Atomics.store ( typedArray, index, value )"><span class="secnum">6.1.2</span> Atomics.store ( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-atomics-mods" title="Modifications to Abstract Operations for Atomics"><span class="secnum">6.2</span> Modifications to Abstract Operations for Atomics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-atomicreadmodifywrite" title="AtomicReadModifyWrite ( typedArray, index, value, op )"><span class="secnum">6.2.1</span> AtomicReadModifyWrite ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>op</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-validateatomicaccess" title="ValidateAtomicAccess ( typedArray, requestIndex )"><span class="secnum">6.2.2</span> ValidateAtomicAccess ( <var>typedArray</var>, <var>requestIndex</var> )</a></li></ol></li></ol></li><li><span class="item-toggle-none"></span><a href="#sec-maxbytelength-guidelines" title="Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines"><span class="secnum">7</span> Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines</a></li><li><span class="item-toggle-none"></span><a href="#omitted-for-brevity" title="Mechanical Changes Omitted for Brevity"><span class="secnum">8</span> Mechanical Changes Omitted for Brevity</a></li></ol></div></div><div id="spec-container"><h1 class="version">Stage 3 Draft / December 3, 2022</h1>
<emu-intro id="intro">
  <h1>Resizable ArrayBuffer and growable SharedArrayBuffer</h1>
  <p>We extend the <code>ArrayBuffer</code> and <code>SharedArrayBuffer</code> <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructors</a></emu-xref> to take an additional maximum byte length, which would construct dynamically resizable and growable array buffers, respectively.</p>
</emu-intro>

<emu-clause id="sec-arraybuffer-objects-mods">
  <h1><span class="secnum">1</span> Modifications to ArrayBuffer Objects</h1>

  <emu-clause id="sec-abstract-operations-for-arraybuffer-objects-mods">
    <h1><span class="secnum">1.1</span> Modifications to Abstract Operations for ArrayBuffer Objects</h1>

    <emu-clause id="sec-detacharraybuffer" type="abstract operation" aoid="DetachArrayBuffer">
      <h1><span class="secnum">1.1.1</span> DetachArrayBuffer ( <var>arrayBuffer</var> [ , <var>key</var> ] )</h1>
      <p>The abstract operation DetachArrayBuffer takes argument <var>arrayBuffer</var> (an ArrayBuffer) and optional argument <var>key</var> (anything) and returns either a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> <emu-const>unused</emu-const> or a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>. It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>If <var>key</var> is not present, set <var>key</var> to <emu-val>undefined</emu-val>.</li><li>If <var>arrayBuffer</var>.[[ArrayBufferDetachKey]] is not <var>key</var>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Set <var>arrayBuffer</var>.[[ArrayBufferData]] to <emu-val>null</emu-val>.</li><li>Set <var>arrayBuffer</var>.[[ArrayBufferByteLength]] to 0.</li><li>Return <emu-const>unused</emu-const>.</li></ol></emu-alg>
      <emu-note><span class="note">Note</span><div class="note-contents">
        <p>Detaching an ArrayBuffer instance disassociates the <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> used as its backing store from the instance and sets the byte length of the buffer to 0. <del>No operations defined by this specification use the DetachArrayBuffer abstract operation. However, an ECMAScript <emu-xref href="#host"><a href="https://tc39.es/ecma262/#host">host</a></emu-xref> or implementation may define such operations.</del></p>
      </div></emu-note>
    </emu-clause>

    <emu-clause id="sec-allocatearraybuffer" type="abstract operation" aoid="AllocateArrayBuffer">
      <h1><span class="secnum">1.1.2</span> AllocateArrayBuffer ( <var>constructor</var>, <var>byteLength</var> [ , <ins><var>maxByteLength</var></ins> ] )</h1>
      <p>The abstract operation AllocateArrayBuffer takes arguments <var>constructor</var> (a <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref>) and <var>byteLength</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref>) and optional argument <ins><var>maxByteLength</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> or <emu-const>empty</emu-const>)</ins> and returns either a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> an ArrayBuffer or a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>. It is used to create an ArrayBuffer. It performs the following steps when called:</p>
      <emu-alg><ol><li><ins>Let <var>slots</var> be « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] ».</ins></li><li><ins>If <var>maxByteLength</var> is present and not <emu-const>empty</emu-const>, then</ins><ol><li><ins>If <var>byteLength</var> &gt; <var>maxByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li><ins>Append [[ArrayBufferMaxByteLength]] to <var>slots</var>.</ins></li></ol></li><li>Let <var>obj</var> be ?&nbsp;<emu-xref aoid="OrdinaryCreateFromConstructor"><a href="https://tc39.es/ecma262/#sec-ordinarycreatefromconstructor" class="e-user-code">OrdinaryCreateFromConstructor</a></emu-xref>(<var>constructor</var>, <emu-val>"%ArrayBuffer.prototype%"</emu-val>, <del>« [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] »</del><ins><var>slots</var></ins>).</li><li>Let <var>block</var> be ?&nbsp;<emu-xref aoid="CreateByteDataBlock"><a href="https://tc39.es/ecma262/#sec-createbytedatablock">CreateByteDataBlock</a></emu-xref>(<var>byteLength</var>).</li><li>Set <var>obj</var>.[[ArrayBufferData]] to <var>block</var>.</li><li>Set <var>obj</var>.[[ArrayBufferByteLength]] to <var>byteLength</var>.</li><li><ins>If <var>maxByteLength</var> is present and not <emu-const>empty</emu-const>, then</ins><ol><li><ins>If it is not possible to create a <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> <var>block</var> consisting of <var>maxByteLength</var> bytes, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li><ins>NOTE: Resizable ArrayBuffers are designed to be implementable with in-place growth. Implementations reserve the right to throw if, for example, virtual memory cannot be reserved up front.</ins></li><li><ins>Set <var>obj</var>.[[ArrayBufferMaxByteLength]] to <var>maxByteLength</var>.</ins></li></ol></li><li>Return <var>obj</var>.</li></ol></emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-arraybufferlength" type="abstract operation" aoid="ArrayBufferByteLength">
      <h1><span class="secnum">1.1.3</span> ArrayBufferByteLength ( <var>arrayBuffer</var>, <var>order</var> )</h1>
      <p>The abstract operation ArrayBufferByteLength takes arguments <var>arrayBuffer</var> (an ArrayBuffer) and <var>order</var> (<emu-const>SeqCst</emu-const> or <emu-const>Unordered</emu-const>) and returns a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref>. It performs the following steps when called:</p>
      <emu-alg><ol><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val> and <var>arrayBuffer</var> has an [[ArrayBufferByteLengthData]] internal slot, then<ol><li>Let <var>bufferByteLengthBlock</var> be <var>arrayBuffer</var>.[[ArrayBufferByteLengthData]].</li><li>Return <emu-xref aoid="ℝ"><a href="https://tc39.es/ecma262/#ℝ">ℝ</a></emu-xref>(<emu-xref aoid="GetValueFromBuffer"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>bufferByteLengthBlock</var>, 0, <emu-const>BigUint64</emu-const>, <emu-val>true</emu-val>, <var>order</var>)).</li></ol></li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>Return <var>arrayBuffer</var>.[[ArrayBufferByteLength]].</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-makeidempotentarraybufferbytelengthgetter" type="abstract operation" aoid="MakeIdempotentArrayBufferByteLengthGetter">
      <h1><span class="secnum">1.1.4</span> MakeIdempotentArrayBufferByteLengthGetter ( <var>order</var> )</h1>
      <p>The abstract operation MakeIdempotentArrayBufferByteLengthGetter takes argument <var>order</var> (<emu-const>SeqCst</emu-const> or <emu-const>Unordered</emu-const>) and returns an <emu-xref href="#sec-abstract-closure"><a href="https://tc39.es/ecma262/#sec-abstract-closure">Abstract Closure</a></emu-xref> with one parameter. The returned <emu-xref href="#sec-abstract-closure"><a href="https://tc39.es/ecma262/#sec-abstract-closure">Abstract Closure</a></emu-xref> helps ensure that there there is a single shared memory read event of the byte length data block in the calling operation. It performs the following steps when called:</p>
      <emu-alg><ol><li>NOTE: The [[ArrayBuffer]] slot is used for editorial clarity only, that a getter should only be used with a single ArrayBuffer.</li><li>Let <var>lengthStorage</var> be { [[ArrayBuffer]]: <emu-const>empty</emu-const>, [[ByteLength]]: <emu-const>empty</emu-const> }.</li><li>Let <var>getter</var> be a new <emu-xref href="#sec-abstract-closure"><a href="https://tc39.es/ecma262/#sec-abstract-closure">Abstract Closure</a></emu-xref> with parameters (<var>buffer</var>) that captures <var>lengthStorage</var> and <var>order</var> and performs the following steps when called:<ol><li>If <var>lengthStorage</var>.[[ByteLength]] is <emu-const>empty</emu-const>, then<ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>lengthStorage</var>.[[ArrayBuffer]] is <emu-const>empty</emu-const>.</li><li>Set <var>lengthStorage</var>.[[ArrayBuffer]] to <var>buffer</var>.</li><li>Set <var>lengthStorage</var>.[[ByteLength]] to <emu-xref aoid="ArrayBufferByteLength" id="_ref_1"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>buffer</var>, <var>order</var>).</li></ol></li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="SameValue"><a href="https://tc39.es/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>lengthStorage</var>.[[ArrayBuffer]], <var>buffer</var>) is <emu-val>true</emu-val>.</li><li>Return <var>lengthStorage</var>.[[ByteLength]].</li></ol></li><li>Return <var>getter</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-isresizablearraybuffer" type="abstract operation" aoid="IsResizableArrayBuffer">
      <h1><span class="secnum">1.1.5</span> IsResizableArrayBuffer ( <var>arrayBuffer</var> )</h1>
      <p>The abstract operation IsResizableArrayBuffer takes argument <var>arrayBuffer</var> (an ArrayBuffer) and returns a Boolean. It performs the following steps when called:</p>
      <emu-alg><ol><li>If <var>arrayBuffer</var> has an [[ArrayBufferMaxByteLength]] internal slot, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-getarraybuffermaxbytelengthoption" type="abstract operation" aoid="GetArrayBufferMaxByteLengthOption">
      <h1><span class="secnum">1.1.6</span> GetArrayBufferMaxByteLengthOption ( <var>options</var> )</h1>
      <p>The abstract operation GetArrayBufferMaxByteLengthOption takes argument <var>options</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>) and returns a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> either a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> or <emu-const>empty</emu-const>. It performs the following steps when called:</p>
      <emu-alg><ol><li>If <emu-xref aoid="Type"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>options</var>) is not Object, return <emu-const>empty</emu-const>.</li><li>Let <var>maxByteLength</var> be ?&nbsp;<emu-xref aoid="Get"><a href="https://tc39.es/ecma262/#sec-get-o-p" class="e-user-code">Get</a></emu-xref>(<var>options</var>, <code>"maxByteLength"</code>).</li><li>If <var>maxByteLength</var> is <emu-val>undefined</emu-val>, return <emu-const>empty</emu-const>.</li><li>Return ?&nbsp;<emu-xref aoid="ToIndex"><a href="https://tc39.es/ecma262/#sec-toindex" class="e-user-code">ToIndex</a></emu-xref>(<var>maxByteLength</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-hostresizearraybuffer" type="host-defined abstract operation" aoid="HostResizeArrayBuffer">
      <h1><span class="secnum">1.1.7</span> HostResizeArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</h1>
      <p>The <emu-xref href="#host-defined"><a href="https://tc39.es/ecma262/#host-defined">host-defined</a></emu-xref> abstract operation HostResizeArrayBuffer takes arguments <var>buffer</var> (an ArrayBuffer) and <var>newByteLength</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref>) and returns either a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> either <emu-const>handled</emu-const> or <emu-const>unhandled</emu-const>, or a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>. The <emu-xref href="#host-defined"><a href="https://tc39.es/ecma262/#host-defined">host-defined</a></emu-xref> abstract operation HostResizeArrayBuffer takes arguments <var>buffer</var> (an ArrayBuffer object) and <var>newByteLength</var>. It gives the <emu-xref href="#host"><a href="https://tc39.es/ecma262/#host">host</a></emu-xref> an opportunity to perform <emu-xref href="#implementation-defined"><a href="https://tc39.es/ecma262/#implementation-defined">implementation-defined</a></emu-xref> resizing of <var>buffer</var>. If the <emu-xref href="#host"><a href="https://tc39.es/ecma262/#host">host</a></emu-xref> chooses not to handle resizing of <var>buffer</var>, it may return <emu-const>unhandled</emu-const> for the default behaviour.</p>

      <p>The implementation of HostResizeArrayBuffer must conform to the following requirements:</p>
      <ul>
        <li>The abstract operation must return either <emu-xref aoid="NormalCompletion"><a href="https://tc39.es/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-const>handled</emu-const>), <emu-xref aoid="NormalCompletion"><a href="https://tc39.es/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-const>unhandled</emu-const>), or an abrupt <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>.</li>
        <li>The abstract operation does not detach <var>buffer</var>.</li>
        <li>If the abstract operation completes normally with <emu-const>handled</emu-const>, <var>buffer</var>.[[ArrayBufferByteLength]] is <var>newByteLength</var>.</li>
      </ul>

      <p>The default implementation of HostResizeArrayBuffer is to return <emu-const>unhandled</emu-const>.</p>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-arraybuffer-constructor">
    <h1><span class="secnum">1.2</span> The ArrayBuffer Constructor</h1>

    <emu-clause id="sec-arraybuffer-length">
      <h1><span class="secnum">1.2.1</span> ArrayBuffer ( <var>length</var> <ins>[ , <var>options</var> ]</ins> )</h1>
      <p>When the <code>ArrayBuffer</code> function is called with argument <var>length</var><ins> and optional argument <var>options</var></ins>, the following steps are taken:</p>
      <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>byteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex"><a href="https://tc39.es/ecma262/#sec-toindex" class="e-user-code">ToIndex</a></emu-xref>(<var>length</var>).</li><li><ins>Let <var>requestedMaxByteLength</var> be ?&nbsp;<emu-xref aoid="GetArrayBufferMaxByteLengthOption" id="_ref_2"><a href="#sec-getarraybuffermaxbytelengthoption" class="e-user-code">GetArrayBufferMaxByteLengthOption</a></emu-xref>(<var>options</var>).</ins></li><li>Return ?&nbsp;<emu-xref aoid="AllocateArrayBuffer" id="_ref_3"><a href="#sec-allocatearraybuffer" class="e-user-code">AllocateArrayBuffer</a></emu-xref>(NewTarget, <var>byteLength</var><ins>, <var>requestedMaxByteLength</var></ins>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object-mods">
    <h1><span class="secnum">1.3</span> Modifications to the Properties of the ArrayBuffer Prototype Object</h1>

    <emu-clause id="sec-get-arraybuffer-@@species">
      <h1><span class="secnum">1.3.1</span> get ArrayBuffer [ @@species ]</h1>
      <p><code>ArrayBuffer[@@species]</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Return the <emu-val>this</emu-val> value.</li></ol></emu-alg>
      <p>The value of the <emu-val>"name"</emu-val> property of this function is <emu-val>"get [Symbol.species]"</emu-val>.</p>
      <emu-note><span class="note">Note</span><div class="note-contents">
        <p>ArrayBuffer prototype methods normally use their <emu-val>this</emu-val> value's <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref> to create a derived object. However, a subclass <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref> may over-ride that default behaviour <ins>for the <emu-xref href="#sec-arraybuffer.prototype.slice" title="" id="_ref_0"><a href="#sec-arraybuffer.prototype.slice">ArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</a></emu-xref> method</ins> by redefining its <emu-xref href="#sec-well-known-symbols"><a href="https://tc39.es/ecma262/#sec-well-known-symbols">@@species</a></emu-xref> property.</p>
      </div></emu-note>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-get-arraybuffer.prototype.maxbytelength">
      <h1><span class="secnum">1.3.2</span> get ArrayBuffer.prototype.maxByteLength</h1>
      <p><code>ArrayBuffer.prototype.maxByteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</li><li>If <emu-xref aoid="IsResizableArrayBuffer" id="_ref_4"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferMaxByteLength]].</li></ol></li><li>Else,<ol><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferByteLength]].</li></ol></li><li>Return <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-arraybuffer.prototype.resizable">
      <h1><span class="secnum">1.3.3</span> get ArrayBuffer.prototype.resizable</h1>
      <p><code>ArrayBuffer.prototype.resizable</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <emu-xref aoid="IsResizableArrayBuffer" id="_ref_5"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>).</li></ol></emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-arraybuffer.prototype.slice">
      <h1><span class="secnum">1.3.4</span> ArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>len</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Let <var>relativeStart</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>start</var>).</li><li>If <var>relativeStart</var> is -∞, let <var>first</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>first</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>first</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>end</var>).</li><li>If <var>relativeEnd</var> is -∞, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>newLen</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>final</var> - <var>first</var>, 0).</li><li>Let <var>ctor</var> be ?&nbsp;<emu-xref aoid="SpeciesConstructor"><a href="https://tc39.es/ecma262/#sec-speciesconstructor" class="e-user-code">SpeciesConstructor</a></emu-xref>(<var>O</var>, <emu-xref href="#sec-arraybuffer-constructor" id="_ref_6"><a href="#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li><li>Let <var>new</var> be ?&nbsp;<emu-xref aoid="Construct"><a href="https://tc39.es/ecma262/#sec-construct" class="e-user-code">Construct</a></emu-xref>(<var>ctor</var>, « <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>newLen</var>) »).</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>new</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>new</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>new</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="SameValue"><a href="https://tc39.es/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>new</var>, <var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>new</var>.[[ArrayBufferByteLength]] &lt; <var>newLen</var>, throw a <emu-val>TypeError</emu-val> exception.</li><li>NOTE: Side-effects of the above steps may have detached <ins>or resized </ins><var>O</var>.</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>fromBuf</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBuf</var> be <var>new</var>.[[ArrayBufferData]].</li><li><ins>If <var>first</var> &lt; <var>O</var>.[[ArrayBufferByteLength]], then</ins><ol><li>Perform <emu-xref aoid="CopyDataBlockBytes"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBuf</var>, 0, <var>fromBuf</var>, <var>first</var>, <ins><emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>O</var>.[[ArrayBufferByteLength]], </ins><var>newLen</var><ins>)</ins>).</li></ol></li><li>Return <var>new</var>.</li></ol></emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-arraybuffer.prototype.resize">
      <h1><span class="secnum">1.3.5</span> ArrayBuffer.prototype.resize ( <var>newLength</var> )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>newByteLength</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>newLength</var>).</li><li>If <var>newByteLength</var> &lt; 0 or <var>newByteLength</var> &gt; <var>O</var>.[[ArrayBufferMaxByteLength]], throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>hostHandled</var> be ?&nbsp;<emu-xref aoid="HostResizeArrayBuffer" id="_ref_7"><a href="#sec-hostresizearraybuffer">HostResizeArrayBuffer</a></emu-xref>(<var>O</var>, <var>newByteLength</var>).</li><li>If <var>hostHandled</var> is <emu-const>handled</emu-const>, return <emu-val>undefined</emu-val>.</li><li>Let <var>oldBlock</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>newBlock</var> be ?&nbsp;<emu-xref aoid="CreateByteDataBlock"><a href="https://tc39.es/ecma262/#sec-createbytedatablock">CreateByteDataBlock</a></emu-xref>(<var>newByteLength</var>).</li><li>Let <var>copyLength</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>newByteLength</var>, <var>O</var>.[[ArrayBufferByteLength]]).</li><li>Perform <emu-xref aoid="CopyDataBlockBytes"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>newBlock</var>, 0, <var>oldBlock</var>, 0, <var>copyLength</var>).</li><li>NOTE: Neither creation of the new <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> nor copying from the old <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> are observable. Implementations reserve the right to implement this method as in-place growth or shrinkage.</li><li>Set <var>O</var>.[[ArrayBufferData]] to <var>newBlock</var>.</li><li>Set <var>O</var>.[[ArrayBufferByteLength]] to <var>newLength</var>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>
    </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-sharedarraybuffer-objects-mods">
  <h1><span class="secnum">2</span> Modifications to SharedArrayBuffer Objects</h1>

  <emu-clause id="sec-abstract-operations-for-sharedarraybuffer-objects-mods">
    <h1><span class="secnum">2.1</span> Modifications to Abstract Operations for SharedArrayBuffer Objects</h1>

    <emu-clause id="sec-allocatesharedarraybuffer" type="abstract operation" aoid="AllocateSharedArrayBuffer">
      <h1><span class="secnum">2.1.1</span> AllocateSharedArrayBuffer ( <var>constructor</var>, <var>byteLength</var> [ , <ins><var>maxByteLength</var></ins> ] )</h1>
      <p>The abstract operation AllocateSharedArrayBuffer takes arguments <var>constructor</var> (a <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref>) and <var>byteLength</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref>) and optional argument <ins><var>maxByteLength</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> or <emu-const>empty</emu-const>)</ins> and returns either a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> a SharedArrayBuffer or a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>. It is used to create a SharedArrayBuffer. It performs the following steps when called:</p>
      <emu-alg><ol><li><ins>Let <var>slots</var> be « [[ArrayBufferData]] ».</ins></li><li><ins>If <var>maxByteLength</var> is present and not <emu-const>empty</emu-const>, then</ins><ol><li><ins>If <var>byteLength</var> &gt; <var>maxByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li><ins>Append [[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to <var>slots</var>.</ins></li></ol></li><li><ins>Else, append [[ArrayBufferByteLength]] to <var>slots</var>.</ins></li><li>Let <var>obj</var> be ?&nbsp;<emu-xref aoid="OrdinaryCreateFromConstructor"><a href="https://tc39.es/ecma262/#sec-ordinarycreatefromconstructor" class="e-user-code">OrdinaryCreateFromConstructor</a></emu-xref>(<var>constructor</var>, <emu-val>"%SharedArrayBuffer.prototype%"</emu-val>, <del>« [[ArrayBufferData]], [[ArrayBufferByteLength]] »</del><ins><var>slots</var></ins>).</li><li><ins>If <var>maxByteLength</var> is present, let <var>allocLength</var> be <var>maxByteLength</var>.</ins></li><li><ins>Else, let <var>allocLength</var> be <var>byteLength</var>.</ins></li><li>Let <var>block</var> be ?&nbsp;<emu-xref aoid="CreateSharedByteDataBlock"><a href="https://tc39.es/ecma262/#sec-createsharedbytedatablock">CreateSharedByteDataBlock</a></emu-xref>(<del><var>byteLength</var></del><ins><var>allocLength</var></ins>).</li><li><ins>NOTE: Growable SharedArrayBuffers must be implemented as in-place growable. Creation of a <var>maxByteLength</var> sized <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> is a specification mechanism. It may be implemented as committing a <var>byteLength</var> sized buffer while reserving <var>maxByteLength</var> in virtual memory.</ins></li><li>Set <var>obj</var>.[[ArrayBufferData]] to <var>block</var>.</li><li><ins>If <var>maxByteLength</var> is present and not <emu-const>empty</emu-const>, then</ins><ol><li><ins><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>byteLength</var> ≤ <var>maxByteLength</var>.</ins></li><li><ins>Let <var>byteLengthBlock</var> be ?&nbsp;<emu-xref aoid="CreateSharedByteDataBlock"><a href="https://tc39.es/ecma262/#sec-createsharedbytedatablock">CreateSharedByteDataBlock</a></emu-xref>(8).</ins></li><li><ins>Perform <emu-xref aoid="SetValueInBuffer"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>byteLengthBlock</var>, 0, <emu-const>BigUint64</emu-const>, <emu-xref aoid="ℤ"><a href="https://tc39.es/ecma262/#ℤ">ℤ</a></emu-xref>(<var>byteLength</var>), <emu-val>true</emu-val>, <emu-const>SeqCst</emu-const>).</ins></li><li><ins>Set <var>obj</var>.[[ArrayBufferByteLengthData]] to <var>byteLengthBlock</var>.</ins></li><li><ins>Set <var>obj</var>.[[ArrayBufferMaxByteLength]] to <var>maxByteLength</var>.</ins></li></ol></li><li><ins>Else,</ins><ol><li>Set <var>obj</var>.[[ArrayBufferByteLength]] to <var>byteLength</var>.</li></ol></li><li>Return <var>obj</var>.</li></ol></emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-hostgrowsharedarraybuffer" type="host-defined abstract operation" aoid="HostGrowSharedArrayBuffer">
      <h1><span class="secnum">2.1.2</span> HostGrowSharedArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</h1>
      <p>The <emu-xref href="#host-defined"><a href="https://tc39.es/ecma262/#host-defined">host-defined</a></emu-xref> abstract operation HostGrowSharedArrayBuffer takes arguments <var>buffer</var> (a SharedArrayBuffer) and <var>newByteLength</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref>) and returns either a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> either <emu-const>handled</emu-const> or <emu-const>unhandled</emu-const>, or a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>. It gives the <emu-xref href="#host"><a href="https://tc39.es/ecma262/#host">host</a></emu-xref> an opportunity to perform <emu-xref href="#implementation-defined"><a href="https://tc39.es/ecma262/#implementation-defined">implementation-defined</a></emu-xref> growing of <var>buffer</var>. If the <emu-xref href="#host"><a href="https://tc39.es/ecma262/#host">host</a></emu-xref> chooses not to handle resizing of <var>buffer</var>, it may return <emu-const>unhandled</emu-const> for the default behaviour.</p>
      <p>The implementation of HostGrowSharedArrayBuffer must conform to the following requirements:</p>
      <ul>
         <li>The abstract operation must return either <emu-xref aoid="NormalCompletion"><a href="https://tc39.es/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-const>handled</emu-const>), <emu-xref aoid="NormalCompletion"><a href="https://tc39.es/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-const>unhandled</emu-const>), or an abrupt <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>.</li>
         <li>If the abstract operation does not complete normally with <emu-const>unhandled</emu-const>, and <var>newByteLength</var> &lt; the current byte length of the <var>buffer</var> or <var>newByteLength</var> &gt; <var>buffer</var>.[[ArrayBufferMaxByteLength]], throw a <emu-val>RangeError</emu-val> exception.</li>
         <li>Let <var>isLittleEndian</var> be the value of the [[LittleEndian]] field of the <emu-xref href="#surrounding-agent"><a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a></emu-xref>'s <emu-xref href="#agent-record"><a href="https://tc39.es/ecma262/#agent-record">Agent Record</a></emu-xref>. If the abstract operation completes normally with <emu-const>handled</emu-const>, a <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">WriteSharedMemory</a></emu-xref> or <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">ReadModifyWriteSharedMemory</a></emu-xref> event whose [[Order]] is <emu-const>SeqCst</emu-const>, [[Payload]] is <emu-xref aoid="NumericToRawBytes"><a href="https://tc39.es/ecma262/#sec-numerictorawbytes">NumericToRawBytes</a></emu-xref>(<emu-const>BigUint64</emu-const>, <var>newByteLength</var>, <var>isLittleEndian</var>), [[Block]] is <var>buffer</var>.[[ArrayBufferByteLengthData]], [[ByteIndex]] is 0, and [[ElementSize]] is 8 is added to the <emu-xref href="#surrounding-agent"><a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a></emu-xref>'s <emu-xref href="#sec-candidate-executions"><a href="https://tc39.es/ecma262/#sec-candidate-executions">candidate execution</a></emu-xref> such that racing calls to <code>SharedArrayBuffer.prototype.grow</code> are not "lost", i.e. silently do nothing.</li>
      </ul>

      <p>The default implementation of HostGrowSharedArrayBuffer is to return <emu-const>unhandled</emu-const>.</p>

      <emu-note><span class="note">Note</span><div class="note-contents">
        <p>The second requirement above is intentionally vague about how or when the current byte length of <var>buffer</var> is read. Because the byte length must be updated via an atomic read-modify-write operation on the underlying hardware, architectures that use load-link/store-conditional or load-exclusive/store-exclusive instruction pairs may wish to keep the paired instructions close in the instruction stream. As such, SharedArrayBuffer.prototype.grow itself does not perform bounds checking on <var>newByteLength</var> before calling HostGrowSharedArrayBuffer, nor is there a requirement on when the current byte length is read.</p>
        <p>This is in contrast with <emu-xref aoid="HostResizeArrayBuffer" id="_ref_8"><a href="#sec-hostresizearraybuffer">HostResizeArrayBuffer</a></emu-xref>, which is guaranteed that the value of <var>newByteLength</var> is ≥ 0 and ≤ <var>buffer</var>.[[ArrayBufferMaxByteLength]].</p>
      </div></emu-note>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer-constructor">
    <h1><span class="secnum">2.2</span> The SharedArrayBuffer Constructor</h1>

    <emu-clause id="sec-sharedarraybuffer-length">
      <h1><span class="secnum">2.2.1</span> SharedArrayBuffer ( <var>length</var> <ins>[ , <var>options</var> ]</ins> )</h1>
      <p>When the <code>SharedArrayBuffer</code> function is called with argument <var>length</var><ins> and optional argument <var>options</var></ins>, the following steps are taken:</p>
      <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>byteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex"><a href="https://tc39.es/ecma262/#sec-toindex" class="e-user-code">ToIndex</a></emu-xref>(<var>length</var>).</li><li><ins>Let <var>requestedMaxByteLength</var> be ?&nbsp;<emu-xref aoid="GetArrayBufferMaxByteLengthOption" id="_ref_9"><a href="#sec-getarraybuffermaxbytelengthoption" class="e-user-code">GetArrayBufferMaxByteLengthOption</a></emu-xref>(<var>options</var>).</ins></li><li>Return ?&nbsp;<emu-xref aoid="AllocateSharedArrayBuffer" id="_ref_10"><a href="#sec-allocatesharedarraybuffer" class="e-user-code">AllocateSharedArrayBuffer</a></emu-xref>(NewTarget, <var>byteLength</var><ins>, <var>requestedMaxByteLength</var></ins>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-sharedarraybuffer-prototype-object-mods">
    <h1><span class="secnum">2.3</span> Modifications to the Properties of the SharedArrayBuffer Prototype Object</h1>

    <emu-clause id="sec-get-sharedarraybuffer.prototype.bytelength">
      <h1><span class="secnum">2.3.1</span> get SharedArrayBuffer.prototype.byteLength</h1>
      <p><code>SharedArrayBuffer.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>length</var> be <del><var>O</var>.[[ArrayBufferByteLength]]</del><ins><emu-xref aoid="ArrayBufferByteLength" id="_ref_11"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>O</var>, <emu-const>SeqCst</emu-const>)</ins>.</li><li>Return <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-get-sharedarraybuffer.prototype.growable">
      <h1><span class="secnum">2.3.2</span> get SharedArrayBuffer.prototype.growable</h1>
      <p><code>SharedArrayBuffer.prototype.growable</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <emu-xref aoid="IsResizableArrayBuffer" id="_ref_12"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-sharedarraybuffer.prototype.maxbytelength">
      <h1><span class="secnum">2.3.3</span> get SharedArrayBuffer.prototype.maxByteLength</h1>
      <p><code>SharedArrayBuffer.prototype.maxByteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsResizableArrayBuffer" id="_ref_13"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferMaxByteLength]].</li></ol></li><li>Else,<ol><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferByteLength]].</li></ol></li><li>Return <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-sharedarraybuffer.prototype.grow">
      <h1><span class="secnum">2.3.4</span> SharedArrayBuffer.prototype.grow ( <var>newLength</var> )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>newByteLength</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>newLength</var>).</li><li>Let <var>hostHandled</var> be ?&nbsp;<emu-xref aoid="HostGrowSharedArrayBuffer" id="_ref_14"><a href="#sec-hostgrowsharedarraybuffer">HostGrowSharedArrayBuffer</a></emu-xref>(<var>O</var>, <var>newByteLength</var>).</li><li>If <var>hostHandled</var> is <emu-const>handled</emu-const>, return <emu-val>undefined</emu-val>.</li><li>Let <var>rawCurrentByteLengthBytesRead</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length 8 whose elements are nondeterministically chosen <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">byte values</a></emu-xref>.</li><li>NOTE: In implementations, <var>rawCurrentByteLengthBytesRead</var> is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the <emu-xref href="#sec-memory-model"><a href="https://tc39.es/ecma262/#sec-memory-model">memory model</a></emu-xref> to describe observable behaviour of hardware with weak consistency.</li><li>Let <var>byteLengthBlock</var> be <var>O</var>.[[ArrayBufferByteLengthData]].</li><li>Let <var>isLittleEndian</var> be the value of the [[LittleEndian]] field of the <emu-xref href="#surrounding-agent"><a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a></emu-xref>'s <emu-xref href="#agent-record"><a href="https://tc39.es/ecma262/#agent-record">Agent Record</a></emu-xref>.</li><li>Let <var>currentByteLength</var> be <emu-xref aoid="RawBytesToNumeric"><a href="https://tc39.es/ecma262/#sec-rawbytestonumeric">RawBytesToNumeric</a></emu-xref>(<emu-const>BigUint64</emu-const>, <var>rawCurrentByteLengthBytesRead</var>, <var>isLittleEndian</var>).</li><li>Let <var>growFailed</var> be <emu-val>false</emu-val>.</li><li>If <var>newByteLength</var> &lt; <var>currentByteLength</var> or <var>newByteLength</var> &gt; <var>O</var>.[[ArrayBufferMaxByteLength]], set <var>growFailed</var> to <emu-val>true</emu-val>.</li><li>Let <var>byteLengthDelta</var> be <var>newByteLength</var> - <var>currentByteLength</var>.</li><li>If it is impossible to create a new <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> value consisting of <var>byteLengthDelta</var> bytes, set <var>growFailed</var> to <emu-val>true</emu-val>.</li><li>NOTE: No new <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> is constructed and used here. The observable behaviour of growable SharedArrayBuffers is specified by allocating a <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>-sized <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> at construction time, and this step is intended to capture the requirement that implementations that run out of memory must throw a <emu-val>RangeError</emu-val>.</li><li>NOTE: The above checks help ensure that concurrent calls to SharedArrayBuffer.prototype.grow are totally ordered. For example, consider two racing calls: <code>sab.grow(10)</code> and <code>sab.grow(20)</code>. One of the two calls is guaranteed to win the race. The call to <code>sab.grow(10)</code> will never shrink <code>sab</code> even if <code>sab.grow(20)</code> happened first.</li><li>If <var>growFailed</var> is <emu-val>false</emu-val> and <var>newByteLength</var> ≠ <var>currentByteLength</var>, then<ol><li>NOTE: Resizes to the same length explicitly do nothing to avoid gratuitous synchronization.</li><li>Let <var>second</var> be a new <emu-xref href="#sec-arraybuffer-notation"><a href="https://tc39.es/ecma262/#sec-arraybuffer-notation">read-modify-write modification function</a></emu-xref> with parameters (<var>oldBytes</var>, <var>newBytes</var>) that captures nothing and performs the following steps atomically when called:<ol><li>Return <var>newBytes</var>.</li></ol></li><li>Let <var>newByteLengthBytes</var> be <emu-xref aoid="NumericToRawBytes"><a href="https://tc39.es/ecma262/#sec-numerictorawbytes">NumericToRawBytes</a></emu-xref>(<emu-const>BigUint64</emu-const>, <emu-xref aoid="ℤ"><a href="https://tc39.es/ecma262/#ℤ">ℤ</a></emu-xref>(<var>newByteLength</var>), <var>isLittleEndian</var>).</li><li>Let <var>event</var> be <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">ReadModifyWriteSharedMemory</a></emu-xref> { [[Order]]: <emu-const>SeqCst</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>byteLengthBlock</var>, [[ByteIndex]]: 0, [[ElementSize]]: 8, [[Payload]]: <var>newByteLengthBytes</var>, [[ModifyOp]]: <var>second</var> }.</li><li>NOTE: The new memory is already zeroed, as a <var>O</var>.[[ArrayBufferMaxByteLength]] sized <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> is already allocated. This is a specification mechanism; an implementation is not required to reserve <var>O</var>.[[ArrayBufferMaxByteLength]] bytes of physical memory.</li></ol></li><li>Else,<ol><li>Let <var>event</var> be <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">ReadSharedMemory</a></emu-xref> { [[Order]]: <emu-const>SeqCst</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>byteLengthBlock</var>, [[ByteIndex]]: 0, [[ElementSize]]: 8 }.</li></ol></li><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href="#surrounding-agent"><a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a></emu-xref>'s <emu-xref href="#agent-record"><a href="https://tc39.es/ecma262/#agent-record">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid="AgentSignifier"><a href="https://tc39.es/ecma262/#sec-agentsignifier">AgentSignifier</a></emu-xref>().</li><li>Append <var>event</var> to <var>eventList</var>.</li><li>Append <emu-xref href="#sec-chosen-value-records"><a href="https://tc39.es/ecma262/#sec-chosen-value-records">Chosen Value Record</a></emu-xref> { [[Event]]: <var>event</var>, [[ChosenValue]]: <var>rawCurrentByteLengthBytesRead</var> } to <var>execution</var>.[[ChosenValues]].</li><li>If <var>growFailed</var> is <emu-val>true</emu-val>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>
      <emu-note><span class="note">Note</span><div class="note-contents">
        <p>Spurious failures of the compare-exchange to update the length are prohibited. If the bounds checking for the new length passes and the implementation is not out of memory, a <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">ReadModifyWriteSharedMemory</a></emu-xref> event (i.e. a successful compare-exchange) is always added into the <emu-xref href="#sec-candidate-executions"><a href="https://tc39.es/ecma262/#sec-candidate-executions">candidate execution</a></emu-xref>.</p>
        <p>Many of the above steps are shared with the algorithm steps of Atomics.compareExchange and should be refactored when merged into the full specification.</p>
      </div></emu-note>
    </emu-clause>
    </ins>

    <emu-clause id="sec-sharedarraybuffer.prototype.slice">
      <h1><span class="secnum">2.3.5</span> SharedArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>len</var> be <del><var>O</var>.[[ArrayBufferByteLength]]</del><ins><emu-xref aoid="ArrayBufferByteLength" id="_ref_15"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>O</var>, <emu-const>SeqCst</emu-const>)</ins>.</li><li>Let <var>relativeStart</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>start</var>).</li><li>If <var>relativeStart</var> is -∞, let <var>first</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>first</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>first</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>end</var>).</li><li>If <var>relativeEnd</var> is -∞, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>newLen</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>final</var> - <var>first</var>, 0).</li><li>Let <var>ctor</var> be ?&nbsp;<emu-xref aoid="SpeciesConstructor"><a href="https://tc39.es/ecma262/#sec-speciesconstructor" class="e-user-code">SpeciesConstructor</a></emu-xref>(<var>O</var>, <emu-xref href="#sec-sharedarraybuffer-constructor" id="_ref_16"><a href="#sec-sharedarraybuffer-constructor">%SharedArrayBuffer%</a></emu-xref>).</li><li>Let <var>new</var> be ?&nbsp;<emu-xref aoid="Construct"><a href="https://tc39.es/ecma262/#sec-construct" class="e-user-code">Construct</a></emu-xref>(<var>ctor</var>, « <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>newLen</var>) »).</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>new</var>, [[ArrayBufferData]]).</li><li><ins>NOTE: Unlike ArrayBuffers, SharedArrayBuffers cannot shrink, so the length does not need to be reloaded.</ins></li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>new</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>new</var>.[[ArrayBufferData]] and <var>O</var>.[[ArrayBufferData]] are the same <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> values, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>new</var>.[[ArrayBufferByteLength]] &lt; <var>newLen</var>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>fromBuf</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBuf</var> be <var>new</var>.[[ArrayBufferData]].</li><li>Perform <emu-xref aoid="CopyDataBlockBytes"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBuf</var>, 0, <var>fromBuf</var>, <var>first</var>, <var>newLen</var>).</li><li>Return <var>new</var>.</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-integer-indexed-exotic-objects-mods">
  <h1><span class="secnum">3</span> Modifications to Integer-Indexed Exotic Objects</h1>

  <emu-clause id="sec-integer-indexed-exotic-objects-ownpropertykeys" type="internal method">
    <h1><span class="secnum">3.1</span> [[OwnPropertyKeys]] ( )</h1>
    <p>The [[OwnPropertyKeys]] internal method of an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref> <var>O</var> takes no arguments and returns a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">property keys</a></emu-xref>. It performs the following steps when called:</p>
    <emu-alg><ol><li>Let <var>keys</var> be a new empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>.[[ViewedArrayBuffer]]) is <emu-val>false</emu-val>, then</del><ol><li><del>For each <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> <var>i</var> starting with 0 such that <var>i</var> &lt; <var>O</var>.[[ArrayLength]], in ascending order, do</del><ol><li><del>Add !&nbsp;<emu-xref aoid="ToString"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>i</var>)) as the last element of <var>keys</var>.</del></li></ol></li></ol></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_17"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>Let <var>len</var> be <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_18"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins></li><li><ins>If <var>len</var> is not <emu-const>out-of-bounds</emu-const>, then</ins><ol><li><ins>For each <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> <var>i</var> starting with 0 such that <var>i</var> &lt; <var>len</var>, in ascending order, do</ins><ol><li><ins>Add !&nbsp;<emu-xref aoid="ToString"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>i</var>)) as the last element of <var>keys</var>.</ins></li></ol></li></ol></li><li>For each own <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">property key</a></emu-xref> <var>P</var> of <var>O</var> such that <emu-xref aoid="Type"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>P</var>) is String and <var>P</var> is not an <emu-xref href="#integer-index"><a href="https://tc39.es/ecma262/#integer-index">integer index</a></emu-xref>, in ascending chronological order of property creation, do<ol><li>Add <var>P</var> as the last element of <var>keys</var>.</li></ol></li><li>For each own <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">property key</a></emu-xref> <var>P</var> of <var>O</var> such that <emu-xref aoid="Type"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>P</var>) is Symbol, in ascending chronological order of property creation, do<ol><li>Add <var>P</var> as the last element of <var>keys</var>.</li></ol></li><li>Return <var>keys</var>.</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-isvalidintegerindex" type="abstract operation" aoid="IsValidIntegerIndex">
    <h1><span class="secnum">3.2</span> IsValidIntegerIndex ( <var>O</var>, <var>index</var> )</h1>
    <p>The abstract operation IsValidIntegerIndex takes arguments <var>O</var> (an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>) and <var>index</var> (a Number) and returns a Boolean. It performs the following steps when called:</p>
    <emu-alg><ol><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>.[[ViewedArrayBuffer]]) is <emu-val>true</emu-val>, return <emu-val>false</emu-val>.</del></li><li>If <emu-xref aoid="IsIntegralNumber"><a href="https://tc39.es/ecma262/#sec-isintegralnumber">IsIntegralNumber</a></emu-xref>(<var>index</var>) is <emu-val>false</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>index</var> is <emu-val>-0</emu-val><sub>𝔽</sub>, return <emu-val>false</emu-val>.</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_19"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>O</var>'s backing buffer is a growable SharedArrayBuffer.</ins></li><li><ins>Let <var>length</var> be <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_20"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins></li><li>If <ins><var>length</var> is <emu-const>out-of-bounds</emu-const> or</ins> <emu-xref aoid="ℝ"><a href="https://tc39.es/ecma262/#ℝ">ℝ</a></emu-xref>(<var>index</var>) &lt; 0 or <emu-xref aoid="ℝ"><a href="https://tc39.es/ecma262/#ℝ">ℝ</a></emu-xref>(<var>index</var>) ≥ <del><var>O</var>.[[ArrayLength]]</del><ins><var>length</var></ins>, return <emu-val>false</emu-val>.</li><li>Return <emu-val>true</emu-val>.</li></ol></emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-integerindexedobjectbytelength" type="abstract operation" aoid="IntegerIndexedObjectByteLength">
    <h1><span class="secnum">3.3</span> IntegerIndexedObjectByteLength ( <var>O</var>, <var>getBufferByteLength</var> )</h1>
    <p>The abstract operation IntegerIndexedObjectByteLength takes arguments <var>O</var> (an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>) and <var>getBufferByteLength</var> (an <emu-xref href="#sec-abstract-closure"><a href="https://tc39.es/ecma262/#sec-abstract-closure">Abstract Closure</a></emu-xref>) and returns a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref>. It performs the following steps when called:</p>
    <emu-alg><ol><li>Let <var>length</var> be <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_21"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</li><li>If <var>length</var> is <emu-const>out-of-bounds</emu-const> or <var>length</var> = 0, return 0.</li><li>If <var>O</var>.[[ByteLength]] is not <emu-const>auto</emu-const>, return <var>O</var>.[[ByteLength]].</li><li>Let <var>elementSize</var> be <emu-xref aoid="TypedArrayElementSize"><a href="https://tc39.es/ecma262/#sec-typedarrayelementsize">TypedArrayElementSize</a></emu-xref>(<var>O</var>).</li><li>Return <var>length</var> × <var>elementSize</var>.</li></ol></emu-alg>
    </emu-clause>

  <emu-clause id="sec-integerindexedobjectlength" type="abstract operation" aoid="IntegerIndexedObjectLength">
    <h1><span class="secnum">3.4</span> IntegerIndexedObjectLength ( <var>O</var>, <var>getBufferByteLength</var> )</h1>
    <p>The abstract operation IntegerIndexedObjectLength takes arguments <var>O</var> (an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>) and <var>getBufferByteLength</var> (an <emu-xref href="#sec-abstract-closure"><a href="https://tc39.es/ecma262/#sec-abstract-closure">Abstract Closure</a></emu-xref>) and returns a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> or <emu-const>out-of-bounds</emu-const>. It performs the following steps when called:</p>
    <emu-alg><ol><li>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_22"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, return <emu-const>out-of-bounds</emu-const>.</li><li>If <var>O</var>.[[ArrayLength]] is not <emu-const>auto</emu-const>, return <var>O</var>.[[ArrayLength]].</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>Let <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="IsResizableArrayBuffer" id="_ref_23"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>.</li><li>Let <var>byteOffset</var> be <var>O</var>.[[ByteOffset]].</li><li>Let <var>elementSize</var> be <emu-xref aoid="TypedArrayElementSize"><a href="https://tc39.es/ecma262/#sec-typedarrayelementsize">TypedArrayElementSize</a></emu-xref>(<var>O</var>).</li><li>Return <emu-xref aoid="floor"><a href="https://tc39.es/ecma262/#eqn-floor">floor</a></emu-xref>((<var>bufferByteLength</var> - <var>byteOffset</var>) / <var>elementSize</var>).</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-isintegerindexedobjectoutofbounds" type="abstract operation" aoid="IsIntegerIndexedObjectOutOfBounds">
    <h1><span class="secnum">3.5</span> IsIntegerIndexedObjectOutOfBounds ( <var>O</var>, <var>getBufferByteLength</var> )</h1>
    <p>The abstract operation IsIntegerIndexedObjectOutOfBounds takes arguments <var>O</var> (an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>) and <var>getBufferByteLength</var> (an <emu-xref href="#sec-abstract-closure"><a href="https://tc39.es/ecma262/#sec-abstract-closure">Abstract Closure</a></emu-xref>) and returns a Boolean. It checks if any of the object's numeric properties reference a value at an index not contained within the underlying data block's bounds. It performs the following steps when called:</p>
    <emu-alg><ol><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>.[[ViewedArrayBuffer]]) is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li><li>Let <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</li><li>Let <var>byteOffsetStart</var> be <var>O</var>.[[ByteOffset]].</li><li>If <var>O</var>.[[ArrayLength]] is <emu-const>auto</emu-const>, then<ol><li>Let <var>byteOffsetEnd</var> be <var>bufferByteLength</var>.</li></ol></li><li>Else,<ol><li>Let <var>elementSize</var> be <emu-xref aoid="TypedArrayElementSize"><a href="https://tc39.es/ecma262/#sec-typedarrayelementsize">TypedArrayElementSize</a></emu-xref>(<var>O</var>).</li><li>Let <var>byteOffsetEnd</var> be <var>byteOffsetStart</var> + <var>O</var>.[[ArrayLength]] × <var>elementSize</var>.</li></ol></li><li>If <var>byteOffsetStart</var> &gt; <var>bufferByteLength</var> or <var>byteOffsetEnd</var> &gt; <var>bufferByteLength</var>, return <emu-val>true</emu-val>.</li><li>NOTE: 0-length TypedArrays are not considered out-of-bounds.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-isarraybufferviewoutofbounds" type="abstract operation" aoid="IsArrayBufferViewOutOfBounds">
    <h1><span class="secnum">3.6</span> IsArrayBufferViewOutOfBounds ( <var>O</var> )</h1>
    <p>The abstract operation IsArrayBufferViewOutOfBounds takes argument <var>O</var> (an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref> or a DataView) and returns a Boolean. It checks if either any of a TypedArray's numeric properties or a DataView object's methods can reference a value at an index not contained within the underlying data block's bounds. This abstract operation exists as a convenience for upstream specifications. It performs the following steps when called:</p>
    <emu-alg><ol><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li><li>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_24"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, then<ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: If <var>O</var> has a [[DataView]] internal slot, <emu-xref aoid="IsViewOutOfBounds" id="_ref_25"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>false</emu-val>. Else, <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_26"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>false</emu-val>.</li><li>NOTE: SharedArrayBuffers can only grow, and views on it cannot go out of bounds after construction. This is special-cased in this operation to avoid shared memory loads of the buffer's byte length, which are not necessary for this check.</li><li>Return <emu-val>false</emu-val>.</li></ol></li><li>If <var>O</var> has a [[DataView]] internal slot, return <emu-xref aoid="IsViewOutOfBounds" id="_ref_27"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</li><li>Return <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_28"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</li></ol></emu-alg>
  </emu-clause>
  </ins>
</emu-clause>

<emu-clause id="sec-typedarray-objects-mods">
  <h1><span class="secnum">4</span> Modifications to TypedArray Objects</h1>

  <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object-mods">
    <h1><span class="secnum">4.1</span> Modifications to Properties of the %TypedArray.prototype% Object</h1>

    <emu-clause id="sec-validatetypedarray" type="abstract operation" aoid="ValidateTypedArray">
      <h1><span class="secnum">4.1.1</span> ValidateTypedArray ( <var>O</var> )</h1>
      <p>The abstract operation ValidateTypedArray takes argument <var>O</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>) and returns either a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> <emu-const>unused</emu-const> or a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_29"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_30"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Return <var>buffer</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.bytelength">
      <h1><span class="secnum">4.1.2</span> get %TypedArray%.prototype.byteLength</h1>
      <p><emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub></del>.</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_31"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>size</var> be <del><var>O</var>.[[ByteLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectByteLength" id="_ref_32"><a href="#sec-integerindexedobjectbytelength">IntegerIndexedObjectByteLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Return <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>size</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.byteoffset">
      <h1><span class="secnum">4.1.3</span> get %TypedArray%.prototype.byteOffset</h1>
      <p><emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.byteOffset</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_33"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_34"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</ins></li><li>Let <var>offset</var> be <var>O</var>.[[ByteOffset]].</li><li>Return <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>offset</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.length">
      <h1><span class="secnum">4.1.4</span> get %TypedArray%.prototype.length</h1>
      <p><emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.length</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_35"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>length</var> be <del><var>O</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_36"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li><ins>If <var>length</var> is <emu-const>out-of-bounds</emu-const>, set <var>length</var> to 0.</ins></li><li>Return <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
      <p>This function is not generic. The <emu-val>this</emu-val> value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-%typedarray%.prototype.copywithin">
      <h1><span class="secnum">4.1.5</span> %TypedArray%.prototype.copyWithin ( <var>target</var>, <var>start</var> [ , <var>end</var> ] )</h1>
      <p>The interpretation and use of the arguments of <emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.copyWithin</code> are the same as for <code>Array.prototype.copyWithin</code> as defined in <emu-xref href="#sec-array.prototype.copywithin"><a href="https://tc39.es/ecma262/#sec-array.prototype.copywithin">23.1.3.4</a></emu-xref>.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="ValidateTypedArray" id="_ref_37"><a href="#sec-validatetypedarray">ValidateTypedArray</a></emu-xref>(<var>O</var>).</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_38"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>len</var> be <del><var>O</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_39"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li><ins><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>len</var> is not <emu-const>out-of-bounds</emu-const>.</ins></li><li>Let <var>relativeTarget</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>target</var>).</li><li>If <var>relativeTarget</var> is -∞, let <var>to</var> be 0.</li><li>Else if <var>relativeTarget</var> &lt; 0, let <var>to</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeTarget</var>, 0).</li><li>Else, let <var>to</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeTarget</var>, <var>len</var>).</li><li>Let <var>relativeStart</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>start</var>).</li><li>If <var>relativeStart</var> is -∞, let <var>from</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>from</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>from</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>end</var>).</li><li>If <var>relativeEnd</var> is -∞, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>count</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>final</var> - <var>from</var>, <var>len</var> - <var>to</var>).</li><li>If <var>count</var> &gt; 0, then<ol><li>NOTE: The copying must be performed in a manner that preserves the bit-level encoding of the source data.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><ins>Set <var>getBufferByteLength</var> to <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_40"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>Set <var>len</var> to <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_41"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins></li><li>If <del><emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val></del><ins><var>len</var> is <emu-const>out-of-bounds</emu-const></ins>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>typedArrayName</var> be the String value of <var>O</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 67</a></emu-xref> for <var>typedArrayName</var>.</li><li><ins>Let <var>bufferByteLen</var> be <var>len</var> × <var>elementSize</var>.</ins></li><li>Let <var>byteOffset</var> be <var>O</var>.[[ByteOffset]].</li><li>Let <var>toByteIndex</var> be <var>to</var> × <var>elementSize</var> + <var>byteOffset</var>.</li><li>Let <var>fromByteIndex</var> be <var>from</var> × <var>elementSize</var> + <var>byteOffset</var>.</li><li>Let <var>countBytes</var> be <var>count</var> × <var>elementSize</var>.</li><li>If <var>fromByteIndex</var> &lt; <var>toByteIndex</var> and <var>toByteIndex</var> &lt; <var>fromByteIndex</var> + <var>countBytes</var>, then<ol><li>Let <var>direction</var> be -1.</li><li>Set <var>fromByteIndex</var> to <var>fromByteIndex</var> + <var>countBytes</var> - 1.</li><li>Set <var>toByteIndex</var> to <var>toByteIndex</var> + <var>countBytes</var> - 1.</li></ol></li><li>Else,<ol><li>Let <var>direction</var> be 1.</li></ol></li><li>Repeat, while <var>countBytes</var> &gt; 0,<ol><li><ins>If <var>fromByteIndex</var> &lt; <var>bufferByteLen</var> and <var>toByteIndex</var> &lt; <var>bufferByteLen</var>, then</ins><ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>buffer</var>, <var>fromByteIndex</var>, <emu-const>Uint8</emu-const>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>buffer</var>, <var>toByteIndex</var>, <emu-const>Uint8</emu-const>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>fromByteIndex</var> to <var>fromByteIndex</var> + <var>direction</var>.</li><li>Set <var>toByteIndex</var> to <var>toByteIndex</var> + <var>direction</var>.</li></ol></li><li>Set <var>countBytes</var> to <var>countBytes</var> - 1.</li></ol></li></ol></li><li>Return <var>O</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-%typedarray%.prototype.fill">
      <h1><span class="secnum">4.1.6</span> %TypedArray%.prototype.fill ( <var>value</var> [ , <var>start</var> [ , <var>end</var> ] ] )</h1>
      <p>The interpretation and use of the arguments of <emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.fill</code> are the same as for <code>Array.prototype.fill</code> as defined in <emu-xref href="#sec-array.prototype.fill"><a href="https://tc39.es/ecma262/#sec-array.prototype.fill">23.1.3.7</a></emu-xref>.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="ValidateTypedArray" id="_ref_42"><a href="#sec-validatetypedarray">ValidateTypedArray</a></emu-xref>(<var>O</var>).</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_43"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>len</var> be <del><var>O</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_44"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li><ins><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>len</var> is not <emu-const>out-of-bounds</emu-const>.</ins></li><li>If <var>O</var>.[[ContentType]] is <emu-const>BigInt</emu-const>, set <var>value</var> to ?&nbsp;<emu-xref aoid="ToBigInt"><a href="https://tc39.es/ecma262/#sec-tobigint" class="e-user-code">ToBigInt</a></emu-xref>(<var>value</var>).</li><li>Otherwise, set <var>value</var> to ?&nbsp;<emu-xref aoid="ToNumber"><a href="https://tc39.es/ecma262/#sec-tonumber" class="e-user-code">ToNumber</a></emu-xref>(<var>value</var>).</li><li>Let <var>relativeStart</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>start</var>).</li><li>If <var>relativeStart</var> is -∞, let <var>k</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>k</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>k</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>end</var>).</li><li>If <var>relativeEnd</var> is -∞, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>.[[ViewedArrayBuffer]]) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Set <var>getBufferByteLength</var> to <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_45"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>Set <var>len</var> to <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_46"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins></li><li><ins>If <var>len</var> is <emu-const>out-of-bounds</emu-const>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li><ins>Set <var>final</var> to <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>final</var>, <var>len</var>).</ins></li><li>Repeat, while <var>k</var> &lt; <var>final</var>,<ol><li>Let <var>Pk</var> be !&nbsp;<emu-xref aoid="ToString"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>k</var>)).</li><li>Perform !&nbsp;<emu-xref aoid="Set"><a href="https://tc39.es/ecma262/#sec-set-o-p-v-throw">Set</a></emu-xref>(<var>O</var>, <var>Pk</var>, <var>value</var>, <emu-val>true</emu-val>).</li><li>Set <var>k</var> to <var>k</var> + 1.</li></ol></li><li>Return <var>O</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-%typedarray%.prototype.slice">
      <h1><span class="secnum">4.1.7</span> %TypedArray%.prototype.slice ( <var>start</var>, <var>end</var> )</h1>
      <p>The interpretation and use of the arguments of <emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.slice</code> are the same as for <code>Array.prototype.slice</code> as defined in <emu-xref href="#sec-array.prototype.slice"><a href="https://tc39.es/ecma262/#sec-array.prototype.slice">23.1.3.28</a></emu-xref>. The following steps are taken:</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="ValidateTypedArray" id="_ref_47"><a href="#sec-validatetypedarray">ValidateTypedArray</a></emu-xref>(<var>O</var>).</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_48"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>len</var> be <del><var>O</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_49"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Let <var>relativeStart</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>start</var>).</li><li>If <var>relativeStart</var> is -∞, let <var>k</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>k</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>k</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>end</var>).</li><li>If <var>relativeEnd</var> is -∞, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>count</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>final</var> - <var>k</var>, 0).</li><li>Let <var>A</var> be ?&nbsp;<emu-xref aoid="TypedArraySpeciesCreate"><a href="https://tc39.es/ecma262/#typedarray-species-create" class="e-user-code">TypedArraySpeciesCreate</a></emu-xref>(<var>O</var>, « <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>count</var>) »).</li><li>If <var>count</var> &gt; 0, then<ol><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>.[[ViewedArrayBuffer]]) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Set <var>getBufferByteLength</var> to <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_50"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>Set <var>len</var> to <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_51"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins></li><li><ins>If <var>len</var> is <emu-const>out-of-bounds</emu-const>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li><ins>Set <var>final</var> to <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>final</var>, <var>len</var>).</ins></li><li>Let <var>srcName</var> be the String value of <var>O</var>.[[TypedArrayName]].</li><li>Let <var>srcType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 67</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>targetName</var> be the String value of <var>A</var>.[[TypedArrayName]].</li><li>Let <var>targetType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 67</a></emu-xref> for <var>targetName</var>.</li><li>If <var>srcType</var> is different from <var>targetType</var>, then<ol><li>Let <var>n</var> be 0.</li><li>Repeat, while <var>k</var> &lt; <var>final</var>,<ol><li>Let <var>Pk</var> be !&nbsp;<emu-xref aoid="ToString"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>k</var>)).</li><li>Let <var>kValue</var> be !&nbsp;<emu-xref aoid="Get"><a href="https://tc39.es/ecma262/#sec-get-o-p">Get</a></emu-xref>(<var>O</var>, <var>Pk</var>).</li><li>Perform !&nbsp;<emu-xref aoid="Set"><a href="https://tc39.es/ecma262/#sec-set-o-p-v-throw">Set</a></emu-xref>(<var>A</var>, !&nbsp;<emu-xref aoid="ToString"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>n</var>)), <var>kValue</var>, <emu-val>true</emu-val>).</li><li>Set <var>k</var> to <var>k</var> + 1.</li><li>Set <var>n</var> to <var>n</var> + 1.</li></ol></li></ol></li><li>Else,<ol><li>Let <var>srcBuffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>Let <var>targetBuffer</var> be <var>A</var>.[[ViewedArrayBuffer]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 67</a></emu-xref> for Element Type <var>srcType</var>.</li><li>NOTE: If <var>srcType</var> and <var>targetType</var> are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.</li><li>Let <var>srcByteOffset</var> be <var>O</var>.[[ByteOffset]].</li><li>Let <var>targetByteIndex</var> be <var>A</var>.[[ByteOffset]].</li><li>Let <var>srcByteIndex</var> be (<var>k</var> × <var>elementSize</var>) + <var>srcByteOffset</var>.</li><li>Let <var>limit</var> be <ins><emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(</ins><var>targetByteIndex</var> + <var>count</var> × <var>elementSize</var><ins>, <var>len</var> × <var>elementSize</var>)</ins>.</li><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var>,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <emu-const>Uint8</emu-const>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <emu-const>Uint8</emu-const>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + 1.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + 1.</li></ol></li></ol></li></ol></li><li>Return <var>A</var>.</li></ol></emu-alg>
      <p>This function is not generic. The <emu-val>this</emu-val> value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-%typedarray%.prototype.subarray">
      <h1><span class="secnum">4.1.8</span> %TypedArray%.prototype.subarray ( <var>begin</var>, <var>end</var> )</h1>
      <p>Returns a new <var>TypedArray</var> whose element type is the same as this <var>TypedArray</var> and whose ArrayBuffer is the same as the ArrayBuffer of this <var>TypedArray</var>, referencing the elements at <var>begin</var>, inclusive, up to <var>end</var>, exclusive. If either <var>begin</var> or <var>end</var> is negative, it refers to an index from the end of the array, as opposed to from the beginning.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><ins>Let <var>getSrcBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_52"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>srcLength</var> be <del><var>O</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_53"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getSrcBufferByteLength</var>)</ins>.</li><li><ins>If <var>srcLength</var> is <emu-const>out-of-bounds</emu-const>, set <var>srcLength</var> to 0.</ins></li><li>Let <var>relativeBegin</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>begin</var>).</li><li>If <var>relativeBegin</var> is -∞, let <var>beginIndex</var> be 0.</li><li>Else if <var>relativeBegin</var> &lt; 0, let <var>beginIndex</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>srcLength</var> + <var>relativeBegin</var>, 0).</li><li>Else, let <var>beginIndex</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeBegin</var>, <var>srcLength</var>).</li><li><ins>If <var>O</var>.[[ArrayLength]] is <emu-const>auto</emu-const> and <var>end</var> is <emu-val>undefined</emu-val>, then</ins><ol><li><ins>Let <var>newLength</var> be <emu-val>undefined</emu-val>.</ins></li></ol></li><li><ins>Else,</ins><ol><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>srcLength</var>; else let <var>relativeEnd</var> be ?&nbsp;<emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>end</var>).</li><li>If <var>relativeEnd</var> is -∞, let <var>endIndex</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>endIndex</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>srcLength</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>endIndex</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>srcLength</var>).</li><li>Let <var>newLength</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>endIndex</var> - <var>beginIndex</var>, 0).</li></ol></li><li>Let <var>constructorName</var> be the String value of <var>O</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 67</a></emu-xref> for <var>constructorName</var>.</li><li>Let <var>srcByteOffset</var> be <var>O</var>.[[ByteOffset]].</li><li>Let <var>beginByteOffset</var> be <var>srcByteOffset</var> + <var>beginIndex</var> × <var>elementSize</var>.</li><li><ins>If <var>newLength</var> is <emu-val>undefined</emu-val>, then</ins><ol><li><ins>Let <var>argumentsList</var> be « <var>buffer</var>, <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>beginByteOffset</var>) ».</ins></li></ol></li><li><ins>Else,</ins><ol><li>Let <var>argumentsList</var> be « <var>buffer</var>, <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>beginByteOffset</var>), <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>newLength</var>) ».</li></ol></li><li>Return ?&nbsp;<emu-xref aoid="TypedArraySpeciesCreate"><a href="https://tc39.es/ecma262/#typedarray-species-create" class="e-user-code">TypedArraySpeciesCreate</a></emu-xref>(<var>O</var>, <var>argumentsList</var>).</li></ol></emu-alg>
      <p>This function is not generic. The <emu-val>this</emu-val> value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-settypedarrayfromtypedarray" type="abstract operation" oldids="sec-%typedarray%.prototype.set-typedarray-offset" aoid="SetTypedArrayFromTypedArray"><span id="sec-%typedarray%.prototype.set-typedarray-offset"></span>
      <h1><span class="secnum">4.1.9</span> SetTypedArrayFromTypedArray ( <var>target</var>, <var>targetOffset</var>, <var>source</var> )</h1>
      <p>The abstract operation SetTypedArrayFromTypedArray takes arguments <var>target</var> (a TypedArray), <var>targetOffset</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> or +∞), and <var>source</var> (a TypedArray) and returns either a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> <emu-const>unused</emu-const> or a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>. It sets multiple values in <var>target</var>, starting at index <var>targetOffset</var>, reading the values from <var>source</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>source</var> <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">is an Object</a></emu-xref> that has a [[TypedArrayName]] internal slot.</li><li>Let <var>targetBuffer</var> be <var>target</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>targetBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getTargetBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_54"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>targetLength</var> be <del><var>target</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_55"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>target</var>, <var>getTargetBufferByteLength</var>)</ins>.</li><li><ins>If <var>targetLength</var> is <emu-const>out-of-bounds</emu-const>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>srcBuffer</var> be <var>source</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>srcBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li>Let <var>targetType</var> be <emu-xref aoid="TypedArrayElementType"><a href="https://tc39.es/ecma262/#sec-typedarrayelementtype">TypedArrayElementType</a></emu-xref>(<var>target</var>).</li><li>Let <var>targetElementSize</var> be <emu-xref aoid="TypedArrayElementSize"><a href="https://tc39.es/ecma262/#sec-typedarrayelementsize">TypedArrayElementSize</a></emu-xref>(<var>target</var>).</li><li>Let <var>targetByteOffset</var> be <var>target</var>.[[ByteOffset]].</li><li>Let <var>srcType</var> be <emu-xref aoid="TypedArrayElementType"><a href="https://tc39.es/ecma262/#sec-typedarrayelementtype">TypedArrayElementType</a></emu-xref>(<var>source</var>).</li><li>Let <var>srcElementSize</var> be <emu-xref aoid="TypedArrayElementSize"><a href="https://tc39.es/ecma262/#sec-typedarrayelementsize">TypedArrayElementSize</a></emu-xref>(<var>source</var>).</li><li><ins>Let <var>getSrcBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_56"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>srcLength</var> be <del><var>source</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_57"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>source</var>, <var>getSrcBufferByteLength</var>)</ins>.</li><li><ins>If <var>srcLength</var> is <emu-const>out-of-bounds</emu-const>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>srcByteOffset</var> be <var>source</var>.[[ByteOffset]].</li><li>If <var>targetOffset</var> is +∞, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>srcLength</var> + <var>targetOffset</var> &gt; <var>targetLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>target</var>.[[ContentType]] ≠ <var>source</var>.[[ContentType]], throw a <emu-val>TypeError</emu-val> exception.</li><li>If both <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>srcBuffer</var>) and <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>targetBuffer</var>) are <emu-val>true</emu-val>, then<ol><li>If <var>srcBuffer</var>.[[ArrayBufferData]] and <var>targetBuffer</var>.[[ArrayBufferData]] are the same <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> values, let <var>same</var> be <emu-val>true</emu-val>; else let <var>same</var> be <emu-val>false</emu-val>.</li></ol></li><li>Else, let <var>same</var> be <emu-xref aoid="SameValue"><a href="https://tc39.es/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcBuffer</var>, <var>targetBuffer</var>).</li><li>If <var>same</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>srcByteLength</var> be <del><var>source</var>.[[ByteLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectByteLength" id="_ref_58"><a href="#sec-integerindexedobjectbytelength">IntegerIndexedObjectByteLength</a></emu-xref>(<var>source</var>, <var>getSrcBufferByteLength</var>)</ins>.</li><li>Set <var>srcBuffer</var> to ?&nbsp;<emu-xref aoid="CloneArrayBuffer"><a href="https://tc39.es/ecma262/#sec-clonearraybuffer">CloneArrayBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteOffset</var>, <var>srcByteLength</var>).</li><li>Let <var>srcByteIndex</var> be 0.</li></ol></li><li>Else, let <var>srcByteIndex</var> be <var>srcByteOffset</var>.</li><li>Let <var>targetByteIndex</var> be <var>targetOffset</var> × <var>targetElementSize</var> + <var>targetByteOffset</var>.</li><li>Let <var>limit</var> be <var>targetByteIndex</var> + <var>targetElementSize</var> × <var>srcLength</var>.</li><li>If <var>srcType</var> is the same as <var>targetType</var>, then<ol><li>NOTE: If <var>srcType</var> and <var>targetType</var> are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.</li><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var>,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <emu-const>Uint8</emu-const>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <emu-const>Uint8</emu-const>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + 1.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + 1.</li></ol></li></ol></li><li>Else,<ol><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var>,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <var>srcType</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <var>targetType</var>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + <var>srcElementSize</var>.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + <var>targetElementSize</var>.</li></ol></li></ol></li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-constructors-mods">
    <h1><span class="secnum">4.2</span> Modifications to the <var>TypedArray</var> Constructors</h1>

    <emu-clause id="sec-initializetypedarrayfromtypedarray" type="abstract operation" oldids="sec-typedarray-typedarray" aoid="InitializeTypedArrayFromTypedArray"><span id="sec-typedarray-typedarray"></span>
      <h1><span class="secnum">4.2.1</span> InitializeTypedArrayFromTypedArray ( <var>O</var>, <var>srcArray</var> )</h1>
      <p>The abstract operation InitializeTypedArrayFromTypedArray takes arguments <var>O</var> (a TypedArray) and <var>srcArray</var> (a TypedArray) and returns either a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> <emu-const>unused</emu-const> or a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>. It performs the following steps when called:</p>
      <emu-alg><ol><li>Let <var>srcData</var> be <var>srcArray</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>srcData</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li>Let <var>elementType</var> be <emu-xref aoid="TypedArrayElementType"><a href="https://tc39.es/ecma262/#sec-typedarrayelementtype">TypedArrayElementType</a></emu-xref>(<var>O</var>).</li><li>Let <var>elementSize</var> be <emu-xref aoid="TypedArrayElementSize"><a href="https://tc39.es/ecma262/#sec-typedarrayelementsize">TypedArrayElementSize</a></emu-xref>(<var>O</var>).</li><li><ins>Let <var>getSrcBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_59"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>elementLength</var> be <del><var>srcArray</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_60"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>srcArray</var>, <var>getSrcBufferByteLength</var>)</ins>.</li><li><ins>If <var>elementLength</var> is <emu-const>out-of-bounds</emu-const>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>srcType</var> be <emu-xref aoid="TypedArrayElementType"><a href="https://tc39.es/ecma262/#sec-typedarrayelementtype">TypedArrayElementType</a></emu-xref>(<var>srcArray</var>).</li><li>Let <var>srcElementSize</var> be <emu-xref aoid="TypedArrayElementSize"><a href="https://tc39.es/ecma262/#sec-typedarrayelementsize">TypedArrayElementSize</a></emu-xref>(<var>srcArray</var>).</li><li>Let <var>srcByteOffset</var> be <var>srcArray</var>.[[ByteOffset]].</li><li>Let <var>byteLength</var> be <var>elementSize</var> × <var>elementLength</var>.</li><li>If <var>elementType</var> is the same as <var>srcType</var>, then<ol><li>Let <var>data</var> be ?&nbsp;<emu-xref aoid="CloneArrayBuffer"><a href="https://tc39.es/ecma262/#sec-clonearraybuffer">CloneArrayBuffer</a></emu-xref>(<var>srcData</var>, <var>srcByteOffset</var>, <var>byteLength</var>).</li></ol></li><li>Else,<ol><li>Let <var>data</var> be ?&nbsp;<emu-xref aoid="AllocateArrayBuffer" id="_ref_61"><a href="#sec-allocatearraybuffer">AllocateArrayBuffer</a></emu-xref>(<emu-xref href="#sec-arraybuffer-constructor" id="_ref_62"><a href="#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>, <var>byteLength</var>).</li><li>If <var>srcArray</var>.[[ContentType]] ≠ <var>O</var>.[[ContentType]], throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>srcByteIndex</var> be <var>srcByteOffset</var>.</li><li>Let <var>targetByteIndex</var> be 0.</li><li>Let <var>count</var> be <var>elementLength</var>.</li><li>Repeat, while <var>count</var> &gt; 0,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcData</var>, <var>srcByteIndex</var>, <var>srcType</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>data</var>, <var>targetByteIndex</var>, <var>elementType</var>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + <var>srcElementSize</var>.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + <var>elementSize</var>.</li><li>Set <var>count</var> to <var>count</var> - 1.</li></ol></li></ol></li><li>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>data</var>.</li><li>Set <var>O</var>.[[ByteLength]] to <var>byteLength</var>.</li><li>Set <var>O</var>.[[ByteOffset]] to 0.</li><li>Set <var>O</var>.[[ArrayLength]] to <var>elementLength</var>.</li><li>Return <emu-const>unused</emu-const>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-initializetypedarrayfromarraybuffer" type="abstract operation" oldids="sec-typedarray-buffer-byteoffset-length" aoid="InitializeTypedArrayFromArrayBuffer"><span id="sec-typedarray-buffer-byteoffset-length"></span>
      <h1><span class="secnum">4.2.2</span> InitializeTypedArrayFromArrayBuffer ( <var>O</var>, <var>buffer</var>, <var>byteOffset</var>, <var>length</var> )</h1>
      <p>The abstract operation InitializeTypedArrayFromArrayBuffer takes arguments <var>O</var> (a TypedArray), <var>buffer</var> (an ArrayBuffer or a SharedArrayBuffer), <var>byteOffset</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>), and <var>length</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>) and returns either a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> <emu-const>unused</emu-const> or a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>. It performs the following steps when called:</p>
      <emu-alg><ol><li>Let <var>elementSize</var> be <emu-xref aoid="TypedArrayElementSize"><a href="https://tc39.es/ecma262/#sec-typedarrayelementsize">TypedArrayElementSize</a></emu-xref>(<var>O</var>).</li><li>Let <var>offset</var> be ?&nbsp;<emu-xref aoid="ToIndex"><a href="https://tc39.es/ecma262/#sec-toindex" class="e-user-code">ToIndex</a></emu-xref>(<var>byteOffset</var>).</li><li>If <var>offset</var> <emu-xref aoid="modulo"><a href="https://tc39.es/ecma262/#eqn-modulo">modulo</a></emu-xref> <var>elementSize</var> ≠ 0, throw a <emu-val>RangeError</emu-val> exception.</li><li><ins>Let <var>bufferIsResizable</var> be <emu-xref aoid="IsResizableArrayBuffer" id="_ref_63"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>buffer</var>).</ins></li><li>If <var>length</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>newLength</var> be ?&nbsp;<emu-xref aoid="ToIndex"><a href="https://tc39.es/ecma262/#sec-toindex" class="e-user-code">ToIndex</a></emu-xref>(<var>length</var>).</li></ol></li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>bufferByteLength</var> be <del><var>buffer</var>.[[ArrayBufferByteLength]]</del><ins><emu-xref aoid="ArrayBufferByteLength" id="_ref_64"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>buffer</var>, <emu-const>SeqCst</emu-const>)</ins>.</li><li><ins>If <var>length</var> is <emu-val>undefined</emu-val> and <var>bufferIsResizable</var> is <emu-val>true</emu-val>, then</ins><ol><li><ins>If <var>offset</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li><ins>Set <var>O</var>.[[ByteLength]] to <emu-const>auto</emu-const>.</ins></li><li><ins>Set <var>O</var>.[[ArrayLength]] to <emu-const>auto</emu-const>.</ins></li></ol></li><li><ins>Else,</ins><ol><li>If <var>length</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>bufferByteLength</var> <emu-xref aoid="modulo"><a href="https://tc39.es/ecma262/#eqn-modulo">modulo</a></emu-xref> <var>elementSize</var> ≠ 0, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>newByteLength</var> be <var>bufferByteLength</var> - <var>offset</var>.</li><li>If <var>newByteLength</var> &lt; 0, throw a <emu-val>RangeError</emu-val> exception.</li></ol></li><li>Else,<ol><li>Let <var>newByteLength</var> be <var>newLength</var> × <var>elementSize</var>.</li><li>If <var>offset</var> + <var>newByteLength</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li></ol></li><li><del>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>buffer</var>.</del></li><li>Set <var>O</var>.[[ByteLength]] to <var>newByteLength</var>.</li><li><del>Set <var>O</var>.[[ByteOffset]] to <var>offset</var>.</del></li><li>Set <var>O</var>.[[ArrayLength]] to <var>newByteLength</var> / <var>elementSize</var>.</li></ol></li><li><ins>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>buffer</var>.</ins></li><li><ins>Set <var>O</var>.[[ByteOffset]] to <var>offset</var>.</ins></li><li>Return <emu-const>unused</emu-const>.</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-dataview-objects-mods">
  <h1><span class="secnum">5</span> Modifications to DataView Objects</h1>

  <emu-clause id="sec-abstract-operations-for-dataview-objects-mods">
    <h1><span class="secnum">5.1</span> Modifications to Abstract Operations For DataView Objects</h1>

    <ins class="block">
    <emu-clause id="sec-getviewbytelength" type="abstract operation" aoid="GetViewByteLength">
      <h1><span class="secnum">5.1.1</span> GetViewByteLength ( <var>view</var>, <var>getBufferByteLength</var> )</h1>
      <p>The abstract operation GetViewByteLength takes arguments <var>view</var> (a DataView) and <var>getBufferByteLength</var> (an <emu-xref href="#sec-abstract-closure"><a href="https://tc39.es/ecma262/#sec-abstract-closure">Abstract Closure</a></emu-xref>). It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="Type"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>view</var>) is Object and <var>view</var> has a [[DataView]] internal slot.</li><li>If <var>view</var>.[[ByteLength]] is not <emu-const>auto</emu-const>, return <var>view</var>.[[ByteLength]].</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li>Let <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</li><li>Return <var>bufferByteLength</var> - <var>view</var>.[[ByteOffset]].</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-isviewoutofbounds" type="abstract operation" aoid="IsViewOutOfBounds">
      <h1><span class="secnum">5.1.2</span> IsViewOutOfBounds ( <var>view</var>, <var>getBufferByteLength</var> )</h1>
      <p>The abstract operation IsViewOutOfBounds takes arguments <var>view</var> (a DataView) and <var>getBufferByteLength</var> (an <emu-xref href="#sec-abstract-closure"><a href="https://tc39.es/ecma262/#sec-abstract-closure">Abstract Closure</a></emu-xref>) and returns a Boolean. It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="Type"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>view</var>) is Object and <var>view</var> has a [[DataView]] internal slot.</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li><li>Let <var>byteLength</var> be <emu-xref aoid="GetViewByteLength" id="_ref_65"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>).</li><li>If <var>byteLength</var> &lt; 0, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-getviewvalue" type="abstract operation" aoid="GetViewValue">
      <h1><span class="secnum">5.1.3</span> GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> )</h1>
      <p>The abstract operation GetViewValue takes arguments <var>view</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>), <var>requestIndex</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>), <var>isLittleEndian</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>), and <var>type</var> (a <emu-xref href="#sec-typedarray-objects"><a href="https://tc39.es/ecma262/#sec-typedarray-objects">TypedArray element type</a></emu-xref>) and returns either a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> either a Number or a BigInt, or a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>. It is used by functions on DataView instances to retrieve values from the view's buffer. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>view</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>view</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>getIndex</var> be ?&nbsp;<emu-xref aoid="ToIndex"><a href="https://tc39.es/ecma262/#sec-toindex" class="e-user-code">ToIndex</a></emu-xref>(<var>requestIndex</var>).</li><li>Set <var>isLittleEndian</var> to <emu-xref aoid="ToBoolean"><a href="https://tc39.es/ecma262/#sec-toboolean">ToBoolean</a></emu-xref>(<var>isLittleEndian</var>).</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_66"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>view</var>'s backing buffer is a growable SharedArrayBuffer.</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_67"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>viewOffset</var> be <var>view</var>.[[ByteOffset]].</li><li>Let <var>viewSize</var> be <del><var>view</var>.[[ByteLength]]</del><ins><emu-xref aoid="GetViewByteLength" id="_ref_68"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 67</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>getIndex</var> + <var>elementSize</var> &gt; <var>viewSize</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>bufferIndex</var> be <var>getIndex</var> + <var>viewOffset</var>.</li><li>Return <emu-xref aoid="GetValueFromBuffer"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>buffer</var>, <var>bufferIndex</var>, <var>type</var>, <emu-val>false</emu-val>, <emu-const>Unordered</emu-const>, <var>isLittleEndian</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-setviewvalue" type="abstract operation" aoid="SetViewValue">
      <h1><span class="secnum">5.1.4</span> SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> )</h1>
      <p>The abstract operation SetViewValue takes arguments <var>view</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>), <var>requestIndex</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>), <var>isLittleEndian</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>), <var>type</var> (a <emu-xref href="#sec-typedarray-objects"><a href="https://tc39.es/ecma262/#sec-typedarray-objects">TypedArray element type</a></emu-xref>), and <var>value</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>) and returns either a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> <emu-val>undefined</emu-val> or a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>. It is used by functions on DataView instances to store values into the view's buffer. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>view</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>view</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>getIndex</var> be ?&nbsp;<emu-xref aoid="ToIndex"><a href="https://tc39.es/ecma262/#sec-toindex" class="e-user-code">ToIndex</a></emu-xref>(<var>requestIndex</var>).</li><li>If <emu-xref aoid="IsBigIntElementType"><a href="https://tc39.es/ecma262/#sec-isbigintelementtype">IsBigIntElementType</a></emu-xref>(<var>type</var>) is <emu-val>true</emu-val>, let <var>numberValue</var> be ?&nbsp;<emu-xref aoid="ToBigInt"><a href="https://tc39.es/ecma262/#sec-tobigint" class="e-user-code">ToBigInt</a></emu-xref>(<var>value</var>).</li><li>Otherwise, let <var>numberValue</var> be ?&nbsp;<emu-xref aoid="ToNumber"><a href="https://tc39.es/ecma262/#sec-tonumber" class="e-user-code">ToNumber</a></emu-xref>(<var>value</var>).</li><li>Set <var>isLittleEndian</var> to <emu-xref aoid="ToBoolean"><a href="https://tc39.es/ecma262/#sec-toboolean">ToBoolean</a></emu-xref>(<var>isLittleEndian</var>).</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_69"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>view</var>'s backing buffer is a growable SharedArrayBuffer.</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_70"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>viewOffset</var> be <var>view</var>.[[ByteOffset]].</li><li>Let <var>viewSize</var> be <del><var>view</var>.[[ByteLength]]</del><ins><emu-xref aoid="GetViewByteLength" id="_ref_71"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 67</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>getIndex</var> + <var>elementSize</var> &gt; <var>viewSize</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>bufferIndex</var> be <var>getIndex</var> + <var>viewOffset</var>.</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>buffer</var>, <var>bufferIndex</var>, <var>type</var>, <var>numberValue</var>, <emu-val>false</emu-val>, <emu-const>Unordered</emu-const>, <var>isLittleEndian</var>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-constructor-mods">
    <h1><span class="secnum">5.2</span> Modifications to the DataView Constructor</h1>

    <emu-clause id="sec-dataview-buffer-byteoffset-bytelength">
      <h1><span class="secnum">5.2.1</span> DataView ( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>byteLength</var> ] ] )</h1>
      <p>When the <code>DataView</code> function is called with at least one argument <var>buffer</var>, the following steps are taken:</p>
      <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>buffer</var>, [[ArrayBufferData]]).</li><li>Let <var>offset</var> be ?&nbsp;<emu-xref aoid="ToIndex"><a href="https://tc39.es/ecma262/#sec-toindex" class="e-user-code">ToIndex</a></emu-xref>(<var>byteOffset</var>).</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>bufferByteLength</var> be <del><var>buffer</var>.[[ArrayBufferByteLength]]</del><ins><emu-xref aoid="ArrayBufferByteLength" id="_ref_72"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>buffer</var>, <emu-const>SeqCst</emu-const>)</ins>.</li><li>If <var>offset</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li><ins>Let <var>bufferIsResizable</var> be <emu-xref aoid="IsResizableArrayBuffer" id="_ref_73"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>buffer</var>).</ins></li><li><ins>Let <var>byteLengthChecked</var> be <emu-const>empty</emu-const>.</ins></li><li><ins>If <var>bufferIsResizable</var> is <emu-val>true</emu-val> and <var>byteLength</var> is <emu-val>undefined</emu-val>, then</ins><ol><li><ins>Let <var>viewByteLength</var> be <emu-const>auto</emu-const>.</ins></li></ol></li><li><del>If</del><ins>Else if</ins> <var>byteLength</var> is <emu-val>undefined</emu-val>, then<ol><li>Let <var>viewByteLength</var> be <var>bufferByteLength</var> - <var>offset</var>.</li></ol></li><li>Else,<ol><li><ins>Set <var>byteLengthChecked</var> to ?&nbsp;<emu-xref aoid="ToIndex"><a href="https://tc39.es/ecma262/#sec-toindex" class="e-user-code">ToIndex</a></emu-xref>(<var>byteLength</var>)</ins>.</li><li>Let <var>viewByteLength</var> be <del>?&nbsp;<emu-xref aoid="ToIndex"><a href="https://tc39.es/ecma262/#sec-toindex" class="e-user-code">ToIndex</a></emu-xref>(<var>byteLength</var>)</del><ins><var>byteLengthChecked</var></ins>.</li><li>If <var>offset</var> + <var>viewByteLength</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li></ol></li><li>Let <var>O</var> be ?&nbsp;<emu-xref aoid="OrdinaryCreateFromConstructor"><a href="https://tc39.es/ecma262/#sec-ordinarycreatefromconstructor" class="e-user-code">OrdinaryCreateFromConstructor</a></emu-xref>(NewTarget, <emu-val>"%DataView.prototype%"</emu-val>, « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_74"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>Set <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</ins></li><li><ins>If <var>offset</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li><ins>If <var>byteLengthChecked</var> is not <emu-const>empty</emu-const>, then</ins><ol><li><ins>If <var>offset</var> + <var>viewByteLength</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li></ol></li><li>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>buffer</var>.</li><li>Set <var>O</var>.[[ByteLength]] to <var>viewByteLength</var>.</li><li>Set <var>O</var>.[[ByteOffset]] to <var>offset</var>.</li><li>Return <var>O</var>.</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-dataview-prototype-object-mods">
    <h1><span class="secnum">5.3</span> Modifications to Properties of the DataView Prototype Object</h1>

    <emu-clause id="sec-get-dataview.prototype.bytelength">
      <h1><span class="secnum">5.3.1</span> get DataView.prototype.byteLength</h1>
      <p><code>DataView.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_75"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_76"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>size</var> be <del><var>O</var>.[[ByteLength]]</del><ins><emu-xref aoid="GetViewByteLength" id="_ref_77"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Return <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>size</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-dataview.prototype.byteoffset">
      <h1><span class="secnum">5.3.2</span> get DataView.prototype.byteOffset</h1>
      <p><code>DataView.prototype.byteOffset</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_78"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_79"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>offset</var> be <var>O</var>.[[ByteOffset]].</li><li>Return <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>offset</var>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-atomics-mods">
  <h1><span class="secnum">6</span> Modifications to Atomics</h1>

  <emu-clause id="sec-properties-of-the-atomics-object-mods">
    <h1><span class="secnum">6.1</span> Modifications to Properties of the Atomics Object</h1>

    <emu-clause id="sec-atomics.compareexchange">
      <h1><span class="secnum">6.1.1</span> Atomics.compareExchange ( <var>typedArray</var>, <var>index</var>, <var>expectedValue</var>, <var>replacementValue</var> )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ?&nbsp;<emu-xref aoid="ValidateIntegerTypedArray"><a href="https://tc39.es/ecma262/#sec-validateintegertypedarray">ValidateIntegerTypedArray</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>indexedPosition</var> be ?&nbsp;<emu-xref aoid="ValidateAtomicAccess" id="_ref_80"><a href="#sec-validateatomicaccess" class="e-user-code">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>If <var>typedArray</var>.[[ContentType]] is <emu-const>BigInt</emu-const>, then<ol><li>Let <var>expected</var> be ?&nbsp;<emu-xref aoid="ToBigInt"><a href="https://tc39.es/ecma262/#sec-tobigint" class="e-user-code">ToBigInt</a></emu-xref>(<var>expectedValue</var>).</li><li>Let <var>replacement</var> be ?&nbsp;<emu-xref aoid="ToBigInt"><a href="https://tc39.es/ecma262/#sec-tobigint" class="e-user-code">ToBigInt</a></emu-xref>(<var>replacementValue</var>).</li></ol></li><li>Else,<ol><li>Let <var>expected</var> be <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(? <emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>expectedValue</var>)).</li><li>Let <var>replacement</var> be <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(? <emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>replacementValue</var>)).</li></ol></li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_81"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>typedArray</var>'s backing buffer is a growable SharedArrayBuffer.</ins></li><li><ins>Let <var>length</var> be <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_82"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>typedArray</var>, <var>getBufferByteLength</var>).</ins></li><li><ins>If <emu-const>length</emu-const> is <emu-const>out-of-bounds</emu-const>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li><ins>If <var>indexedPosition</var> ≥ <var>length</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li>NOTE: The above check<ins>s</ins> <del>is</del><ins>are</ins> not redundant with the check<ins>s</ins> in <emu-xref aoid="ValidateIntegerTypedArray"><a href="https://tc39.es/ecma262/#sec-validateintegertypedarray">ValidateIntegerTypedArray</a></emu-xref> <ins>and <emu-xref aoid="ValidateAtomicAccess" id="_ref_83"><a href="#sec-validateatomicaccess">ValidateAtomicAccess</a></emu-xref></ins> because the call to <emu-xref aoid="ToBigInt"><a href="https://tc39.es/ecma262/#sec-tobigint">ToBigInt</a></emu-xref> or <emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity">ToIntegerOrInfinity</a></emu-xref> on the preceding lines can have arbitrary side effects, which could cause the buffer to become detached. <ins>These checks are only needed when <var>typedArray</var>'s backing buffer is an ArrayBuffer.</ins></li><li>Let <var>elementType</var> be <emu-xref aoid="TypedArrayElementType"><a href="https://tc39.es/ecma262/#sec-typedarrayelementtype">TypedArrayElementType</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>elementSize</var> be <emu-xref aoid="TypedArrayElementSize"><a href="https://tc39.es/ecma262/#sec-typedarrayelementsize">TypedArrayElementSize</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>isLittleEndian</var> be the value of the [[LittleEndian]] field of the <emu-xref href="#surrounding-agent"><a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a></emu-xref>'s <emu-xref href="#agent-record"><a href="https://tc39.es/ecma262/#agent-record">Agent Record</a></emu-xref>.</li><li>Let <var>expectedBytes</var> be <emu-xref aoid="NumericToRawBytes"><a href="https://tc39.es/ecma262/#sec-numerictorawbytes">NumericToRawBytes</a></emu-xref>(<var>elementType</var>, <var>expected</var>, <var>isLittleEndian</var>).</li><li>Let <var>replacementBytes</var> be <emu-xref aoid="NumericToRawBytes"><a href="https://tc39.es/ecma262/#sec-numerictorawbytes">NumericToRawBytes</a></emu-xref>(<var>elementType</var>, <var>replacement</var>, <var>isLittleEndian</var>).</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href="#surrounding-agent"><a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a></emu-xref>'s <emu-xref href="#agent-record"><a href="https://tc39.es/ecma262/#agent-record">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid="AgentSignifier"><a href="https://tc39.es/ecma262/#sec-agentsignifier">AgentSignifier</a></emu-xref>().</li><li>Let <var>rawBytesRead</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <var>elementSize</var> whose elements are nondeterministically chosen <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">byte values</a></emu-xref>.</li><li>NOTE: In implementations, <var>rawBytesRead</var> is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the <emu-xref href="#sec-memory-model"><a href="https://tc39.es/ecma262/#sec-memory-model">memory model</a></emu-xref> to describe observable behaviour of hardware with weak consistency.</li><li>NOTE: The comparison of the expected value and the read value is performed outside of the <emu-xref href="#sec-arraybuffer-notation"><a href="https://tc39.es/ecma262/#sec-arraybuffer-notation">read-modify-write modification function</a></emu-xref> to avoid needlessly strong synchronization when the expected value is not equal to the read value.</li><li>If <emu-xref aoid="ByteListEqual"><a href="https://tc39.es/ecma262/#sec-bytelistequal">ByteListEqual</a></emu-xref>(<var>rawBytesRead</var>, <var>expectedBytes</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>second</var> be a new <emu-xref href="#sec-arraybuffer-notation"><a href="https://tc39.es/ecma262/#sec-arraybuffer-notation">read-modify-write modification function</a></emu-xref> with parameters (<var>oldBytes</var>, <var>newBytes</var>) that captures nothing and performs the following steps atomically when called:<ol><li>Return <var>newBytes</var>.</li></ol></li><li>Let <var>event</var> be <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">ReadModifyWriteSharedMemory</a></emu-xref> { [[Order]]: <emu-const>SeqCst</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>block</var>, [[ByteIndex]]: <var>indexedPosition</var>, [[ElementSize]]: <var>elementSize</var>, [[Payload]]: <var>replacementBytes</var>, [[ModifyOp]]: <var>second</var> }.</li></ol></li><li>Else,<ol><li>Let <var>event</var> be <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">ReadSharedMemory</a></emu-xref> { [[Order]]: <emu-const>SeqCst</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>block</var>, [[ByteIndex]]: <var>indexedPosition</var>, [[ElementSize]]: <var>elementSize</var> }.</li></ol></li><li>Append <var>event</var> to <var>eventList</var>.</li><li>Append <emu-xref href="#sec-chosen-value-records"><a href="https://tc39.es/ecma262/#sec-chosen-value-records">Chosen Value Record</a></emu-xref> { [[Event]]: <var>event</var>, [[ChosenValue]]: <var>rawBytesRead</var> } to <var>execution</var>.[[ChosenValues]].</li></ol></li><li>Else,<ol><li>Let <var>rawBytesRead</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <var>elementSize</var> whose elements are the sequence of <var>elementSize</var> bytes starting with <var>block</var>[<var>indexedPosition</var>].</li><li>If <emu-xref aoid="ByteListEqual"><a href="https://tc39.es/ecma262/#sec-bytelistequal">ByteListEqual</a></emu-xref>(<var>rawBytesRead</var>, <var>expectedBytes</var>) is <emu-val>true</emu-val>, then<ol><li>Store the individual bytes of <var>replacementBytes</var> into <var>block</var>, starting at <var>block</var>[<var>indexedPosition</var>].</li></ol></li></ol></li><li>Return <emu-xref aoid="RawBytesToNumeric"><a href="https://tc39.es/ecma262/#sec-rawbytestonumeric">RawBytesToNumeric</a></emu-xref>(<var>elementType</var>, <var>rawBytesRead</var>, <var>isLittleEndian</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.store">
      <h1><span class="secnum">6.1.2</span> Atomics.store ( <var>typedArray</var>, <var>index</var>, <var>value</var> )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ?&nbsp;<emu-xref aoid="ValidateIntegerTypedArray"><a href="https://tc39.es/ecma262/#sec-validateintegertypedarray">ValidateIntegerTypedArray</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>indexedPosition</var> be ?&nbsp;<emu-xref aoid="ValidateAtomicAccess" id="_ref_84"><a href="#sec-validateatomicaccess" class="e-user-code">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>If <var>typedArray</var>.[[ContentType]] is <emu-const>BigInt</emu-const>, let <var>v</var> be ?&nbsp;<emu-xref aoid="ToBigInt"><a href="https://tc39.es/ecma262/#sec-tobigint" class="e-user-code">ToBigInt</a></emu-xref>(<var>value</var>).</li><li>Otherwise, let <var>v</var> be <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(? <emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>value</var>)).</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_85"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>typedArray</var>'s backing buffer is a growable SharedArrayBuffer.</ins></li><li><ins>Let <var>length</var> be <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_86"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>typedArray</var>, <var>getBufferByteLength</var>).</ins></li><li><ins>If <emu-const>length</emu-const> is <emu-const>out-of-bounds</emu-const>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li><ins>If <var>indexedPosition</var> ≥ <var>length</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li>Let <var>elementType</var> be <emu-xref aoid="TypedArrayElementType"><a href="https://tc39.es/ecma262/#sec-typedarrayelementtype">TypedArrayElementType</a></emu-xref>(<var>typedArray</var>).</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>v</var>, <emu-val>true</emu-val>, <emu-const>SeqCst</emu-const>).</li><li>Return <var>v</var>.</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-abstract-operations-for-atomics-mods">
    <h1><span class="secnum">6.2</span> Modifications to Abstract Operations for Atomics</h1>

    <emu-clause id="sec-atomicreadmodifywrite" type="abstract operation" aoid="AtomicReadModifyWrite">
      <h1><span class="secnum">6.2.1</span> AtomicReadModifyWrite ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>op</var> )</h1>
      <p>The abstract operation AtomicReadModifyWrite takes arguments <var>typedArray</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>), <var>index</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>), <var>value</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>), and <var>op</var> (a <emu-xref href="#sec-arraybuffer-notation"><a href="https://tc39.es/ecma262/#sec-arraybuffer-notation">read-modify-write modification function</a></emu-xref>) and returns either a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> either a Number or a BigInt, or a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>. <var>op</var> takes two <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">byte values</a></emu-xref> arguments and returns a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">byte values</a></emu-xref>. This operation atomically loads a value, combines it with another value, and stores the result of the combination. It returns the loaded value. It performs the following steps when called:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ?&nbsp;<emu-xref aoid="ValidateIntegerTypedArray"><a href="https://tc39.es/ecma262/#sec-validateintegertypedarray">ValidateIntegerTypedArray</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>indexedPosition</var> be ?&nbsp;<emu-xref aoid="ValidateAtomicAccess" id="_ref_87"><a href="#sec-validateatomicaccess" class="e-user-code">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>If <var>typedArray</var>.[[ContentType]] is <emu-const>BigInt</emu-const>, let <var>v</var> be ?&nbsp;<emu-xref aoid="ToBigInt"><a href="https://tc39.es/ecma262/#sec-tobigint" class="e-user-code">ToBigInt</a></emu-xref>(<var>value</var>).</li><li>Otherwise, let <var>v</var> be <emu-xref aoid="𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(? <emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity" class="e-user-code">ToIntegerOrInfinity</a></emu-xref>(<var>value</var>)).</li><li><del>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_88"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>typedArray</var>'s backing buffer is a growable SharedArrayBuffer.</ins></li><li><ins>Let <var>length</var> be <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_89"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>typedArray</var>, <var>getBufferByteLength</var>).</ins></li><li><ins>If <emu-const>length</emu-const> is <emu-const>out-of-bounds</emu-const>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li><ins>If <var>indexedPosition</var> ≥ <var>length</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li>NOTE: The above check<ins>s</ins> <del>is</del><ins>are</ins> not redundant with the check<ins>s</ins> in <emu-xref aoid="ValidateIntegerTypedArray"><a href="https://tc39.es/ecma262/#sec-validateintegertypedarray">ValidateIntegerTypedArray</a></emu-xref> <ins>and <emu-xref aoid="ValidateAtomicAccess" id="_ref_90"><a href="#sec-validateatomicaccess">ValidateAtomicAccess</a></emu-xref></ins> because the call to <emu-xref aoid="ToBigInt"><a href="https://tc39.es/ecma262/#sec-tobigint">ToBigInt</a></emu-xref> or <emu-xref aoid="ToIntegerOrInfinity"><a href="https://tc39.es/ecma262/#sec-tointegerorinfinity">ToIntegerOrInfinity</a></emu-xref> on the preceding lines can have arbitrary side effects, which could cause the buffer to become detached. <ins>These checks are only needed when <var>typedArray</var>'s backing buffer is an ArrayBuffer.</ins></li><li>Let <var>elementType</var> be <emu-xref aoid="TypedArrayElementType"><a href="https://tc39.es/ecma262/#sec-typedarrayelementtype">TypedArrayElementType</a></emu-xref>(<var>typedArray</var>).</li><li>Return <emu-xref aoid="GetModifySetValueInBuffer"><a href="https://tc39.es/ecma262/#sec-getmodifysetvalueinbuffer">GetModifySetValueInBuffer</a></emu-xref>(<var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>v</var>, <var>op</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-validateatomicaccess" type="abstract operation" aoid="ValidateAtomicAccess">
      <h1><span class="secnum">6.2.2</span> ValidateAtomicAccess ( <var>typedArray</var>, <var>requestIndex</var> )</h1>
      <p>The abstract operation ValidateAtomicAccess takes arguments <var>typedArray</var> (a TypedArray) and <var>requestIndex</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>) and returns either a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">normal completion containing</a></emu-xref> an <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> or a <emu-xref href="#sec-completion-record-specification-type"><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">throw completion</a></emu-xref>. It performs the following steps when called:</p>
      <emu-alg><ol><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_91"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li>Let <var>length</var> be <del><var>typedArray</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_92"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>typedArray</var>, <var>getBufferByteLength</var>)</ins>.</li><li><ins><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>length</var> is not <emu-const>out-of-bounds</emu-const>.</ins></li><li>Let <var>accessIndex</var> be ?&nbsp;<emu-xref aoid="ToIndex"><a href="https://tc39.es/ecma262/#sec-toindex" class="e-user-code">ToIndex</a></emu-xref>(<var>requestIndex</var>).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>accessIndex</var> ≥ 0.</li><li>If <var>accessIndex</var> ≥ <var>length</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 67</a></emu-xref> for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Return (<var>accessIndex</var> × <var>elementSize</var>) + <var>offset</var>.</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-maxbytelength-guidelines">
  <h1><span class="secnum">7</span> Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines</h1>
  <emu-note><span class="note">Note 1</span><div class="note-contents">
    <p>The following are guidelines for ECMAScript programmers working with resizable ArrayBuffer and growable SharedArrayBuffer.</p>
    <p>We recommend that programs be tested in their deployment environments where possible. The amount of available physical memory differ greatly between hardware devices. Similarly, virtual memory subsystems also differ greatly between hardware devices as well as operating systems. An application that runs without out-of-memory errors on a 64-bit desktop web browser could run out of memory on a 32-bit mobile web browser.</p>
    <p>When choosing a value for the <code>"maxByteLength"</code> option for resizable ArrayBuffer and growable SharedArrayBuffer, we recommend that the smallest possible size for the application be chosen. We recommend that <code>"maxByteLength"</code> does not exceed 1073741824, or 1GiB.</p>
    <p>Please note that successfully constructing a ResizableArrayBuffer or a growable SharedArrayBuffer for a particular maximum size does not guarantee that future resizes and grows will succeed.</p>
  </div></emu-note>

  <emu-note><span class="note">Note 2</span><div class="note-contents">
    <p>The following are guidelines for ECMAScript implementers implementing resizable ArrayBuffer.</p>
    <p>Resizable ArrayBuffer can be implemented as copying upon resize, as in-place growth via reserving virtual memory up front, or as a combination of both for different values of the <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref>'s <code>"maxByteLength"</code> option.</p>
    <p>If a <emu-xref href="#host"><a href="https://tc39.es/ecma262/#host">host</a></emu-xref> is multi-tenanted (i.e. it runs many JavaScript applications simultaneously), such as a web browser, and its implementations choose to implement in-place growth by reserving virtual memory, we recommend that both 32-bit and 64-bit implementations throw for values of <code>"maxByteLength"</code> ≥ 1GiB to 1.5GiB. This is to reduce the likelihood a single application can exhaust the virtual memory address space and to reduce interoperability risks.</p>
    <p>If a <emu-xref href="#host"><a href="https://tc39.es/ecma262/#host">host</a></emu-xref> does not have virtual memory, such as those running on embedded devices without an MMU, or if a <emu-xref href="#host"><a href="https://tc39.es/ecma262/#host">host</a></emu-xref> only implements resizing by copying, it may accept any <emu-xref href="#number-value-for"><a href="https://tc39.es/ecma262/#number-value-for">Number value for</a></emu-xref> the <code>"maxByteLength"</code> option. However, we recommend a <emu-val>RangeError</emu-val> be thrown if a memory block of the requested size can never be allocated. For example, if the requested size is greater than the maximium amount of usable memory on the device.</p>
  </div></emu-note>

  <emu-note><span class="note">Note 3</span><div class="note-contents">
    <p>The following are guidelines for ECMAScript implementers implementing growable SharedArrayBuffer.</p>
    <p>We recommend growable SharedArrayBuffer be implemented as in-place growth via reserving virtual memory up front.</p>
    <p>Because grow operations can be concurrent with memory accesses on a growable SharedArrayBuffer, the constraints of the <emu-xref href="#sec-memory-model"><a href="https://tc39.es/ecma262/#sec-memory-model">memory model</a></emu-xref> require that even unordered accesses do not "tear" (bits of their values will not be mixed). In practice, this means the underlying data block of a growable SharedArrayBuffer cannot be grown by being copied without stopping the world. We do not recommend stopping the world as an implementation strategy because it introduces a serialization point and is slow.</p>
    <p>Grown memory must appear zeroed from the moment of its creation, including to any racy concurrent accesses. This can be accomplished via zero-filled-on-demand virtual memory pages, or careful synchronization if manually zeroing memory.</p>
    <p>In practice it is difficult to implement growable SharedArrayBuffer by copying on <emu-xref href="#host"><a href="https://tc39.es/ecma262/#host">hosts</a></emu-xref> that do not have virtual memory, such as those running on embedded devices without an MMU. Memory usage behaviour of growable SharedArrayBuffers on such <emu-xref href="#host"><a href="https://tc39.es/ecma262/#host">hosts</a></emu-xref> may significantly differ from that of <emu-xref href="#host"><a href="https://tc39.es/ecma262/#host">hosts</a></emu-xref> with virtual memory. Such <emu-xref href="#host"><a href="https://tc39.es/ecma262/#host">hosts</a></emu-xref> should clearly communicate memory usage expectations to users.</p>
  </div></emu-note>
</emu-clause>

<emu-clause id="omitted-for-brevity">
  <h1><span class="secnum">8</span> Mechanical Changes Omitted for Brevity</h1>
  <ul>
    <li><p>Uses of [[ArrayLength]] on <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic objects</a></emu-xref> are replaced with calls to <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_93"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>.</p></li>
    <li><p>Uses of [[ByteLength]] on <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic objects</a></emu-xref> are replaced with calls to IntegerIndexedByteLength.</p></li>
    <li><p>Uses of [[ArrayBufferByteLength]] on buffer objects that may be growable SharedArrayBuffers are replaced with calls to <emu-xref aoid="ArrayBufferByteLength" id="_ref_94"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>.</p></li>
  </ul>
</emu-clause>
</div></body>