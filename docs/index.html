<!doctype html>
<head><meta charset="utf-8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<title>ResizableArrayBuffer and GrowableSharedArrayBuffer</title>
<script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"intro","aoid":null,"title":"ResizableArrayBuffer and GrowableSharedArrayBuffer","titleHTML":"ResizableArrayBuffer and GrowableSharedArrayBuffer","number":"","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ResizableArrayBuffer and GrowableSharedArrayBuffer"},{"type":"op","aoid":"AllocateArrayBuffer","refId":"sec-allocatearraybuffer","location":"","referencingIds":[],"key":"AllocateArrayBuffer"},{"type":"clause","id":"sec-allocatearraybuffer","aoid":"AllocateArrayBuffer","title":"AllocateArrayBuffer ( constructor, byteLength[ , requestedMaxByteLength ] )","titleHTML":"AllocateArrayBuffer ( <var>constructor</var>, <var>byteLength</var><ins>[ , <var>requestedMaxByteLength</var> ]</ins> )","number":"1.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_11","_ref_146"],"key":"AllocateArrayBuffer ( constructor, byteLength[ , requestedMaxByteLength ] )"},{"type":"op","aoid":"ArrayBufferByteLength","refId":"sec-arraybufferlength","location":"","referencingIds":[],"key":"ArrayBufferByteLength"},{"type":"clause","id":"sec-arraybufferlength","aoid":"ArrayBufferByteLength","title":"ArrayBufferByteLength ( arrayBuffer, order )","titleHTML":"ArrayBufferByteLength ( <var>arrayBuffer</var>, <var>order</var> )","number":"1.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_6","_ref_15","_ref_44","_ref_51","_ref_55","_ref_155","_ref_198"],"key":"ArrayBufferByteLength ( arrayBuffer, order )"},{"type":"op","aoid":"MakeIdempotentArrayBufferByteLengthGetter","refId":"sec-makeidempotentarraybufferbytelengthgetter","location":"","referencingIds":[],"key":"MakeIdempotentArrayBufferByteLengthGetter"},{"type":"clause","id":"sec-makeidempotentarraybufferbytelengthgetter","aoid":"MakeIdempotentArrayBufferByteLengthGetter","title":"MakeIdempotentArrayBufferByteLengthGetter ( order )","titleHTML":"MakeIdempotentArrayBufferByteLengthGetter ( <var>order</var> )","number":"1.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_97","_ref_104","_ref_112","_ref_116","_ref_120","_ref_124","_ref_127","_ref_141","_ref_163","_ref_174","_ref_187","_ref_192","_ref_194"],"key":"MakeIdempotentArrayBufferByteLengthGetter ( order )"},{"type":"op","aoid":"IsResizableArrayBuffer","refId":"sec-isresizablearraybuffer","location":"","referencingIds":[],"key":"IsResizableArrayBuffer"},{"type":"clause","id":"sec-isresizablearraybuffer","aoid":"IsResizableArrayBuffer","title":"IsResizableArrayBuffer ( arrayBuffer )","titleHTML":"IsResizableArrayBuffer ( <var>arrayBuffer</var> )","number":"1.4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_60","_ref_69","_ref_81","_ref_87","_ref_95","_ref_109","_ref_152","_ref_181"],"key":"IsResizableArrayBuffer ( arrayBuffer )"},{"type":"op","aoid":"HostResizeArrayBuffer","refId":"sec-hostresizearraybuffer","location":"","referencingIds":[],"key":"HostResizeArrayBuffer"},{"type":"clause","id":"sec-hostresizearraybuffer","aoid":"HostResizeArrayBuffer","title":"HostResizeArrayBuffer ( buffer, newByteLength )","titleHTML":"HostResizeArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )","number":"1.5","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_22"],"key":"HostResizeArrayBuffer ( buffer, newByteLength )"},{"type":"clause","id":"sec-abstract-operations-for-arraybuffer-objects-mods","aoid":null,"title":"Modifications to Abstract Operations for ArrayBuffer Objects","titleHTML":"Modifications to Abstract Operations for ArrayBuffer Objects","number":"1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Abstract Operations for ArrayBuffer Objects"},{"type":"term","term":"%ResizableArrayBuffer%","refId":"sec-resizablearraybuffer-constructor","referencingIds":[],"namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","key":"%ResizableArrayBuffer%"},{"type":"clause","id":"sec-resizablearraybuffer-initiallength-maxlength","aoid":null,"title":"ResizableArrayBuffer ( initialLength, maxLength )","titleHTML":"ResizableArrayBuffer ( <var>initialLength</var>, <var>maxLength</var> )","number":"2.1.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ResizableArrayBuffer ( initialLength, maxLength )"},{"type":"clause","id":"sec-resizablearraybuffer-constructor","aoid":null,"title":"The ResizableArrayBuffer Constructor","titleHTML":"The ResizableArrayBuffer Constructor","number":"2.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_16","_ref_199"],"key":"The ResizableArrayBuffer Constructor"},{"type":"clause","id":"sec-properties-of-the-resizablearraybuffer-constructor","aoid":null,"title":"Properties of the ResizableArrayBuffer Constructor","titleHTML":"Properties of the ResizableArrayBuffer Constructor","number":"2.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Properties of the ResizableArrayBuffer Constructor"},{"type":"clause","id":"sec-resizablearraybuffer.prototype","aoid":null,"title":"ResizableArrayBuffer.prototype","titleHTML":"ResizableArrayBuffer.prototype","number":"2.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ResizableArrayBuffer.prototype"},{"type":"term","term":"ResizableArrayBuffer prototype object","refId":"sec-properties-of-the-resizablearraybuffer-prototype-object","referencingIds":[],"namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","key":"ResizableArrayBuffer prototype object"},{"type":"term","term":"%ResizableArrayBuffer.prototype%","refId":"sec-properties-of-the-resizablearraybuffer-prototype-object","referencingIds":[],"namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","key":"%ResizableArrayBuffer.prototype%"},{"type":"clause","id":"sec-get-resizablearraybuffer.prototype.bytelength","aoid":null,"title":"get ResizableArrayBuffer.prototype.byteLength","titleHTML":"get ResizableArrayBuffer.prototype.byteLength","number":"2.4.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get ResizableArrayBuffer.prototype.byteLength"},{"type":"clause","id":"sec-resizablearraybuffer.prototype.constructor","aoid":null,"title":"ResizableArrayBuffer.prototype.constructor","titleHTML":"ResizableArrayBuffer.prototype.constructor","number":"2.4.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ResizableArrayBuffer.prototype.constructor"},{"type":"clause","id":"sec-get-resizablearraybuffer.prototype.maxbytelength","aoid":null,"title":"get ResizableArrayBuffer.prototype.maxByteLength","titleHTML":"get ResizableArrayBuffer.prototype.maxByteLength","number":"2.4.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get ResizableArrayBuffer.prototype.maxByteLength"},{"type":"clause","id":"sec-resizablearraybuffer.prototype.resize","aoid":null,"title":"ResizableArrayBuffer.prototype.resize ( newLength )","titleHTML":"ResizableArrayBuffer.prototype.resize ( <var>newLength</var> )","number":"2.4.4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ResizableArrayBuffer.prototype.resize ( newLength )"},{"type":"clause","id":"sec-resizablearraybuffer.prototype.slice","aoid":null,"title":"ResizableArrayBuffer.prototype.slice ( start, end )","titleHTML":"ResizableArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )","number":"2.4.5","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ResizableArrayBuffer.prototype.slice ( start, end )"},{"type":"clause","id":"sec-resizablearraybuffer.prototype.transfer","aoid":null,"title":"ResizableArrayBuffer.prototype.transfer ( [ newLength ] )","titleHTML":"ResizableArrayBuffer.prototype.transfer ( [ <var>newLength</var> ] )","number":"2.4.6","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ResizableArrayBuffer.prototype.transfer ( [ newLength ] )"},{"type":"clause","id":"sec-resizablearraybuffer.prototype-@@tostringtag","aoid":null,"title":"ResizableArrayBuffer.prototype [ @@toStringTag ]","titleHTML":"ResizableArrayBuffer.prototype [ @@toStringTag ]","number":"2.4.7","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ResizableArrayBuffer.prototype [ @@toStringTag ]"},{"type":"clause","id":"sec-properties-of-the-resizablearraybuffer-prototype-object","aoid":null,"title":"Properties of the ResizableArrayBuffer Prototype Object","titleHTML":"Properties of the ResizableArrayBuffer Prototype Object","number":"2.4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_12"],"key":"Properties of the ResizableArrayBuffer Prototype Object"},{"type":"clause","id":"sec-resizablearraybuffer-objects","aoid":null,"title":"ResizableArrayBuffer Objects","titleHTML":"ResizableArrayBuffer Objects","number":"2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ResizableArrayBuffer Objects"},{"type":"op","aoid":"AllocateSharedArrayBuffer","refId":"sec-allocatesharedarraybuffer","location":"","referencingIds":[],"key":"AllocateSharedArrayBuffer"},{"type":"clause","id":"sec-allocatesharedarraybuffer","aoid":"AllocateSharedArrayBuffer","title":"AllocateSharedArrayBuffer ( constructor, byteLength[ , requestedMaxByteLength ] )","titleHTML":"AllocateSharedArrayBuffer ( <var>constructor</var>, <var>byteLength</var><ins>[ , <var>requestedMaxByteLength</var> ]</ins> )","number":"3.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_40"],"key":"AllocateSharedArrayBuffer ( constructor, byteLength[ , requestedMaxByteLength ] )"},{"type":"op","aoid":"HostGrowSharedArrayBuffer","refId":"sec-hostgrowsharedarraybuffer","location":"","referencingIds":[],"key":"HostGrowSharedArrayBuffer"},{"type":"clause","id":"sec-hostgrowsharedarraybuffer","aoid":"HostGrowSharedArrayBuffer","title":"HostGrowSharedArrayBuffer ( buffer, newByteLength )","titleHTML":"HostGrowSharedArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )","number":"3.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_50"],"key":"HostGrowSharedArrayBuffer ( buffer, newByteLength )"},{"type":"clause","id":"sec-abstract-operations-for-sharedarraybuffer-objects-mods","aoid":null,"title":"Modifications to Abstract Operations for SharedArrayBuffer Objects","titleHTML":"Modifications to Abstract Operations for SharedArrayBuffer Objects","number":"3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Abstract Operations for SharedArrayBuffer Objects"},{"type":"term","term":"%GrowableSharedArrayBuffer%","refId":"sec-growablesharedarraybuffer-constructor","referencingIds":[],"namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","key":"%GrowableSharedArrayBuffer%"},{"type":"clause","id":"sec-growablesharedarraybuffere-initiallength-maxlength","aoid":null,"title":"GrowableSharedArrayBuffer ( initialLength, maxLength )","titleHTML":"GrowableSharedArrayBuffer ( <var>initialLength</var>, <var>maxLength</var> )","number":"4.1.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"GrowableSharedArrayBuffer ( initialLength, maxLength )"},{"type":"clause","id":"sec-growablesharedarraybuffer-constructor","aoid":null,"title":"The GrowableSharedArrayBuffer Constructor","titleHTML":"The GrowableSharedArrayBuffer Constructor","number":"4.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_45","_ref_200"],"key":"The GrowableSharedArrayBuffer Constructor"},{"type":"clause","id":"sec-properties-of-the-growablesharedarraybuffer-constructor","aoid":null,"title":"Properties of the GrowableSharedArrayBuffer Constructor","titleHTML":"Properties of the GrowableSharedArrayBuffer Constructor","number":"4.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Properties of the GrowableSharedArrayBuffer Constructor"},{"type":"clause","id":"sec-growablesharedarraybuffer.prototype","aoid":null,"title":"GrowableSharedArrayBuffer.prototype","titleHTML":"GrowableSharedArrayBuffer.prototype","number":"4.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"GrowableSharedArrayBuffer.prototype"},{"type":"term","term":"GrowableSharedArrayBuffer prototype object","refId":"sec-properties-of-the-growablesharedarraybuffer-prototype-object","referencingIds":[],"namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","key":"GrowableSharedArrayBuffer prototype object"},{"type":"term","term":"%GrowableSharedArrayBuffer.prototype%","refId":"sec-properties-of-the-growablesharedarraybuffer-prototype-object","referencingIds":[],"namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","key":"%GrowableSharedArrayBuffer.prototype%"},{"type":"clause","id":"sec-get-growablesharedarraybuffer.prototype.bytelength","aoid":null,"title":"get GrowableSharedArrayBuffer.prototype.byteLength","titleHTML":"get GrowableSharedArrayBuffer.prototype.byteLength","number":"4.4.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get GrowableSharedArrayBuffer.prototype.byteLength"},{"type":"clause","id":"sec-growablesharedarraybuffer.prototype.constructor","aoid":null,"title":"GrowableSharedArrayBuffer.prototype.constructor","titleHTML":"GrowableSharedArrayBuffer.prototype.constructor","number":"4.4.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"GrowableSharedArrayBuffer.prototype.constructor"},{"type":"clause","id":"sec-get-growablesharedarraybuffer.prototype.maxbytelength","aoid":null,"title":"get GrowableSharedArrayBuffer.prototype.maxByteLength","titleHTML":"get GrowableSharedArrayBuffer.prototype.maxByteLength","number":"4.4.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get GrowableSharedArrayBuffer.prototype.maxByteLength"},{"type":"clause","id":"sec-growablesharedarraybuffer.prototype.grow","aoid":null,"title":"GrowableSharedArrayBuffer.prototype.grow ( newLength )","titleHTML":"GrowableSharedArrayBuffer.prototype.grow ( <var>newLength</var> )","number":"4.4.4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"GrowableSharedArrayBuffer.prototype.grow ( newLength )"},{"type":"clause","id":"sec-growablesharedarraybuffer.prototype.slice","aoid":null,"title":"GrowableSharedArrayBuffer.prototype.slice ( start, end )","titleHTML":"GrowableSharedArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )","number":"4.4.5","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"GrowableSharedArrayBuffer.prototype.slice ( start, end )"},{"type":"clause","id":"sec-growablesharedarraybuffer.prototype.toString","aoid":null,"title":"GrowableSharedArrayBuffer.prototype [ @@toStringTag ]","titleHTML":"GrowableSharedArrayBuffer.prototype [ @@toStringTag ]","number":"4.4.6","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"GrowableSharedArrayBuffer.prototype [ @@toStringTag ]"},{"type":"clause","id":"sec-properties-of-the-growablesharedarraybuffer-prototype-object","aoid":null,"title":"Properties of the GrowableSharedArrayBuffer Prototype Object","titleHTML":"Properties of the GrowableSharedArrayBuffer Prototype Object","number":"4.4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_41"],"key":"Properties of the GrowableSharedArrayBuffer Prototype Object"},{"type":"clause","id":"sec-growablesharedarraybuffer-objects","aoid":null,"title":"GrowableSharedArrayBuffer Objects","titleHTML":"GrowableSharedArrayBuffer Objects","number":"4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"GrowableSharedArrayBuffer Objects"},{"type":"clause","id":"sec-get-arraybuffer.prototype.bytelength","aoid":null,"title":"get ArrayBuffer.prototype.byteLength","titleHTML":"get ArrayBuffer.prototype.byteLength","number":"5.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get ArrayBuffer.prototype.byteLength"},{"type":"clause","id":"sec-arraybuffer.prototype.slice","aoid":null,"title":"ArrayBuffer.prototype.slice ( start, end )","titleHTML":"ArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )","number":"5.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ArrayBuffer.prototype.slice ( start, end )"},{"type":"clause","id":"sec-arraybuffer.prototype.transfer","aoid":null,"title":"ArrayBuffer.prototype.transfer ( [ newLength ] )","titleHTML":"ArrayBuffer.prototype.transfer ( [ <var>newLength</var> ] )","number":"5.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ArrayBuffer.prototype.transfer ( [ newLength ] )"},{"type":"clause","id":"sec-properties-of-the-arraybuffer-prototype-object-mods","aoid":null,"title":"Modifications to Properties of the ArrayBuffer Prototype Object","titleHTML":"Modifications to Properties of the ArrayBuffer Prototype Object","number":"5","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Properties of the ArrayBuffer Prototype Object"},{"type":"clause","id":"sec-get-sharedarraybuffer.prototype.bytelength","aoid":null,"title":"get SharedArrayBuffer.prototype.byteLength","titleHTML":"get SharedArrayBuffer.prototype.byteLength","number":"6.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get SharedArrayBuffer.prototype.byteLength"},{"type":"clause","id":"sec-sharedarraybuffer.prototype.slice","aoid":null,"title":"SharedArrayBuffer.prototype.slice ( start, end )","titleHTML":"SharedArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )","number":"6.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"SharedArrayBuffer.prototype.slice ( start, end )"},{"type":"clause","id":"sec-properties-of-the-sharedarraybuffer-prototype-object-mods","aoid":null,"title":"Modifications to Properties of the SharedArrayBuffer Prototype Object","titleHTML":"Modifications to Properties of the SharedArrayBuffer Prototype Object","number":"6","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Properties of the SharedArrayBuffer Prototype Object"},{"type":"clause","id":"sec-integer-indexed-exotic-objects-ownpropertykeys","aoid":null,"title":"[[OwnPropertyKeys]] ( )","titleHTML":"[[OwnPropertyKeys]] ( )","number":"7.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"[[OwnPropertyKeys]] ( )"},{"type":"op","aoid":"IsValidIntegerIndex","refId":"sec-isvalidintegerindex","location":"","referencingIds":[],"key":"IsValidIntegerIndex"},{"type":"clause","id":"sec-isvalidintegerindex","aoid":"IsValidIntegerIndex","title":"IsValidIntegerIndex ( O, index )","titleHTML":"IsValidIntegerIndex ( <var>O</var>, <var>index</var> )","number":"7.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"IsValidIntegerIndex ( O, index )"},{"type":"op","aoid":"IntegerIndexedObjectByteLength","refId":"sec-integerindexedobjectbytelength","location":"","referencingIds":[],"key":"IntegerIndexedObjectByteLength"},{"type":"clause","id":"sec-integerindexedobjectbytelength","aoid":"IntegerIndexedObjectByteLength","title":"IntegerIndexedObjectByteLength ( O, getBufferByteLength )","titleHTML":"IntegerIndexedObjectByteLength ( <var>O</var>, <var>getBufferByteLength</var> )","number":"7.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_117","_ref_134"],"key":"IntegerIndexedObjectByteLength ( O, getBufferByteLength )"},{"type":"op","aoid":"IntegerIndexedObjectLength","refId":"sec-integerindexedobjectlength","location":"","referencingIds":[],"key":"IntegerIndexedObjectLength"},{"type":"clause","id":"sec-integerindexedobjectlength","aoid":"IntegerIndexedObjectLength","title":"IntegerIndexedObjectLength ( O, getBufferByteLength )","titleHTML":"IntegerIndexedObjectLength ( <var>O</var>, <var>getBufferByteLength</var> )","number":"7.4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_98","_ref_106","_ref_107","_ref_125","_ref_128","_ref_142","_ref_195","_ref_197"],"key":"IntegerIndexedObjectLength ( O, getBufferByteLength )"},{"type":"op","aoid":"IsIntegerIndexedObjectOutOfBounds","refId":"sec-isintegerindexedobjectoutofbounds","location":"","referencingIds":[],"key":"IsIntegerIndexedObjectOutOfBounds"},{"type":"clause","id":"sec-isintegerindexedobjectoutofbounds","aoid":"IsIntegerIndexedObjectOutOfBounds","title":"IsIntegerIndexedObjectOutOfBounds ( O, getBufferByteLength )","titleHTML":"IsIntegerIndexedObjectOutOfBounds ( <var>O</var>, <var>getBufferByteLength</var> )","number":"7.5","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_105","_ref_108","_ref_113","_ref_121","_ref_130","_ref_148"],"key":"IsIntegerIndexedObjectOutOfBounds ( O, getBufferByteLength )"},{"type":"clause","id":"sec-integer-indexed-exotic-objects-mods","aoid":null,"title":"Modifications to Integer-Indexed Exotic Objects","titleHTML":"Modifications to Integer-Indexed Exotic Objects","number":"7","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Integer-Indexed Exotic Objects"},{"type":"op","aoid":"ValidateTypedArray","refId":"sec-validatetypedarray","location":"","referencingIds":[],"key":"ValidateTypedArray"},{"type":"clause","id":"sec-validatetypedarray","aoid":"ValidateTypedArray","title":"Runtime Semantics: ValidateTypedArray ( O )","titleHTML":"Runtime Semantics: ValidateTypedArray ( <var>O</var> )","number":"8.1.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Runtime Semantics: ValidateTypedArray ( O )"},{"type":"clause","id":"sec-get-%typedarray%.prototype.bytelength","aoid":null,"title":"get %TypedArray%.prototype.byteLength","titleHTML":"get %TypedArray%.prototype.byteLength","number":"8.1.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get %TypedArray%.prototype.byteLength"},{"type":"clause","id":"sec-get-%typedarray%.prototype.byteoffset","aoid":null,"title":"get %TypedArray%.prototype.byteOffset","titleHTML":"get %TypedArray%.prototype.byteOffset","number":"8.1.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get %TypedArray%.prototype.byteOffset"},{"type":"clause","id":"sec-get-%typedarray%.prototype.length","aoid":null,"title":"get %TypedArray%.prototype.length","titleHTML":"get %TypedArray%.prototype.length","number":"8.1.4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get %TypedArray%.prototype.length"},{"type":"op","aoid":"SetTypedArrayFromTypedArray","refId":"sec-settypedarrayfromtypedarray","location":"","referencingIds":[],"key":"SetTypedArrayFromTypedArray"},{"type":"clause","id":"sec-settypedarrayfromtypedarray","aoid":"SetTypedArrayFromTypedArray","title":"SetTypedArrayFromTypedArray ( target, targetOffset, source )","titleHTML":"SetTypedArrayFromTypedArray ( <var>target</var>, <var>targetOffset</var>, <var>source</var> )","number":"8.1.5","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"SetTypedArrayFromTypedArray ( target, targetOffset, source )"},{"type":"clause","id":"sec-properties-of-the-%typedarrayprototype%-object-mods","aoid":null,"title":"Modifications to Properties of the %TypedArray.prototype% Object","titleHTML":"Modifications to Properties of the %TypedArray.prototype% Object","number":"8.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Properties of the %TypedArray.prototype% Object"},{"type":"op","aoid":"InitializeTypedArrayFromTypedArray","refId":"sec-initializetypedarrayfromtypedarray","location":"","referencingIds":[],"key":"InitializeTypedArrayFromTypedArray"},{"type":"clause","id":"sec-initializetypedarrayfromtypedarray","aoid":"InitializeTypedArrayFromTypedArray","title":"InitializeTypedArrayFromTypedArray ( O, srcArray )","titleHTML":"InitializeTypedArrayFromTypedArray ( <var>O</var>, <var>srcArray</var> )","number":"8.2.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"InitializeTypedArrayFromTypedArray ( O, srcArray )"},{"type":"op","aoid":"InitializeTypedArrayFromArrayBuffer","refId":"sec-initializetypedarrayfromarraybuffer","location":"","referencingIds":[],"key":"InitializeTypedArrayFromArrayBuffer"},{"type":"clause","id":"sec-initializetypedarrayfromarraybuffer","aoid":"InitializeTypedArrayFromArrayBuffer","title":"InitializeTypedArrayFromArrayBuffer ( O, buffer, byteOffset, length )","titleHTML":"InitializeTypedArrayFromArrayBuffer ( <var>O</var>, <var>buffer</var>, <var>byteOffset</var>, <var>length</var> )","number":"8.2.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"InitializeTypedArrayFromArrayBuffer ( O, buffer, byteOffset, length )"},{"type":"clause","id":"sec-typedarray-constructors-mods","aoid":null,"title":"Modifications to the TypedArray Constructors","titleHTML":"Modifications to the <var>TypedArray</var> Constructors","number":"8.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to the TypedArray Constructors"},{"type":"clause","id":"sec-typedarray-objects-mods","aoid":null,"title":"Modifications to TypedArray Objects","titleHTML":"Modifications to TypedArray Objects","number":"8","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to TypedArray Objects"},{"type":"op","aoid":"GetViewByteLength","refId":"sec-getviewbytelength","location":"","referencingIds":[],"key":"GetViewByteLength"},{"type":"clause","id":"sec-getviewbytelength","aoid":"GetViewByteLength","title":"GetViewByteLength ( view, getBufferByteLength )","titleHTML":"GetViewByteLength ( <var>view</var>, <var>getBufferByteLength</var> )","number":"9.1.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_158","_ref_165","_ref_176","_ref_189"],"key":"GetViewByteLength ( view, getBufferByteLength )"},{"type":"op","aoid":"IsViewOutOfBounds","refId":"sec-isviewoutofbounds","location":"","referencingIds":[],"key":"IsViewOutOfBounds"},{"type":"clause","id":"sec-isviewoutofbounds","aoid":"IsViewOutOfBounds","title":"IsViewOutOfBounds ( view, getBufferByteLength )","titleHTML":"IsViewOutOfBounds ( <var>view</var>, <var>getBufferByteLength</var> )","number":"9.1.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_164","_ref_175","_ref_188","_ref_193"],"key":"IsViewOutOfBounds ( view, getBufferByteLength )"},{"type":"op","aoid":"GetViewValue","refId":"sec-getviewvalue","location":"","referencingIds":[],"key":"GetViewValue"},{"type":"clause","id":"sec-getviewvalue","aoid":"GetViewValue","title":"GetViewValue ( view, requestIndex, isLittleEndian, type )","titleHTML":"GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> )","number":"9.1.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"GetViewValue ( view, requestIndex, isLittleEndian, type )"},{"type":"op","aoid":"SetViewValue","refId":"sec-setviewvalue","location":"","referencingIds":[],"key":"SetViewValue"},{"type":"clause","id":"sec-setviewvalue","aoid":"SetViewValue","title":"SetViewValue ( view, requestIndex, isLittleEndian, type, value )","titleHTML":"SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> )","number":"9.1.4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"SetViewValue ( view, requestIndex, isLittleEndian, type, value )"},{"type":"clause","id":"sec-abstract-operations-for-dataview-objects-mods","aoid":null,"title":"Modifications to Abstract Operations For DataView Objects","titleHTML":"Modifications to Abstract Operations For DataView Objects","number":"9.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Abstract Operations For DataView Objects"},{"type":"clause","id":"sec-dataview-buffer-byteoffset-bytelength","aoid":null,"title":"DataView ( buffer [ , byteOffset [ , byteLength ] ] )","titleHTML":"DataView ( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>byteLength</var> ] ] )","number":"9.2.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"DataView ( buffer [ , byteOffset [ , byteLength ] ] )"},{"type":"clause","id":"sec-dataview-constructor-mods","aoid":null,"title":"Modifications to the DataView Constructor","titleHTML":"Modifications to the DataView Constructor","number":"9.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to the DataView Constructor"},{"type":"clause","id":"sec-get-dataview.prototype.bytelength","aoid":null,"title":"get DataView.prototype.byteLength","titleHTML":"get DataView.prototype.byteLength","number":"9.3.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get DataView.prototype.byteLength"},{"type":"clause","id":"sec-get-dataview.prototype.byteoffset","aoid":null,"title":"get DataView.prototype.byteOffset","titleHTML":"get DataView.prototype.byteOffset","number":"9.3.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get DataView.prototype.byteOffset"},{"type":"clause","id":"sec-properties-of-the-dataview-prototype-object-mods","aoid":null,"title":"Modifications to Properties of the DataView Prototype Object","titleHTML":"Modifications to Properties of the DataView Prototype Object","number":"9.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Properties of the DataView Prototype Object"},{"type":"clause","id":"sec-dataview-objects-mods","aoid":null,"title":"Modifications to DataView Objects","titleHTML":"Modifications to DataView Objects","number":"9","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to DataView Objects"},{"type":"op","aoid":"ValidateAtomicAccess","refId":"sec-validateatomicaccess","location":"","referencingIds":[],"key":"ValidateAtomicAccess"},{"type":"clause","id":"sec-validateatomicaccess","aoid":"ValidateAtomicAccess","title":"ValidateAtomicAccess ( typedArray, requestIndex )","titleHTML":"ValidateAtomicAccess ( <var>typedArray</var>, <var>requestIndex</var> )","number":"10.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ValidateAtomicAccess ( typedArray, requestIndex )"},{"type":"clause","id":"sec-abstract-operations-for-atomics-mods","aoid":null,"title":"Modifications to Abstract Operations for Atomics","titleHTML":"Modifications to Abstract Operations for Atomics","number":"10","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Abstract Operations for Atomics"},{"type":"clause","id":"sec-maxbytelength-guidelines","aoid":null,"title":"ResizableArrayBuffer and GrowableSharedArrayBuffer Guidelines","titleHTML":"ResizableArrayBuffer and GrowableSharedArrayBuffer Guidelines","number":"11","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ResizableArrayBuffer and GrowableSharedArrayBuffer Guidelines"},{"type":"clause","id":"omitted-for-brevity","aoid":null,"title":"Mechanical Changes Omitted for Brevity","titleHTML":"Mechanical Changes Omitted for Brevity","number":"12","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Mechanical Changes Omitted for Brevity"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu-spacer"></div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-pins"><div class="menu-pane-header">Pins</div><ul id="menu-pins-list"></ul></div><div class="menu-pane-header">Table of Contents</div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="ResizableArrayBuffer and GrowableSharedArrayBuffer">ResizableArrayBuffer and GrowableSharedArrayBuffer</a></li><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-arraybuffer-objects-mods" title="Modifications to Abstract Operations for ArrayBuffer Objects"><span class="secnum">1</span> Modifications to Abstract Operations for ArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-allocatearraybuffer" title="AllocateArrayBuffer ( constructor, byteLength[ , requestedMaxByteLength ] )"><span class="secnum">1.1</span> AllocateArrayBuffer ( <var>constructor</var>, <var>byteLength</var><ins>[ , <var>requestedMaxByteLength</var> ]</ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybufferlength" title="ArrayBufferByteLength ( arrayBuffer, order )"><span class="secnum">1.2</span> ArrayBufferByteLength ( <var>arrayBuffer</var>, <var>order</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-makeidempotentarraybufferbytelengthgetter" title="MakeIdempotentArrayBufferByteLengthGetter ( order )"><span class="secnum">1.3</span> MakeIdempotentArrayBufferByteLengthGetter ( <var>order</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isresizablearraybuffer" title="IsResizableArrayBuffer ( arrayBuffer )"><span class="secnum">1.4</span> IsResizableArrayBuffer ( <var>arrayBuffer</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-hostresizearraybuffer" title="HostResizeArrayBuffer ( buffer, newByteLength )"><span class="secnum">1.5</span> HostResizeArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-resizablearraybuffer-objects" title="ResizableArrayBuffer Objects"><span class="secnum">2</span> ResizableArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-resizablearraybuffer-constructor" title="The ResizableArrayBuffer Constructor"><span class="secnum">2.1</span> The ResizableArrayBuffer Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-resizablearraybuffer-initiallength-maxlength" title="ResizableArrayBuffer ( initialLength, maxLength )"><span class="secnum">2.1.1</span> ResizableArrayBuffer ( <var>initialLength</var>, <var>maxLength</var> )</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#sec-properties-of-the-resizablearraybuffer-constructor" title="Properties of the ResizableArrayBuffer Constructor"><span class="secnum">2.2</span> Properties of the ResizableArrayBuffer Constructor</a></li><li><span class="item-toggle-none"></span><a href="#sec-resizablearraybuffer.prototype" title="ResizableArrayBuffer.prototype"><span class="secnum">2.3</span> ResizableArrayBuffer.prototype</a></li><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-resizablearraybuffer-prototype-object" title="Properties of the ResizableArrayBuffer Prototype Object"><span class="secnum">2.4</span> Properties of the ResizableArrayBuffer Prototype Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-resizablearraybuffer.prototype.bytelength" title="get ResizableArrayBuffer.prototype.byteLength"><span class="secnum">2.4.1</span> get ResizableArrayBuffer.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-resizablearraybuffer.prototype.constructor" title="ResizableArrayBuffer.prototype.constructor"><span class="secnum">2.4.2</span> ResizableArrayBuffer.prototype.constructor</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-resizablearraybuffer.prototype.maxbytelength" title="get ResizableArrayBuffer.prototype.maxByteLength"><span class="secnum">2.4.3</span> get ResizableArrayBuffer.prototype.maxByteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-resizablearraybuffer.prototype.resize" title="ResizableArrayBuffer.prototype.resize ( newLength )"><span class="secnum">2.4.4</span> ResizableArrayBuffer.prototype.resize ( <var>newLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-resizablearraybuffer.prototype.slice" title="ResizableArrayBuffer.prototype.slice ( start, end )"><span class="secnum">2.4.5</span> ResizableArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-resizablearraybuffer.prototype.transfer" title="ResizableArrayBuffer.prototype.transfer ( [ newLength ] )"><span class="secnum">2.4.6</span> ResizableArrayBuffer.prototype.transfer ( [ <var>newLength</var> ] )</a></li><li><span class="item-toggle-none"></span><a href="#sec-resizablearraybuffer.prototype-@@tostringtag" title="ResizableArrayBuffer.prototype [ @@toStringTag ]"><span class="secnum">2.4.7</span> ResizableArrayBuffer.prototype [ @@toStringTag ]</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-sharedarraybuffer-objects-mods" title="Modifications to Abstract Operations for SharedArrayBuffer Objects"><span class="secnum">3</span> Modifications to Abstract Operations for SharedArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-allocatesharedarraybuffer" title="AllocateSharedArrayBuffer ( constructor, byteLength[ , requestedMaxByteLength ] )"><span class="secnum">3.1</span> AllocateSharedArrayBuffer ( <var>constructor</var>, <var>byteLength</var><ins>[ , <var>requestedMaxByteLength</var> ]</ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-hostgrowsharedarraybuffer" title="HostGrowSharedArrayBuffer ( buffer, newByteLength )"><span class="secnum">3.2</span> HostGrowSharedArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-growablesharedarraybuffer-objects" title="GrowableSharedArrayBuffer Objects"><span class="secnum">4</span> GrowableSharedArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-growablesharedarraybuffer-constructor" title="The GrowableSharedArrayBuffer Constructor"><span class="secnum">4.1</span> The GrowableSharedArrayBuffer Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-growablesharedarraybuffere-initiallength-maxlength" title="GrowableSharedArrayBuffer ( initialLength, maxLength )"><span class="secnum">4.1.1</span> GrowableSharedArrayBuffer ( <var>initialLength</var>, <var>maxLength</var> )</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#sec-properties-of-the-growablesharedarraybuffer-constructor" title="Properties of the GrowableSharedArrayBuffer Constructor"><span class="secnum">4.2</span> Properties of the GrowableSharedArrayBuffer Constructor</a></li><li><span class="item-toggle-none"></span><a href="#sec-growablesharedarraybuffer.prototype" title="GrowableSharedArrayBuffer.prototype"><span class="secnum">4.3</span> GrowableSharedArrayBuffer.prototype</a></li><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-growablesharedarraybuffer-prototype-object" title="Properties of the GrowableSharedArrayBuffer Prototype Object"><span class="secnum">4.4</span> Properties of the GrowableSharedArrayBuffer Prototype Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-growablesharedarraybuffer.prototype.bytelength" title="get GrowableSharedArrayBuffer.prototype.byteLength"><span class="secnum">4.4.1</span> get GrowableSharedArrayBuffer.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-growablesharedarraybuffer.prototype.constructor" title="GrowableSharedArrayBuffer.prototype.constructor"><span class="secnum">4.4.2</span> GrowableSharedArrayBuffer.prototype.constructor</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-growablesharedarraybuffer.prototype.maxbytelength" title="get GrowableSharedArrayBuffer.prototype.maxByteLength"><span class="secnum">4.4.3</span> get GrowableSharedArrayBuffer.prototype.maxByteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-growablesharedarraybuffer.prototype.grow" title="GrowableSharedArrayBuffer.prototype.grow ( newLength )"><span class="secnum">4.4.4</span> GrowableSharedArrayBuffer.prototype.grow ( <var>newLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-growablesharedarraybuffer.prototype.slice" title="GrowableSharedArrayBuffer.prototype.slice ( start, end )"><span class="secnum">4.4.5</span> GrowableSharedArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-growablesharedarraybuffer.prototype.toString" title="GrowableSharedArrayBuffer.prototype [ @@toStringTag ]"><span class="secnum">4.4.6</span> GrowableSharedArrayBuffer.prototype [ @@toStringTag ]</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-arraybuffer-prototype-object-mods" title="Modifications to Properties of the ArrayBuffer Prototype Object"><span class="secnum">5</span> Modifications to Properties of the ArrayBuffer Prototype Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-arraybuffer.prototype.bytelength" title="get ArrayBuffer.prototype.byteLength"><span class="secnum">5.1</span> get ArrayBuffer.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer.prototype.slice" title="ArrayBuffer.prototype.slice ( start, end )"><span class="secnum">5.2</span> ArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer.prototype.transfer" title="ArrayBuffer.prototype.transfer ( [ newLength ] )"><span class="secnum">5.3</span> ArrayBuffer.prototype.transfer ( [ <var>newLength</var> ] )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-sharedarraybuffer-prototype-object-mods" title="Modifications to Properties of the SharedArrayBuffer Prototype Object"><span class="secnum">6</span> Modifications to Properties of the SharedArrayBuffer Prototype Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-sharedarraybuffer.prototype.bytelength" title="get SharedArrayBuffer.prototype.byteLength"><span class="secnum">6.1</span> get SharedArrayBuffer.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-sharedarraybuffer.prototype.slice" title="SharedArrayBuffer.prototype.slice ( start, end )"><span class="secnum">6.2</span> SharedArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-integer-indexed-exotic-objects-mods" title="Modifications to Integer-Indexed Exotic Objects"><span class="secnum">7</span> Modifications to Integer-Indexed Exotic Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-integer-indexed-exotic-objects-ownpropertykeys" title="[[OwnPropertyKeys]] ( )"><span class="secnum">7.1</span> [[OwnPropertyKeys]] ( )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isvalidintegerindex" title="IsValidIntegerIndex ( O, index )"><span class="secnum">7.2</span> IsValidIntegerIndex ( <var>O</var>, <var>index</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-integerindexedobjectbytelength" title="IntegerIndexedObjectByteLength ( O, getBufferByteLength )"><span class="secnum">7.3</span> IntegerIndexedObjectByteLength ( <var>O</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-integerindexedobjectlength" title="IntegerIndexedObjectLength ( O, getBufferByteLength )"><span class="secnum">7.4</span> IntegerIndexedObjectLength ( <var>O</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isintegerindexedobjectoutofbounds" title="IsIntegerIndexedObjectOutOfBounds ( O, getBufferByteLength )"><span class="secnum">7.5</span> IsIntegerIndexedObjectOutOfBounds ( <var>O</var>, <var>getBufferByteLength</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-typedarray-objects-mods" title="Modifications to TypedArray Objects"><span class="secnum">8</span> Modifications to TypedArray Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-%typedarrayprototype%-object-mods" title="Modifications to Properties of the %TypedArray.prototype% Object"><span class="secnum">8.1</span> Modifications to Properties of the %TypedArray.prototype% Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-validatetypedarray" title="Runtime Semantics: ValidateTypedArray ( O )"><span class="secnum">8.1.1</span> RS: ValidateTypedArray ( <var>O</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-%typedarray%.prototype.bytelength" title="get %TypedArray%.prototype.byteLength"><span class="secnum">8.1.2</span> get %TypedArray%.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-%typedarray%.prototype.byteoffset" title="get %TypedArray%.prototype.byteOffset"><span class="secnum">8.1.3</span> get %TypedArray%.prototype.byteOffset</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-%typedarray%.prototype.length" title="get %TypedArray%.prototype.length"><span class="secnum">8.1.4</span> get %TypedArray%.prototype.length</a></li><li><span class="item-toggle-none"></span><a href="#sec-settypedarrayfromtypedarray" title="SetTypedArrayFromTypedArray ( target, targetOffset, source )"><span class="secnum">8.1.5</span> SetTypedArrayFromTypedArray ( <var>target</var>, <var>targetOffset</var>, <var>source</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-typedarray-constructors-mods" title="Modifications to the TypedArray Constructors"><span class="secnum">8.2</span> Modifications to the <var>TypedArray</var> Constructors</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-initializetypedarrayfromtypedarray" title="InitializeTypedArrayFromTypedArray ( O, srcArray )"><span class="secnum">8.2.1</span> InitializeTypedArrayFromTypedArray ( <var>O</var>, <var>srcArray</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-initializetypedarrayfromarraybuffer" title="InitializeTypedArrayFromArrayBuffer ( O, buffer, byteOffset, length )"><span class="secnum">8.2.2</span> InitializeTypedArrayFromArrayBuffer ( <var>O</var>, <var>buffer</var>, <var>byteOffset</var>, <var>length</var> )</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-dataview-objects-mods" title="Modifications to DataView Objects"><span class="secnum">9</span> Modifications to DataView Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-dataview-objects-mods" title="Modifications to Abstract Operations For DataView Objects"><span class="secnum">9.1</span> Modifications to Abstract Operations For DataView Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-getviewbytelength" title="GetViewByteLength ( view, getBufferByteLength )"><span class="secnum">9.1.1</span> GetViewByteLength ( <var>view</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isviewoutofbounds" title="IsViewOutOfBounds ( view, getBufferByteLength )"><span class="secnum">9.1.2</span> IsViewOutOfBounds ( <var>view</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-getviewvalue" title="GetViewValue ( view, requestIndex, isLittleEndian, type )"><span class="secnum">9.1.3</span> GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-setviewvalue" title="SetViewValue ( view, requestIndex, isLittleEndian, type, value )"><span class="secnum">9.1.4</span> SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-dataview-constructor-mods" title="Modifications to the DataView Constructor"><span class="secnum">9.2</span> Modifications to the DataView Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-dataview-buffer-byteoffset-bytelength" title="DataView ( buffer [ , byteOffset [ , byteLength ] ] )"><span class="secnum">9.2.1</span> DataView ( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>byteLength</var> ] ] )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-dataview-prototype-object-mods" title="Modifications to Properties of the DataView Prototype Object"><span class="secnum">9.3</span> Modifications to Properties of the DataView Prototype Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-dataview.prototype.bytelength" title="get DataView.prototype.byteLength"><span class="secnum">9.3.1</span> get DataView.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-dataview.prototype.byteoffset" title="get DataView.prototype.byteOffset"><span class="secnum">9.3.2</span> get DataView.prototype.byteOffset</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-atomics-mods" title="Modifications to Abstract Operations for Atomics"><span class="secnum">10</span> Modifications to Abstract Operations for Atomics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-validateatomicaccess" title="ValidateAtomicAccess ( typedArray, requestIndex )"><span class="secnum">10.1</span> ValidateAtomicAccess ( <var>typedArray</var>, <var>requestIndex</var> )</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#sec-maxbytelength-guidelines" title="ResizableArrayBuffer and GrowableSharedArrayBuffer Guidelines"><span class="secnum">11</span> ResizableArrayBuffer and GrowableSharedArrayBuffer Guidelines</a></li><li><span class="item-toggle-none"></span><a href="#omitted-for-brevity" title="Mechanical Changes Omitted for Brevity"><span class="secnum">12</span> Mechanical Changes Omitted for Brevity</a></li></ol></div></div><div id="spec-container"><h1 class="version first">Stage 2 Draft / March 30, 2021</h1>
<emu-intro id="intro">
  <h1>ResizableArrayBuffer and GrowableSharedArrayBuffer</h1>
  <p>We provide two new constructors, <code>ResizableArrayBuffer</code> and <code>GrowableSharedArrayBuffer</code>, which allow dynamically resizable array buffers. In addition, a <code>transfer</code> method is added to the existing <code>ArrayBuffer</code> prototype.</p>
</emu-intro>

<emu-clause id="sec-abstract-operations-for-arraybuffer-objects-mods">
  <h1><span class="secnum">1</span> Modifications to Abstract Operations for ArrayBuffer Objects</h1>

  <emu-clause id="sec-allocatearraybuffer" aoid="AllocateArrayBuffer">
    <h1><span class="secnum">1.1</span> AllocateArrayBuffer ( <var>constructor</var>, <var>byteLength</var><ins>[ , <var>requestedMaxByteLength</var> ]</ins> )</h1>
    <p>The abstract operation AllocateArrayBuffer takes arguments <var>constructor</var><del> and</del><ins>,</ins> <var>byteLength</var><ins>, and <var>requestedMaxByteLength</var></ins>. It is used to create an ArrayBuffer object. It performs the following steps when called:</p>
    <emu-alg><ol><li><ins>Let <var>slots</var> be « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] ».</ins></li><li><ins>If <var>requestedMaxByteLength</var> is present, append [[ArrayBufferMaxByteLength]] to <var>slots</var>.</ins></li><li>Let <var>obj</var> be ?&nbsp;<emu-xref aoid="OrdinaryCreateFromConstructor" id="_ref_0"><a href="https://tc39.es/ecma262/#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(<var>constructor</var>, <emu-val>"%ArrayBuffer.prototype%"</emu-val>, <del>« [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] »</del><ins>_slots</ins>).</li><li>Let <var>block</var> be ?&nbsp;<emu-xref aoid="CreateByteDataBlock" id="_ref_1"><a href="https://tc39.es/ecma262/#sec-createbytedatablock">CreateByteDataBlock</a></emu-xref>(<var>byteLength</var>).</li><li>Set <var>obj</var>.[[ArrayBufferData]] to <var>block</var>.</li><li>Set <var>obj</var>.[[ArrayBufferByteLength]] to <var>byteLength</var>.</li><li><ins>If <var>requestedMaxByteLength</var> is present, then</ins><ol><li><ins>Let <var>maxByteLength</var> be an implementation-defined value that is either = <var>requestedMaxByteLength</var> or both ≥ <var>requestedMaxByteLength</var> and a power of 2.</ins></li><li><ins>NOTE: Implementations may choose to round up the requested maximum byte length, for example, to be on a page boundary.</ins></li><li><ins>If it is not possible to create a <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> <var>block</var> consisting of <var>maxByteLength</var> bytes, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li><ins>NOTE: ResizableArrayBuffers are designed to be implementable with in-place growth. Implementations reserve the right to throw if, for example, virtual memory cannot be reserved up front.</ins></li><li><ins>Set <var>obj</var>.[[ArrayBufferMaxByteLength]] to <var>maxByteLength</var>.</ins></li></ol></li><li>Return <var>obj</var>.</li></ol></emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-arraybufferlength" aoid="ArrayBufferByteLength">
    <h1><span class="secnum">1.2</span> ArrayBufferByteLength ( <var>arrayBuffer</var>, <var>order</var> )</h1>
    <p>The abstract operation ArrayBufferByteLength takes arguments <var>arrayBuffer</var> and <var>order</var> (either <emu-const>SeqCst</emu-const> or <emu-const>Unordered</emu-const>). It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="Type" id="_ref_2"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>arrayBuffer</var>) is Object and <var>arrayBuffer</var> has an [[ArrayBufferData]] internal slot.</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_3"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val> and <var>arrayBuffer</var> has an [[ArrayBufferByteLengthData]] internal slot, then<ol><li>Let <var>bufferByteLengthBlock</var> be <var>O</var>.[[ArrayBufferByteLengthData]].</li><li>Return <emu-xref href="#ℝ"><a href="https://tc39.es/ecma262/#ℝ">ℝ</a></emu-xref>(<emu-xref aoid="GetValueFromBuffer" id="_ref_4"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>bufferByteLengthBlock</var>, 0, <emu-const>Uint64</emu-const>, <emu-val>true</emu-val>, <var>order</var>)).</li></ol></li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="IsDetachedBuffer" id="_ref_5"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>Return <var>arrayBuffer</var>.[[ArrayBufferByteLength]].</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-makeidempotentarraybufferbytelengthgetter" aoid="MakeIdempotentArrayBufferByteLengthGetter">
    <h1><span class="secnum">1.3</span> MakeIdempotentArrayBufferByteLengthGetter ( <var>order</var> )</h1>
    <p>The abstract operation MakeIdempotentArrayBufferByteLengthGetter takes argument <var>order</var> (either <emu-const>SeqCst</emu-const> or <emu-const>Unordered</emu-const>). The returned Abstract Closure helps ensure that there there is a single shared memory read event of the byte length data block in the calling operation. It performs the following steps when called:</p>
    <emu-alg><ol><li>NOTE: The [[ArrayBuffer]] slot is used for editorial clarity only, that a getter should only be used with a single ArrayBuffer.</li><li>Let <var>lengthStorage</var> be { [[ArrayBuffer]]: <emu-const>empty</emu-const>, [[ByteLength]]: <emu-const>empty</emu-const> }.</li><li>Let <var>getter</var> be a new Abstract Closure with parameters (<var>buffer</var>) that captures <var>lengthStorage</var>, <var>buffer</var>, and <var>order</var> and performs the following steps when called:<ol><li>If <var>lengthStorage</var>.[[ByteLength]] is not <emu-const>empty</emu-const>, then<ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>lengthStorage</var>.[[ArrayBuffer]] is <emu-const>empty</emu-const>.</li><li>Set <var>lengthStorage</var>.[[ArrayBuffer]] to <var>buffer</var>.</li><li>Set <var>lengthStorage</var>.[[ByteLength]] to <emu-xref aoid="ArrayBufferByteLength" id="_ref_6"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>buffer</var>, <var>order</var>).</li></ol></li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="SameValue" id="_ref_7"><a href="https://tc39.es/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>lengthStorage</var>.[[ArrayBuffer]], <var>buffer</var>) is <emu-val>true</emu-val>.</li><li>Return <var>lengthStorage</var>.[[ByteLength]].</li></ol></li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-isresizablearraybuffer" aoid="IsResizableArrayBuffer">
    <h1><span class="secnum">1.4</span> IsResizableArrayBuffer ( <var>arrayBuffer</var> )</h1>
    <p>The abstract operation IsResizableArrayBuffer takes argument <var>arrayBuffer</var>. It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="Type" id="_ref_8"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>arrayBuffer</var>) is Object and <var>arrayBuffer</var> has an [[ArrayBufferData]] internal slot.</li><li>If <var>buffer</var> has an [[ArrayBufferMaxByteLength]] internal slot, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-hostresizearraybuffer" aoid="HostResizeArrayBuffer">
    <h1><span class="secnum">1.5</span> HostResizeArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</h1>
    <p>The host-defined abstract operation HostResizeArrayBuffer takes arguments <var>buffer</var> (a ResizableArrayBuffer object) and <var>newByteLength</var>. It gives the host an opportunity to perform implementation-defined resizing of <var>buffer</var>. If the host chooses not to handle resizing of <var>buffer</var>, it may return <emu-const>unhandled</emu-const> for the default behavior.</p>

    <p>The implementation of HostResizeArrayBuffer must conform to the following requirements:</p>
    <ul>
      <li>If the abstract operation completes normally, <var>buffer</var>.[[ArrayBufferByteLength]] is <var>newByteLength</var>.</li>
      <li>The return value is either <emu-const>handled</emu-const> or <emu-const>unhandled</emu-const>.</li>
    </ul>

    <p>The default implementation of HostResizeArrayBuffer is to return <emu-const>unhandled</emu-const>.</p>
  </emu-clause>
  </ins>
</emu-clause>

<ins class="block">
<emu-clause id="sec-resizablearraybuffer-objects">
  <h1><span class="secnum">2</span> ResizableArrayBuffer Objects</h1>

  <emu-clause id="sec-resizablearraybuffer-constructor">
    <h1><span class="secnum">2.1</span> The ResizableArrayBuffer Constructor</h1>
    <p>The ResizableArrayBuffer <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref>:</p>
    <ul>
      <li>is <dfn>%ResizableArrayBuffer%</dfn>.</li>
      <li>is the initial value of the <emu-val>"ResizableArrayBuffer"</emu-val> property of the <emu-xref href="#sec-global-object"><a href="https://tc39.es/ecma262/#sec-global-object">global object</a></emu-xref>.</li>
      <li>creates and initializes a new ResizableArrayBuffer object when called as a <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref>.</li>
      <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
      <li>is designed to be subclassable. It may be used as the value of an <code>extends</code> clause of a class definition. Subclass constructors that intend to inherit the specified ResizableArrayBuffer behaviour must include a <code>super</code> call to the ResizableArrayBuffer <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref> to create and initialize subclass instances with the internal state necessary to support the <code>ResizableArrayBuffer.prototype</code> built-in methods.</li>
    </ul>

    <emu-clause id="sec-resizablearraybuffer-initiallength-maxlength">
      <h1><span class="secnum">2.1.1</span> ResizableArrayBuffer ( <var>initialLength</var>, <var>maxLength</var> )</h1>
      <p>When the <code>ResizableArrayBuffer</code> function is called with arguments <var>initialLength</var> and <var>maxLength</var>, the following steps are taken:</p>
      <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>byteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_9"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>initialLength</var>).</li><li>Let <var>maxByteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_10"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>maxLength</var>).</li><li>If <var>byteLength</var> &gt; <var>maxByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Return ?&nbsp;<emu-xref aoid="AllocateArrayBuffer" id="_ref_11"><a href="#sec-allocatearraybuffer">AllocateArrayBuffer</a></emu-xref>(NewTarget, <var>byteLength</var>, <var>maxByteLength</var>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-resizablearraybuffer-constructor">
    <h1><span class="secnum">2.2</span> Properties of the ResizableArrayBuffer Constructor</h1>
    <p>The ResizableArrayBuffer <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref>:</p>
    <ul>
      <li>has a [[Prototype]] internal slot whose value is <emu-xref href="#sec-properties-of-the-function-prototype-object"><a href="https://tc39.es/ecma262/#sec-properties-of-the-function-prototype-object">%Function.prototype%</a></emu-xref>.</li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-resizablearraybuffer.prototype">
    <h1><span class="secnum">2.3</span> ResizableArrayBuffer.prototype</h1>
    <p>The initial value of <code>ResizableArrayBuffer.prototype</code> is the <emu-xref href="#sec-properties-of-the-resizablearraybuffer-prototype-object" id="_ref_12"><a href="#sec-properties-of-the-resizablearraybuffer-prototype-object">ResizableArrayBuffer prototype object</a></emu-xref>.</p>
    <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }.</p>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-resizablearraybuffer-prototype-object">
    <h1><span class="secnum">2.4</span> Properties of the ResizableArrayBuffer Prototype Object</h1>
    <p>The <dfn>ResizableArrayBuffer prototype object</dfn>:</p>
    <ul>
      <li>is <dfn>%ResizableArrayBuffer.prototype%</dfn>.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>is an ordinary object.</li>
      <li>does not have an [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]], or [[ArrayBufferMaxByteLength]] internal slot.</li>
    </ul>

    <emu-clause id="sec-get-resizablearraybuffer.prototype.bytelength">
      <h1><span class="secnum">2.4.1</span> get ResizableArrayBuffer.prototype.byteLength</h1>
      <p><code>ResizableArrayBuffer.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_13"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_14"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</li><li>NOTE: The <emu-const>SeqCst</emu-const> argument below is ignored for ResizableArrayBuffer.</li><li>Let <var>length</var> be <emu-xref aoid="ArrayBufferByteLength" id="_ref_15"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>O</var>, <emu-const>SeqCst</emu-const>).</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-resizablearraybuffer.prototype.constructor">
      <h1><span class="secnum">2.4.2</span> ResizableArrayBuffer.prototype.constructor</h1>
      <p>The initial value of <code>ResizableArrayBuffer.prototype.constructor</code> is <emu-xref href="#sec-resizablearraybuffer-constructor" id="_ref_16"><a href="#sec-resizablearraybuffer-constructor">%ResizableArrayBuffer%</a></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-get-resizablearraybuffer.prototype.maxbytelength">
      <h1><span class="secnum">2.4.3</span> get ResizableArrayBuffer.prototype.maxByteLength</h1>
      <p><code>ResizableArrayBuffer.prototype.maxByteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_17"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_18"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</li><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferMaxByteLength]].</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-resizablearraybuffer.prototype.resize">
      <h1><span class="secnum">2.4.4</span> ResizableArrayBuffer.prototype.resize ( <var>newLength</var> )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_19"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_20"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_21"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>newByteLength</var> be ?&nbsp;ToIntegerOrInfinity(<var>newLength</var>).</li><li>If <var>newByteLength</var> &lt; 0 or <var>newByteLength</var> &gt; <var>O</var>.[[ArrayBufferMaxByteLength]], throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>hostHandled</var> be ?&nbsp;<emu-xref aoid="HostResizeArrayBuffer" id="_ref_22"><a href="#sec-hostresizearraybuffer">HostResizeArrayBuffer</a></emu-xref>(<var>O</var>, <var>newByteLength</var>).</li><li>If <var>hostHandled</var> is <emu-const>handled</emu-const>, return <emu-val>undefined</emu-val>.</li><li>Let <var>oldBlock</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>newBlock</var> be ?&nbsp;<emu-xref aoid="CreateByteDataBlock" id="_ref_23"><a href="https://tc39.es/ecma262/#sec-createbytedatablock">CreateByteDataBlock</a></emu-xref>(<var>newByteLength</var>).</li><li>Let <var>copyLength</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>newByteLength</var>, <var>O</var>.[[ArrayBufferByteLength]]).</li><li>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_24"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>newBlock</var>, 0, <var>oldBlock</var>, 0, <var>copyLength</var>).</li><li>NOTE: Neither creation of the new <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> nor copying from the old <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> are observable. Implementations reserve the right to implement this method as in-place growth or shrinkage.</li><li>Set <var>O</var>.[[ArrayBufferData]] to <var>newBlock</var>.</li><li>Set <var>O</var>.[[ArrayBufferByteLength]] to <var>newLength</var>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-resizablearraybuffer.prototype.slice">
      <h1><span class="secnum">2.4.5</span> ResizableArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_25"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_26"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>len</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Let <var>relativeStart</var> be ?&nbsp;ToIntegerOrInfinity(<var>start</var>).</li><li>If <var>relativeStart</var> is -∞, let <var>first</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>first</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>first</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;ToIntegerOrInfinity(<var>end</var>).</li><li>If <var>relativeEnd</var> is -∞, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>newLen</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>final</var> - <var>first</var>, 0).</li><li>Let <var>new</var> be ?&nbsp;<emu-xref aoid="Construct" id="_ref_27"><a href="https://tc39.es/ecma262/#sec-construct">Construct</a></emu-xref>(<emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.es/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>, « <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>newLen</var>) »).</li><li>NOTE: This method returns a fixed ArrayBuffer.</li><li>Let <var>fromBlock</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBlock</var> be <var>new</var>.[[ArrayBufferData]].</li><li>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_28"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBlock</var>, 0, <var>fromBlock</var>, <var>first</var>, <var>newLen</var>).</li><li>Return <var>new</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-resizablearraybuffer.prototype.transfer">
      <h1><span class="secnum">2.4.6</span> ResizableArrayBuffer.prototype.transfer ( [ <var>newLength</var> ] )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_29"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_30"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>newLength</var> is not present, let <var>newByteLength</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Else, let <var>newByteLength</var> be ?&nbsp;ToIntegerOrInfinity(<var>newLength</var>).</li><li>Let <var>new</var> be ?&nbsp;<emu-xref aoid="Construct" id="_ref_31"><a href="https://tc39.es/ecma262/#sec-construct">Construct</a></emu-xref>(<emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.es/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>, « <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>newByteLength</var>) »).</li><li>NOTE: This method returns a fixed ArrayBuffer.</li><li>Let <var>copyLength</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>newByteLength</var>, <var>O</var>.[[ArrayBufferByteLength]]).</li><li>Let <var>fromBlock</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBlock</var> be <var>new</var>.[[ArrayBufferData]].</li><li>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_32"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBlock</var>, 0, <var>fromBlock</var>, 0, <var>copyLength</var>).</li><li>NOTE: Neither creation of the new <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> nor copying from the old <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> are observable. Implementations reserve the right to implement this method as a zero-copy move or a <code>realloc</code>.</li><li>Perform !&nbsp;<emu-xref aoid="DetachArrayBuffer" id="_ref_33"><a href="https://tc39.es/ecma262/#sec-detacharraybuffer">DetachArrayBuffer</a></emu-xref>(<var>O</var>).</li><li>Return <var>new</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-resizablearraybuffer.prototype-@@tostringtag">
      <h1><span class="secnum">2.4.7</span> ResizableArrayBuffer.prototype [ @@toStringTag ]</h1>
      <p>The initial value of the @@toStringTag property is the String value <emu-val>"ResizableArrayBuffer"</emu-val>.</p>
      <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>
</ins>

<emu-clause id="sec-abstract-operations-for-sharedarraybuffer-objects-mods">
  <h1><span class="secnum">3</span> Modifications to Abstract Operations for SharedArrayBuffer Objects</h1>

  <emu-clause id="sec-allocatesharedarraybuffer" aoid="AllocateSharedArrayBuffer">
    <h1><span class="secnum">3.1</span> AllocateSharedArrayBuffer ( <var>constructor</var>, <var>byteLength</var><ins>[ , <var>requestedMaxByteLength</var> ]</ins> )</h1>
    <p>The abstract operation AllocateSharedArrayBuffer takes arguments <var>constructor</var><del> and</del><ins>,</ins> <var>byteLength</var><ins>, and <var>requestedMaxByteLength</var></ins>. It is used to create a SharedArrayBuffer object. It performs the following steps when called:</p>
    <emu-alg><ol><li><ins>Let <var>slots</var> be « [[ArrayBufferData]] ».</ins></li><li><ins>If <var>requestedMaxByteLength</var> is present, then:</ins></li><li><ins>Append [[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to <var>slots</var>.</ins><ol><li><ins>Let <var>maxByteLength</var> be an implementation-defined value that is either = <var>requestedMaxByteLength</var> or both ≥ <var>requestedMaxByteLength</var> and a power of 2.</ins></li><li><ins>NOTE: Implementations may choose to round up the requested maximum byte length, for example, to be on a page boundary.</ins></li></ol></li><li><ins>Else, append [[ArrayBufferByteLength]] to <var>slots</var>.</ins></li><li>Let <var>obj</var> be ?&nbsp;<emu-xref aoid="OrdinaryCreateFromConstructor" id="_ref_34"><a href="https://tc39.es/ecma262/#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(<var>constructor</var>, <emu-val>"%SharedArrayBuffer.prototype%"</emu-val>, <del>« [[ArrayBufferData]], [[ArrayBufferByteLength]] »</del><ins><var>slots</var></ins>).</li><li><ins><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>byteLength</var> ≤ <var>maxByteLength</var>.</ins></li><li><ins>If <var>maxByteLength</var> is present, then let <var>allocLength</var> be <var>byteLength</var>.</ins></li><li><ins>Else, let <var>allocLength</var> be <var>maxByteLength</var></ins></li><li>Let <var>block</var> be ?&nbsp;<emu-xref aoid="CreateSharedByteDataBlock" id="_ref_35"><a href="https://tc39.es/ecma262/#sec-createsharedbytedatablock">CreateSharedByteDataBlock</a></emu-xref>(<del><var>byteLength</var></del><ins><var>allocLength</var></ins>).</li><li><ins>NOTE: GrowableSharedArrayBuffers must be implemented as in-place growable. Creation of a <var>maxByteLength</var> sized <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> is a specification mechanism. It may be implemented as committing a <var>byteLength</var> sized buffer while reserving <var>maxByteLength</var> in virtual memory.</ins></li><li>Set <var>obj</var>.[[ArrayBufferData]] to <var>block</var>.</li><li><ins>If <var>maxByteLength</var> is present, then</ins><ol><li><ins>Let <var>byteLengthBlock</var> be ?&nbsp;<emu-xref aoid="CreateSharedByteDataBlock" id="_ref_36"><a href="https://tc39.es/ecma262/#sec-createsharedbytedatablock">CreateSharedByteDataBlock</a></emu-xref>(4).</ins></li><li><ins>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_37"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>byteLengthBlock</var>, 0, <emu-const>Uint64</emu-const>, <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>byteLength</var>), <emu-val>true</emu-val>, <emu-const>SeqCst</emu-const>).</ins></li><li><ins>Set <var>obj</var>.[[ArrayBufferByteLengthData]] to <var>byteLengthBlock</var>.</ins></li><li><ins>Set <var>obj</var>.[[ArrayBufferMaxByteLength]] to <var>maxByteLength</var>.</ins></li></ol></li><li><ins>Else,</ins><ol><li>Set <var>obj</var>.[[ArrayBufferByteLength]] to <var>byteLength</var>.</li></ol></li><li>Return <var>obj</var>.</li></ol></emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-hostgrowsharedarraybuffer" aoid="HostGrowSharedArrayBuffer">
    <h1><span class="secnum">3.2</span> HostGrowSharedArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</h1>
    <p>The host-defined abstract operation HostGrowSharedArrayBuffer takes arguments <var>buffer</var> (a GrowableSharedArrayBuffer object) and <var>newByteLength</var>. It gives the host an opportunity to perform implementation-defined growing of <var>buffer</var>. If the host chooses not to handle resizing of <var>buffer</var>, it may return <emu-const>unhandled</emu-const> for the default behavior.</p>

    <p>The implementation of HostGrowSharedArrayBuffer must conform to the following requirements:</p>
    <ul>
       <li>If the abstract operation completes normally, <var>buffer</var>.[[ArrayBufferByteLength]] is <var>newByteLength</var>.</li>
      <li>The return value is either <emu-const>handled</emu-const> or <emu-const>unhandled</emu-const>.</li>
    </ul>

    <p>The default implementation of HostGrowSharedArrayBuffer is to return <emu-const>unhandled</emu-const>.</p>
  </emu-clause>
  </ins>
</emu-clause>

<ins class="block">
<emu-clause id="sec-growablesharedarraybuffer-objects">
  <h1><span class="secnum">4</span> GrowableSharedArrayBuffer Objects</h1>

  <emu-clause id="sec-growablesharedarraybuffer-constructor">
    <h1><span class="secnum">4.1</span> The GrowableSharedArrayBuffer Constructor</h1>
    <p>The GrowableSharedArrayBuffer <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref>:</p>
    <ul>
      <li>is <dfn>%GrowableSharedArrayBuffer%</dfn>.</li>
      <li>is the initial value of the <emu-val>"GrowableSharedArrayBuffer"</emu-val> property of the <emu-xref href="#sec-global-object"><a href="https://tc39.es/ecma262/#sec-global-object">global object</a></emu-xref>.</li>
      <li>creates and initializes a new GrowableSharedArrayBuffer object when called as a <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref>.</li>
      <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
      <li>is designed to be subclassable. It may be used as the value of an <code>extends</code> clause of a class definition. Subclass constructors that intend to inherit the specified GrowableSharedArrayBuffer behaviour must include a <code>super</code> call to the GrowableSharedArrayBuffer <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref> to create and initialize subclass instances with the internal state necessary to support the <code>GrowableSharedArrayBuffer.prototype</code> built-in methods.</li>
    </ul>

    <emu-clause id="sec-growablesharedarraybuffere-initiallength-maxlength">
      <h1><span class="secnum">4.1.1</span> GrowableSharedArrayBuffer ( <var>initialLength</var>, <var>maxLength</var> )</h1>
      <p>When the <code>GrowableSharedArrayBuffer</code> function is called with arguments <var>initialLength</var> and <var>maxLength</var>, the following steps are taken:</p>
      <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>byteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_38"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>initialLength</var>).</li><li>Let <var>maxByteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_39"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>maxLength</var>).</li><li>If <var>byteLength</var> &gt; <var>maxByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Return ?&nbsp;<emu-xref aoid="AllocateSharedArrayBuffer" id="_ref_40"><a href="#sec-allocatesharedarraybuffer">AllocateSharedArrayBuffer</a></emu-xref>(NewTarget, <var>byteLength</var>, <var>maxByteLength</var>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-growablesharedarraybuffer-constructor">
    <h1><span class="secnum">4.2</span> Properties of the GrowableSharedArrayBuffer Constructor</h1>
    <p>The GrowableSharedArrayBuffer <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref> has a [[Prototype]] internal slot whose value is <emu-xref href="#sec-properties-of-the-function-prototype-object"><a href="https://tc39.es/ecma262/#sec-properties-of-the-function-prototype-object">%Function.prototype%</a></emu-xref>.</p>
  </emu-clause>

  <emu-clause id="sec-growablesharedarraybuffer.prototype">
    <h1><span class="secnum">4.3</span> GrowableSharedArrayBuffer.prototype</h1>
    <p>The initial value of <code>GrowableSharedArrayBuffer.prototype</code> is the <emu-xref href="#sec-properties-of-the-growablesharedarraybuffer-prototype-object" id="_ref_41"><a href="#sec-properties-of-the-growablesharedarraybuffer-prototype-object">GrowableSharedArrayBuffer prototype object</a></emu-xref>.</p>
    <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }.</p>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-growablesharedarraybuffer-prototype-object">
    <h1><span class="secnum">4.4</span> Properties of the GrowableSharedArrayBuffer Prototype Object</h1>
    <p>The <dfn>GrowableSharedArrayBuffer prototype object</dfn>:</p>
    <ul>
      <li>is <dfn>%GrowableSharedArrayBuffer.prototype%</dfn>.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>is an ordinary object.</li>
      <li>does not have an [[ArrayBufferData]], [[ArrayBufferByteLengthData]], or [[ArrayBufferMaxByteLength]] internal slot.</li>
    </ul>

    <emu-clause id="sec-get-growablesharedarraybuffer.prototype.bytelength">
      <h1><span class="secnum">4.4.1</span> get GrowableSharedArrayBuffer.prototype.byteLength</h1>
      <p><code>GrowableSharedArrayBuffer.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_42"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_43"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>length</var> be <emu-xref aoid="ArrayBufferByteLength" id="_ref_44"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>O</var>, <emu-const>SeqCst</emu-const>).</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-growablesharedarraybuffer.prototype.constructor">
      <h1><span class="secnum">4.4.2</span> GrowableSharedArrayBuffer.prototype.constructor</h1>
      <p>The initial value of <code>GrowableSharedArrayBuffer.prototype.constructor</code> is <emu-xref href="#sec-growablesharedarraybuffer-constructor" id="_ref_45"><a href="#sec-growablesharedarraybuffer-constructor">%GrowableSharedArrayBuffer%</a></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-get-growablesharedarraybuffer.prototype.maxbytelength">
      <h1><span class="secnum">4.4.3</span> get GrowableSharedArrayBuffer.prototype.maxByteLength</h1>
      <p><code>GrowableSharedArrayBuffer.prototype.maxByteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_46"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_47"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>O</var>.[[ArrayBufferMaxByteLength]]).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-growablesharedarraybuffer.prototype.grow">
      <h1><span class="secnum">4.4.4</span> GrowableSharedArrayBuffer.prototype.grow ( <var>newLength</var> )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_48"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_49"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>newByteLength</var> to ?&nbsp;ToIntegerOrInfinity(<var>newLength</var>).</li><li>If <var>newByteLength</var> &lt; <var>currentByteLength</var> or <var>newByteLength</var> &gt; <var>O</var>.[[ArrayBufferMaxByteLength]], throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>hostHandled</var> be ?&nbsp;<emu-xref aoid="HostGrowSharedArrayBuffer" id="_ref_50"><a href="#sec-hostgrowsharedarraybuffer">HostGrowSharedArrayBuffer</a></emu-xref>(<var>O</var>, <var>newByteLength</var>).</li><li>If <var>hostHandled</var> is <emu-const>handled</emu-const>, return <emu-val>undefined</emu-val>.</li><li>Let <var>currentByteLength</var> be <emu-xref aoid="ArrayBufferByteLength" id="_ref_51"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>O</var>, <emu-const>SeqCst</emu-const>).</li><li>If <var>newByteLength</var> ≠ <var>currentByteLength</var>, then<ol><li>Note: Resizes to the same length explicitly do nothing to avoid gratuitous synchronization.</li><li>Let <var>byteLengthBlock</var> be <var>O</var>.[[ArrayBufferByteLengthData]].</li><li>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_52"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>byteLengthBlock</var>, 0, <emu-const>Uint64</emu-const>, <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>newByteLength</var>), <emu-val>true</emu-val>, <emu-const>SeqCst</emu-const>).</li></ol></li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-growablesharedarraybuffer.prototype.slice">
      <h1><span class="secnum">4.4.5</span> GrowableSharedArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_53"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_54"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>len</var> be <emu-xref aoid="ArrayBufferByteLength" id="_ref_55"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>O</var>, <emu-const>SeqCst</emu-const>).</li><li>Let <var>relativeStart</var> be ?&nbsp;ToIntegerOrInfinity(<var>start</var>).</li><li>If <var>relativeStart</var> is -∞, let <var>first</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>first</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>first</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;ToIntegerOrInfinity(<var>end</var>).</li><li>If <var>relativeEnd</var> is -∞, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>newLen</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>final</var> - <var>first</var>, 0).</li><li>Let <var>new</var> be ?&nbsp;<emu-xref aoid="Construct" id="_ref_56"><a href="https://tc39.es/ecma262/#sec-construct">Construct</a></emu-xref>(<emu-xref href="#sec-sharedarraybuffer-constructor"><a href="https://tc39.es/ecma262/#sec-sharedarraybuffer-constructor">%SharedArrayBuffer%</a></emu-xref>, « <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>newLen</var>) »).</li><li>NOTE: This method returns a fixed SharedArrayBuffer.</li><li>Let <var>fromBlock</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBlock</var> be <var>new</var>.[[ArrayBufferData]].</li><li>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_57"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBlock</var>, 0, <var>fromBlock</var>, <var>first</var>, <var>newLen</var>).</li><li>Return <var>new</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-growablesharedarraybuffer.prototype.toString">
      <h1><span class="secnum">4.4.6</span> GrowableSharedArrayBuffer.prototype [ @@toStringTag ]</h1>
      <p>The initial value of the @@toStringTag property is the String value <emu-val>"GrowableSharedArrayBuffer"</emu-val>.</p>
      <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>
</ins>

<emu-clause id="sec-properties-of-the-arraybuffer-prototype-object-mods">
  <h1><span class="secnum">5</span> Modifications to Properties of the ArrayBuffer Prototype Object</h1>

  <emu-clause id="sec-get-arraybuffer.prototype.bytelength">
    <h1><span class="secnum">5.1</span> get ArrayBuffer.prototype.byteLength</h1>
    <p><code>ArrayBuffer.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
    <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_58"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_59"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>If <emu-xref aoid="IsResizableArrayBuffer" id="_ref_60"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_61"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</li><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-arraybuffer.prototype.slice">
    <h1><span class="secnum">5.2</span> ArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</h1>
    <p>The following steps are taken:</p>
    <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_62"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_63"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_64"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>len</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Let <var>relativeStart</var> be ?&nbsp;ToIntegerOrInfinity(<var>start</var>).</li><li>If <var>relativeStart</var> is -∞, let <var>first</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>first</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>first</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;ToIntegerOrInfinity(<var>end</var>).</li><li>If <var>relativeEnd</var> is -∞, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>newLen</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>final</var> - <var>first</var>, 0).</li><li>Let <var>ctor</var> be ?&nbsp;<emu-xref aoid="SpeciesConstructor" id="_ref_65"><a href="https://tc39.es/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>O</var>, <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.es/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li><li>Let <var>new</var> be ?&nbsp;<emu-xref aoid="Construct" id="_ref_66"><a href="https://tc39.es/ecma262/#sec-construct">Construct</a></emu-xref>(<var>ctor</var>, « <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>newLen</var>) »).</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_67"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>new</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_68"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>new</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>If <emu-xref aoid="IsResizableArrayBuffer" id="_ref_69"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>new</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_70"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>new</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="SameValue" id="_ref_71"><a href="https://tc39.es/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>new</var>, <var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>new</var>.[[ArrayBufferByteLength]] &lt; <var>newLen</var>, throw a <emu-val>TypeError</emu-val> exception.</li><li>NOTE: Side-effects of the above steps may have detached <var>O</var>.</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_72"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>fromBuf</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBuf</var> be <var>new</var>.[[ArrayBufferData]].</li><li>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_73"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBuf</var>, 0, <var>fromBuf</var>, <var>first</var>, <var>newLen</var>).</li><li>Return <var>new</var>.</li></ol></emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-arraybuffer.prototype.transfer">
    <h1><span class="secnum">5.3</span> ArrayBuffer.prototype.transfer ( [ <var>newLength</var> ] )</h1>
    <p>The following steps are taken:</p>
    <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_74"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_75"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_76"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>newLength</var> is not present, let <var>newByteLength</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Else, let <var>newByteLength</var> be ?&nbsp;ToIntegerOrInfinity(<var>newLength</var>).</li><li>Let <var>ctor</var> be ?&nbsp;<emu-xref aoid="SpeciesConstructor" id="_ref_77"><a href="https://tc39.es/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>O</var>, <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.es/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li><li>Let <var>new</var> be ?&nbsp;<emu-xref aoid="Construct" id="_ref_78"><a href="https://tc39.es/ecma262/#sec-construct">Construct</a></emu-xref>(<var>ctor</var>, « <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>newLen</var>) »).</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_79"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>new</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_80"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>new</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsResizableArrayBuffer" id="_ref_81"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>new</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_82"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>new</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="SameValue" id="_ref_83"><a href="https://tc39.es/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>new</var>, <var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>copyLength</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>newByteLength</var>, <var>O</var>.[[ArrayBufferByteLength]]).</li><li>Let <var>fromBlock</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBlock</var> be <var>new</var>.[[ArrayBufferData]].</li><li>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_84"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBlock</var>, 0, <var>fromBlock</var>, 0, <var>copyLength</var>).</li><li>NOTE: Neither creation of the new <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> nor copying from the old <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> are observable. Implementations reserve the right to implement this method as a zero-copy move or a <code>realloc</code>.</li><li>Perform !&nbsp;<emu-xref aoid="DetachArrayBuffer" id="_ref_85"><a href="https://tc39.es/ecma262/#sec-detacharraybuffer">DetachArrayBuffer</a></emu-xref>(<var>O</var>).</li><li>Return <var>new</var>.</li></ol></emu-alg>
  </emu-clause>
  </ins>
</emu-clause>

<emu-clause id="sec-properties-of-the-sharedarraybuffer-prototype-object-mods">
  <h1><span class="secnum">6</span> Modifications to Properties of the SharedArrayBuffer Prototype Object</h1>

  <emu-clause id="sec-get-sharedarraybuffer.prototype.bytelength">
    <h1><span class="secnum">6.1</span> get SharedArrayBuffer.prototype.byteLength</h1>
    <p><code>SharedArrayBuffer.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
    <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_86"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li><ins>If <emu-xref aoid="IsResizableArrayBuffer" id="_ref_87"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_88"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer.prototype.slice">
    <h1><span class="secnum">6.2</span> SharedArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</h1>
    <p>The following steps are taken:</p>
    <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_89"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_90"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>len</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Let <var>relativeStart</var> be ?&nbsp;ToIntegerOrInfinity(<var>start</var>).</li><li>If <var>relativeStart</var> is -∞, let <var>first</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>first</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>first</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;ToIntegerOrInfinity(<var>end</var>).</li><li>If <var>relativeEnd</var> is -∞, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>newLen</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>final</var> - <var>first</var>, 0).</li><li>Let <var>ctor</var> be ?&nbsp;<emu-xref aoid="SpeciesConstructor" id="_ref_91"><a href="https://tc39.es/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>O</var>, <emu-xref href="#sec-sharedarraybuffer-constructor"><a href="https://tc39.es/ecma262/#sec-sharedarraybuffer-constructor">%SharedArrayBuffer%</a></emu-xref>).</li><li>Let <var>new</var> be ?&nbsp;<emu-xref aoid="Construct" id="_ref_92"><a href="https://tc39.es/ecma262/#sec-construct">Construct</a></emu-xref>(<var>ctor</var>, « <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>newLen</var>) »).</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_93"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>new</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_94"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>new</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>If <emu-xref aoid="IsResizableArrayBuffer" id="_ref_95"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>new</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>If <var>new</var>.[[ArrayBufferData]] and <var>O</var>.[[ArrayBufferData]] are the same <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> values, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>new</var>.[[ArrayBufferByteLength]] &lt; <var>newLen</var>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>fromBuf</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBuf</var> be <var>new</var>.[[ArrayBufferData]].</li><li>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_96"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBuf</var>, 0, <var>fromBuf</var>, <var>first</var>, <var>newLen</var>).</li><li>Return <var>new</var>.</li></ol></emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-integer-indexed-exotic-objects-mods">
  <h1><span class="secnum">7</span> Modifications to Integer-Indexed Exotic Objects</h1>

  <emu-clause id="sec-integer-indexed-exotic-objects-ownpropertykeys">
    <h1><span class="secnum">7.1</span> [[OwnPropertyKeys]] ( )</h1>
    <p>When the [[OwnPropertyKeys]] internal method of an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref> <var>O</var> is called, the following steps are taken:</p>
    <emu-alg><ol><li>Let <var>keys</var> be a new empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_97"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><del>Let <var>len</var> be <var>O</var>.[[ArrayLength]]</del>.</li><li><ins>Let <var>len</var> be <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_98"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins></li><li>For each <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> <var>i</var> starting with 0 such that <var>i</var> &lt; <var>len</var>, in ascending order, do<ol><li>Add !&nbsp;<emu-xref aoid="ToString" id="_ref_99"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<var>i</var>) as the last element of <var>keys</var>.</li></ol></li><li>For each own property key <var>P</var> of <var>O</var> such that <emu-xref aoid="Type" id="_ref_100"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>P</var>) is String and <var>P</var> is not an <emu-xref href="#integer-index"><a href="https://tc39.es/ecma262/#integer-index">integer index</a></emu-xref>, in ascending chronological order of property creation, do<ol><li>Add <var>P</var> as the last element of <var>keys</var>.</li></ol></li><li>For each own property key <var>P</var> of <var>O</var> such that <emu-xref aoid="Type" id="_ref_101"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>P</var>) is Symbol, in ascending chronological order of property creation, do<ol><li>Add <var>P</var> as the last element of <var>keys</var>.</li></ol></li><li>Return <var>keys</var>.</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-isvalidintegerindex" aoid="IsValidIntegerIndex">
    <h1><span class="secnum">7.2</span> IsValidIntegerIndex ( <var>O</var>, <var>index</var> )</h1>
    <p>The abstract operation IsValidIntegerIndex takes arguments <var>O</var>, <var>getBufferByteLength</var>, and <var>index</var>. It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="Type" id="_ref_102"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>index</var>) is Number.</li><li>If !&nbsp;<emu-xref aoid="IsInteger" id="_ref_103"><a href="https://tc39.es/ecma262/#sec-isinteger">IsInteger</a></emu-xref>(<var>index</var>) is <emu-val>false</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>index</var> is <emu-val>-0</emu-val><sub>𝔽</sub>, return <emu-val>false</emu-val>.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_104"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>O</var>'s backing buffer is a GrowableSharedArrayBuffer.</ins></li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_105"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, return <emu-val>false</emu-val>.</ins></li><li>If <emu-xref href="#ℝ"><a href="https://tc39.es/ecma262/#ℝ">ℝ</a></emu-xref>(<var>index</var>) &lt; 0 or <emu-xref href="#ℝ"><a href="https://tc39.es/ecma262/#ℝ">ℝ</a></emu-xref>(<var>index</var>) ≥ <del><var>O</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_106"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>, return <emu-val>false</emu-val>.</li><li>Return <emu-val>true</emu-val>.</li></ol></emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-integerindexedobjectbytelength" aoid="IntegerIndexedObjectByteLength">
    <h1><span class="secnum">7.3</span> IntegerIndexedObjectByteLength ( <var>O</var>, <var>getBufferByteLength</var> )</h1>
    <p>The abstract operation IntegerIndexedObjectByteLength takes arguments <var>O</var> and <var>getBufferByteLength</var>. It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li>Let <var>length</var> be <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_107"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</li><li>If <var>length</var> = 0, return 0.</li><li>If <var>O</var>.[[ByteLength]] is not <emu-const>auto</emu-const>, return <var>O</var>.[[ByteLength]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>O</var>.[[TypedArrayName]].</li><li>Return <var>length</var> × <var>elementSize</var>.</li></ol></emu-alg>
    </emu-clause>

  <emu-clause id="sec-integerindexedobjectlength" aoid="IntegerIndexedObjectLength">
    <h1><span class="secnum">7.4</span> IntegerIndexedObjectLength ( <var>O</var>, <var>getBufferByteLength</var> )</h1>
    <p>The abstract operation IntegerIndexedObjectLength takes arguments <var>O</var> and <var>getBufferByteLength</var>. It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_108"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, return 0.</li><li>If <var>O</var>.[[ArrayLength]] is not <emu-const>auto</emu-const>, return <var>O</var>.[[ArrayLength]].</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>Let <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="IsResizableArrayBuffer" id="_ref_109"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>.</li><li>Let <var>byteOffset</var> be <var>O</var>.[[ByteOffset]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>O</var>.[[TypedArrayName]].</li><li>Let <var>length</var> be <emu-xref aoid="floor"><a href="https://tc39.es/ecma262/#eqn-floor">floor</a></emu-xref>((<var>bufferByteLength</var> - <var>byteOffset</var>) / <var>elementSize</var>).</li><li>Return <var>length</var>.</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-isintegerindexedobjectoutofbounds" aoid="IsIntegerIndexedObjectOutOfBounds">
    <h1><span class="secnum">7.5</span> IsIntegerIndexedObjectOutOfBounds ( <var>O</var>, <var>getBufferByteLength</var> )</h1>
    <p>The abstract operation IsIntegerIndexedObjectOutOfBounds takes arguments <var>O</var> and <var>getBufferByteLength</var>. It checks if any part of the underlying viewed buffer is out of bounds. It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>Let <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</li><li>Let <var>byteOffsetStart</var> be <var>O</var>.[[ByteOffset]].</li><li>If <var>O</var>.[[ArrayLength]] is <emu-const>auto</emu-const>, then<ol><li>Let <var>byteOffsetEnd</var> be <var>bufferByteLength</var>.</li></ol></li><li>Else,<ol><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>O</var>.[[TypedArrayName]].</li><li>Let <var>byteOffsetEnd</var> be <var>O</var>.[[ArrayLength]] × <var>elementSize</var>.</li></ol></li><li>If <var>byteOffsetStart</var> ≥ <var>bufferByteLength</var> or <var>byteOffsetEnd</var> ≥ <var>bufferByteLength</var>, then return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
  </emu-clause>
  </ins>
</emu-clause>

<emu-clause id="sec-typedarray-objects-mods">
  <h1><span class="secnum">8</span> Modifications to TypedArray Objects</h1>

  <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object-mods">
    <h1><span class="secnum">8.1</span> Modifications to Properties of the %TypedArray.prototype% Object</h1>

    <emu-clause id="sec-validatetypedarray" aoid="ValidateTypedArray">
      <h1><span class="secnum">8.1.1</span> Runtime Semantics: ValidateTypedArray ( <var>O</var> )</h1>
      <p>The abstract operation ValidateTypedArray takes argument <var>O</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_110"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_111"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_112"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_113"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Return <var>buffer</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.bytelength">
      <h1><span class="secnum">8.1.2</span> get %TypedArray%.prototype.byteLength</h1>
      <p><emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_114"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_115"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_116"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>size</var> be <del><var>O</var>.[[ByteLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectByteLength" id="_ref_117"><a href="#sec-integerindexedobjectbytelength">IntegerIndexedObjectByteLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>size</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.byteoffset">
      <h1><span class="secnum">8.1.3</span> get %TypedArray%.prototype.byteOffset</h1>
      <p><emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.byteOffset</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_118"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_119"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_120"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_121"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</ins></li><li>Let <var>offset</var> be <var>O</var>.[[ByteOffset]].</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>offset</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.length">
      <h1><span class="secnum">8.1.4</span> get %TypedArray%.prototype.length</h1>
      <p><emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.length</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_122"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_123"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</li><li>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_124"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</li><li>Let <var>length</var> be <del><var>O</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_125"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
      <p>This function is not generic. The <emu-val>this</emu-val> value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-settypedarrayfromtypedarray" aoid="SetTypedArrayFromTypedArray" oldids="sec-%typedarray%.prototype.set-typedarray-offset">
      <span id="sec-%typedarray%.prototype.set-typedarray-offset"></span><h1><span class="secnum">8.1.5</span> SetTypedArrayFromTypedArray ( <var>target</var>, <var>targetOffset</var>, <var>source</var> )</h1>
      <p>The abstract operation SetTypedArrayFromTypedArray takes arguments <var>target</var> (a TypedArray object), <var>targetOffset</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> or +∞), and <var>source</var> (a TypedArray object). It sets multiple values in <var>target</var>, starting at index <var>targetOffset</var>, reading the values from <var>source</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>source</var> is an Object that has a [[TypedArrayName]] internal slot.</li><li>Let <var>targetBuffer</var> be <var>target</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_126"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>targetBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getSrcBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_127"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>targetLength</var> be <del><var>target</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_128"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>target</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Let <var>srcBuffer</var> be <var>source</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_129"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>srcBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_130"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>target</var>, getSrcBufferByteLength_) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>targetName</var> be the String value of <var>target</var>.[[TypedArrayName]].</li><li>Let <var>targetType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetElementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetByteOffset</var> be <var>target</var>.[[ByteOffset]].</li><li>Let <var>srcName</var> be the String value of <var>source</var>.[[TypedArrayName]].</li><li>Let <var>srcType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcElementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcLength</var> be <var>source</var>.[[ArrayLength]].</li><li>Let <var>srcByteOffset</var> be <var>source</var>.[[ByteOffset]].</li><li>If <var>targetOffset</var> is +∞, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>srcLength</var> + <var>targetOffset</var> &gt; <var>targetLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>target</var>.[[ContentType]] ≠ <var>source</var>.[[ContentType]], throw a <emu-val>TypeError</emu-val> exception.</li><li>If both <emu-xref aoid="IsSharedArrayBuffer" id="_ref_131"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>srcBuffer</var>) and <emu-xref aoid="IsSharedArrayBuffer" id="_ref_132"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>targetBuffer</var>) are <emu-val>true</emu-val>, then<ol><li>If <var>srcBuffer</var>.[[ArrayBufferData]] and <var>targetBuffer</var>.[[ArrayBufferData]] are the same <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> values, let <var>same</var> be <emu-val>true</emu-val>; else let <var>same</var> be <emu-val>false</emu-val>.</li></ol></li><li>Else, let <var>same</var> be <emu-xref aoid="SameValue" id="_ref_133"><a href="https://tc39.es/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcBuffer</var>, <var>targetBuffer</var>).</li><li>If <var>same</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>srcByteLength</var> be <del><var>source</var>.[[ByteLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectByteLength" id="_ref_134"><a href="#sec-integerindexedobjectbytelength">IntegerIndexedObjectByteLength</a></emu-xref>(<var>source</var>, <var>getSrcBufferByteLength</var>)</ins>.</li><li>Set <var>srcBuffer</var> to ?&nbsp;<emu-xref aoid="CloneArrayBuffer" id="_ref_135"><a href="https://tc39.es/ecma262/#sec-clonearraybuffer">CloneArrayBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteOffset</var>, <var>srcByteLength</var>, <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.es/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li><li>NOTE: <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.es/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref> is used to clone <var>srcBuffer</var> because is it known to not have any observable side-effects.</li><li>Let <var>srcByteIndex</var> be 0.</li></ol></li><li>Else, let <var>srcByteIndex</var> be <var>srcByteOffset</var>.</li><li>Let <var>targetByteIndex</var> be <var>targetOffset</var> × <var>targetElementSize</var> + <var>targetByteOffset</var>.</li><li>Let <var>limit</var> be <var>targetByteIndex</var> + <var>targetElementSize</var> × <var>srcLength</var>.</li><li>If <var>srcType</var> is the same as <var>targetType</var>, then<ol><li>NOTE: If <var>srcType</var> and <var>targetType</var> are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.</li><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var>,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer" id="_ref_136"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <emu-const>Uint8</emu-const>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_137"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <emu-const>Uint8</emu-const>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + 1.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + 1.</li></ol></li></ol></li><li>Else,<ol><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var>,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer" id="_ref_138"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <var>srcType</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_139"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <var>targetType</var>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + <var>srcElementSize</var>.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + <var>targetElementSize</var>.</li></ol></li></ol></li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-constructors-mods">
    <h1><span class="secnum">8.2</span> Modifications to the <var>TypedArray</var> Constructors</h1>

    <emu-clause id="sec-initializetypedarrayfromtypedarray" aoid="InitializeTypedArrayFromTypedArray" oldids="sec-typedarray-typedarray">
      <span id="sec-typedarray-typedarray"></span><h1><span class="secnum">8.2.1</span> InitializeTypedArrayFromTypedArray ( <var>O</var>, <var>srcArray</var> )</h1>
      <p>The abstract operation InitializeTypedArrayFromTypedArray takes arguments <var>O</var> (a TypedArray object) and <var>srcArray</var> (a TypedArray object). It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an Object that has a [[TypedArrayName]] internal slot.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>srcArray</var> is an Object that has a [[TypedArrayName]] internal slot.</li><li>Let <var>srcData</var> be <var>srcArray</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_140"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>srcData</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>constructorName</var> be the String value of <var>O</var>.[[TypedArrayName]].</li><li>Let <var>elementType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>constructorName</var>.</li><li><ins>Let <var>getSrcBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_141"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>elementLength</var> be <del><var>srcArray</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_142"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>srcArray</var>, <var>getSrcBufferByteLength</var>)</ins>.</li><li>Let <var>srcName</var> be the String value of <var>srcArray</var>.[[TypedArrayName]].</li><li>Let <var>srcType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcElementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcByteOffset</var> be <var>srcArray</var>.[[ByteOffset]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>constructorName</var>.</li><li>Let <var>byteLength</var> be <var>elementSize</var> × <var>elementLength</var>.</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_143"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>srcData</var>) is <emu-val>false</emu-val>, then<ol><li>Let <var>bufferConstructor</var> be ?&nbsp;<emu-xref aoid="SpeciesConstructor" id="_ref_144"><a href="https://tc39.es/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>srcData</var>, <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.es/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li></ol></li><li>Else,<ol><li>Let <var>bufferConstructor</var> be <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.es/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>.</li></ol></li><li>If <var>elementType</var> is the same as <var>srcType</var>, then<ol><li>Let <var>data</var> be ?&nbsp;<emu-xref aoid="CloneArrayBuffer" id="_ref_145"><a href="https://tc39.es/ecma262/#sec-clonearraybuffer">CloneArrayBuffer</a></emu-xref>(<var>srcData</var>, <var>srcByteOffset</var>, <var>byteLength</var>, <var>bufferConstructor</var>).</li></ol></li><li>Else,<ol><li>Let <var>data</var> be ?&nbsp;<emu-xref aoid="AllocateArrayBuffer" id="_ref_146"><a href="#sec-allocatearraybuffer">AllocateArrayBuffer</a></emu-xref>(<var>bufferConstructor</var>, <var>byteLength</var>).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_147"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>srcData</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_148"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>srcArray</var>, <var>getSrcBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>If <var>srcArray</var>.[[ContentType]] ≠ <var>O</var>.[[ContentType]], throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>srcByteIndex</var> be <var>srcByteOffset</var>.</li><li>Let <var>targetByteIndex</var> be 0.</li><li>Let <var>count</var> be <var>elementLength</var>.</li><li>Repeat, while <var>count</var> &gt; 0,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer" id="_ref_149"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcData</var>, <var>srcByteIndex</var>, <var>srcType</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_150"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>data</var>, <var>targetByteIndex</var>, <var>elementType</var>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + <var>srcElementSize</var>.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + <var>elementSize</var>.</li><li>Set <var>count</var> to <var>count</var> - 1.</li></ol></li></ol></li><li>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>data</var>.</li><li>Set <var>O</var>.[[ByteLength]] to <var>byteLength</var>.</li><li>Set <var>O</var>.[[ByteOffset]] to 0.</li><li>Set <var>O</var>.[[ArrayLength]] to <var>elementLength</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-initializetypedarrayfromarraybuffer" aoid="InitializeTypedArrayFromArrayBuffer" oldids="sec-typedarray-buffer-byteoffset-length">
      <span id="sec-typedarray-buffer-byteoffset-length"></span><h1><span class="secnum">8.2.2</span> InitializeTypedArrayFromArrayBuffer ( <var>O</var>, <var>buffer</var>, <var>byteOffset</var>, <var>length</var> )</h1>
      <p>The abstract operation InitializeTypedArrayFromArrayBuffer takes arguments <var>O</var> (a TypedArray object), <var>buffer</var> (an ArrayBuffer object), <var>byteOffset</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>), and <var>length</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>). It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an Object that has a [[TypedArrayName]] internal slot.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>buffer</var> is an Object that has an [[ArrayBufferData]] internal slot.</li><li>Let <var>constructorName</var> be the String value of <var>O</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>constructorName</var>.</li><li>Let <var>offset</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_151"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>byteOffset</var>).</li><li>If <var>offset</var> <emu-xref aoid="modulo"><a href="https://tc39.es/ecma262/#eqn-modulo">modulo</a></emu-xref> <var>elementSize</var> ≠ 0, throw a <emu-val>RangeError</emu-val> exception</li><li><ins>Let <var>bufferIsResizable</var> be <emu-xref aoid="IsResizableArrayBuffer" id="_ref_152"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>buffer</var>).</ins>.</li><li>If <var>length</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>newLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_153"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>length</var>).</li></ol></li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_154"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>bufferByteLength</var> be <del><var>buffer</var>.[[ArrayBufferByteLength]]</del><ins><emu-xref aoid="ArrayBufferByteLength" id="_ref_155"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>buffer</var>, <emu-const>SeqCst</emu-const>).</ins>.</li><li><ins>If <var>length</var> is <emu-val>undefined</emu-val> and <var>bufferIsResizable</var> is <emu-val>true</emu-val>, then</ins><ol><li><ins>If <var>offset</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li><ins>Set <var>O</var>.[[ByteLength]] to <emu-const>auto</emu-const>.</ins></li><li><ins>Set <var>O</var>.[[ArrayLength]] to <emu-const>auto</emu-const>.</ins></li></ol></li><li><ins>Else,</ins><ol><li>If <var>length</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>bufferByteLength</var> <emu-xref aoid="modulo"><a href="https://tc39.es/ecma262/#eqn-modulo">modulo</a></emu-xref> <var>elementSize</var> ≠ 0, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>newByteLength</var> be <var>bufferByteLength</var> - <var>offset</var>.</li><li>If <var>newByteLength</var> &lt; 0, throw a <emu-val>RangeError</emu-val> exception.</li></ol></li><li>Else,<ol><li>Let <var>newByteLength</var> be <var>newLength</var> × <var>elementSize</var>.</li><li>If <var>offset</var> + <var>newByteLength</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li></ol></li><li><del>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>buffer</var>.</del></li><li>Set <var>O</var>.[[ByteLength]] to <var>newByteLength</var>.</li><li><del>Set <var>O</var>.[[ByteOffset]] to <var>offset</var>.</del></li><li>Set <var>O</var>.[[ArrayLength]] to <var>newByteLength</var> / <var>elementSize</var>.</li></ol></li><li><ins>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>buffer</var>.</ins></li><li><ins>Set <var>O</var>.[[ByteOffset]] to <var>offset</var>.</ins></li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-dataview-objects-mods">
  <h1><span class="secnum">9</span> Modifications to DataView Objects</h1>

  <emu-clause id="sec-abstract-operations-for-dataview-objects-mods">
    <h1><span class="secnum">9.1</span> Modifications to Abstract Operations For DataView Objects</h1>

    <ins class="block">
    <emu-clause id="sec-getviewbytelength" aoid="GetViewByteLength">
      <h1><span class="secnum">9.1.1</span> GetViewByteLength ( <var>view</var>, <var>getBufferByteLength</var> )</h1>
      <p>The abstract operation GetViewByteLength takes arguments <var>view</var> and <var>getBufferByteLength</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_156"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>view</var>, [[DataView]]).</li><li>If <var>view</var>.[[ByteLength]] is not <emu-const>auto</emu-const>, then return <var>view</var>.[[ByteLength]].</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li>Return <var>getBufferByteLength</var>(<var>buffer</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-isviewoutofbounds" aoid="IsViewOutOfBounds">
      <h1><span class="secnum">9.1.2</span> IsViewOutOfBounds ( <var>view</var>, <var>getBufferByteLength</var> )</h1>
      <p>The abstract operation IsViewOutOfBounds takes arguments <var>view</var> and <var>getBufferByteLength</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_157"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>view</var>, [[DataView]]).</li><li>Let <var>byteLength</var> be <emu-xref aoid="GetViewByteLength" id="_ref_158"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>).</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li>Let <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</li><li>If <var>view</var>.[[ByteOffset]] + <var>byteLength</var> &gt; <var>bufferByteLength</var>, then return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-getviewvalue" aoid="GetViewValue">
      <h1><span class="secnum">9.1.3</span> GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> )</h1>
      <p>The abstract operation GetViewValue takes arguments <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, and <var>type</var>. It is used by functions on DataView instances to retrieve values from the view's buffer. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_159"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>view</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>view</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>getIndex</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_160"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>requestIndex</var>).</li><li>Set <var>isLittleEndian</var> to !&nbsp;<emu-xref aoid="ToBoolean" id="_ref_161"><a href="https://tc39.es/ecma262/#sec-toboolean">ToBoolean</a></emu-xref>(<var>isLittleEndian</var>).</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_162"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_163"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>view</var>'s backing buffer is a GrowableSharedArrayBuffer.</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_164"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>viewOffset</var> be <var>view</var>.[[ByteOffset]].</li><li>Let <var>viewSize</var> be <del><var>view</var>.[[ByteLength]]</del><ins><emu-xref aoid="GetViewByteLength" id="_ref_165"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>getIndex</var> + <var>elementSize</var> &gt; <var>viewSize</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>bufferIndex</var> be <var>getIndex</var> + <var>viewOffset</var>.</li><li>Return <emu-xref aoid="GetValueFromBuffer" id="_ref_166"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>buffer</var>, <var>bufferIndex</var>, <var>type</var>, <emu-val>false</emu-val>, <emu-const>Unordered</emu-const>, <var>isLittleEndian</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-setviewvalue" aoid="SetViewValue">
      <h1><span class="secnum">9.1.4</span> SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> )</h1>
      <p>The abstract operation SetViewValue takes arguments <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, and <var>value</var>. It is used by functions on DataView instances to store values into the view's buffer. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_167"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>view</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>view</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>getIndex</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_168"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>requestIndex</var>).</li><li>If !&nbsp;<emu-xref aoid="IsBigIntElementType" id="_ref_169"><a href="https://tc39.es/ecma262/#sec-isbigintelementtype">IsBigIntElementType</a></emu-xref>(<var>type</var>) is <emu-val>true</emu-val>, let <var>numberValue</var> be ?&nbsp;<emu-xref aoid="ToBigInt" id="_ref_170"><a href="https://tc39.es/ecma262/#sec-tobigint">ToBigInt</a></emu-xref>(<var>value</var>).</li><li>Otherwise, let <var>numberValue</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_171"><a href="https://tc39.es/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>value</var>).</li><li>Set <var>isLittleEndian</var> to !&nbsp;<emu-xref aoid="ToBoolean" id="_ref_172"><a href="https://tc39.es/ecma262/#sec-toboolean">ToBoolean</a></emu-xref>(<var>isLittleEndian</var>).</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_173"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_174"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>view</var>'s backing buffer is a GrowableSharedArrayBuffer.</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_175"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>viewOffset</var> be <var>view</var>.[[ByteOffset]].</li><li>Let <var>viewSize</var> be <del><var>view</var>.[[ByteLength]]</del><ins><emu-xref aoid="GetViewByteLength" id="_ref_176"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>getIndex</var> + <var>elementSize</var> &gt; <var>viewSize</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>bufferIndex</var> be <var>getIndex</var> + <var>viewOffset</var>.</li><li>Return <emu-xref aoid="SetValueInBuffer" id="_ref_177"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>buffer</var>, <var>bufferIndex</var>, <var>type</var>, <var>numberValue</var>, <emu-val>false</emu-val>, <emu-const>Unordered</emu-const>, <var>isLittleEndian</var>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-constructor-mods">
    <h1><span class="secnum">9.2</span> Modifications to the DataView Constructor</h1>

    <emu-clause id="sec-dataview-buffer-byteoffset-bytelength">
      <h1><span class="secnum">9.2.1</span> DataView ( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>byteLength</var> ] ] )</h1>
      <p>When the <code>DataView</code> function is called with at least one argument <var>buffer</var>, the following steps are taken:</p>
      <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_178"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>buffer</var>, [[ArrayBufferData]]).</li><li>Let <var>offset</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_179"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>byteOffset</var>).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_180"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>bufferByteLength</var> be <del><var>buffer</var>.[[ArrayBufferByteLength]]</del><ins>ArrayBufferByteLengthGetter(<var>buffer</var>, <emu-const>SeqCst</emu-const>).</ins>.</li><li>If <var>offset</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li><ins>Let <var>bufferIsResizable</var> be <emu-xref aoid="IsResizableArrayBuffer" id="_ref_181"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>buffer</var>).</ins></li><li><ins>If <var>bufferIsResizable</var> is <emu-val>true</emu-val> and <var>byteLength</var> is <emu-val>undefined</emu-val>, then</ins><ol><li><ins>Let <var>viewByteLength</var> be <emu-const>auto</emu-const>.</ins></li></ol></li><li><del>I</del><ins>Else i</ins>f <var>byteLength</var> is <emu-val>undefined</emu-val>, then<ol><li>Let <var>viewByteLength</var> be <var>bufferByteLength</var> - <var>offset</var>.</li></ol></li><li>Else,<ol><li>Let <var>viewByteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_182"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>byteLength</var>).</li><li>If <var>offset</var> + <var>viewByteLength</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li></ol></li><li>Let <var>O</var> be ?&nbsp;<emu-xref aoid="OrdinaryCreateFromConstructor" id="_ref_183"><a href="https://tc39.es/ecma262/#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(NewTarget, <emu-val>"%DataView.prototype%"</emu-val>, « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_184"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>buffer</var>.</li><li>Set <var>O</var>.[[ByteLength]] to <var>viewByteLength</var>.</li><li>Set <var>O</var>.[[ByteOffset]] to <var>offset</var>.</li><li>Return <var>O</var>.</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-dataview-prototype-object-mods">
    <h1><span class="secnum">9.3</span> Modifications to Properties of the DataView Prototype Object</h1>

    <emu-clause id="sec-get-dataview.prototype.bytelength">
      <h1><span class="secnum">9.3.1</span> get DataView.prototype.byteLength</h1>
      <p><code>DataView.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_185"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_186"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_187"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_188"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>size</var> be <del><var>O</var>.[[ByteLength]]</del><ins><emu-xref aoid="GetViewByteLength" id="_ref_189"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>size</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-dataview.prototype.byteoffset">
      <h1><span class="secnum">9.3.2</span> get DataView.prototype.byteOffset</h1>
      <p><code>DataView.prototype.byteOffset</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_190"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_191"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_192"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_193"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>offset</var> be <var>O</var>.[[ByteOffset]].</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>offset</var>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations-for-atomics-mods">
  <h1><span class="secnum">10</span> Modifications to Abstract Operations for Atomics</h1>

  <emu-clause id="sec-validateatomicaccess" aoid="ValidateAtomicAccess">
    <h1><span class="secnum">10.1</span> ValidateAtomicAccess ( <var>typedArray</var>, <var>requestIndex</var> )</h1>
    <p>The abstract operation ValidateAtomicAccess takes arguments <var>typedArray</var> and <var>requestIndex</var>. It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>typedArray</var> is an Object that has a [[ViewedArrayBuffer]] internal slot.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_194"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li>Let <var>length</var> be <del><var>typedArray</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_195"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>typedArray</var>)</ins>.</li><li>Let <var>accessIndex</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_196"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>requestIndex</var>).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>accessIndex</var> ≥ 0.</li><li>If <var>accessIndex</var> ≥ <var>length</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Return (<var>accessIndex</var> × <var>elementSize</var>) + <var>offset</var>.</li></ol></emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-maxbytelength-guidelines">
  <h1><span class="secnum">11</span> ResizableArrayBuffer and GrowableSharedArrayBuffer Guidelines</h1>
  <emu-note><span class="note">Note 1</span><div class="note-contents">
    <p>The following are guidelines for ECMAScript programmers working with ResizableArrayBuffer and GrowableSharedArrayBuffer.</p>
    <p>We recommend that programs be tested in their deployment environments where possible. The amount of available physical memory differ greatly between hardware devices. Similarly, virtual memory subsystems also differ greatly between hardware devices as well as operating systems. An application that runs without out-of-memory errors on a 64-bit desktop web browser could run out of memory on a 32-bit mobile web browser.</p>
    <p>When choosing a value for <var>requestedMaxByteLength</var> parameters for ResizableArrayBuffer and GrowableSharedArrayBuffer, we recommend that the smallest possible size for the application be chosen. We recommend that <var>requestedMaxByteLength</var> does not exceed 1073741824, or 1GiB.</p>
    <p>Please note that successfully constructing a ResizableArrayBuffer or a GrowableSharedArrayBuffer for a particular maximum size does not guarantee that future resizes and grows will succeed.</p>
  </div></emu-note>

  <emu-note><span class="note">Note 2</span><div class="note-contents">
    <p>The following are guidelines for ECMAScript implementers implementing ResizableArrayBuffer.</p>
    <p>ResizableArrayBuffer can be implemented as copying upon resize, as in-place growth via reserving virtual memory up front, or as a combination of both for different values of the <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref>'s <var>requestedMaxByteLength</var> parameter.</p>
    <p>If a host is multi-tenanted (i.e. it runs many JavaScript applications simultaneously), such as a web browser, and its implementations choose to implement in-place growth by reserving virtual memory, we recommend that both 32-bit and 64-bit implementations throw for values of <var>requestedMaxByteLength</var> ≥ 1GiB to 1.5GiB. This is to reduce the likelihood a single application can exhaust the virtual memory address space and to reduce interoperability risks.</p>
    <p>If a host does not have virtual memory, such as those running on embedded devices, or if a host only implements resizing by copying, it may ignore the <var>requestedMaxByteLength</var> parameter. However, we recommend a <emu-val>RangeError</emu-val> be thrown if a memory block of the requested size can never be allocated. For example, if the requested size is greater than the maximium amount of usable memory on the device.</p>
  </div></emu-note>

  <emu-note><span class="note">Note 3</span><div class="note-contents">
    <p>The following are guidelines for ECMAScript implementers implementing GrowableSharedArrayBuffer.</p>
    <p>We recommend GrowableSharedArrayBuffer be implemented as in-place growth via reserving virtual memory up front.</p>
    <p>Because grow operations can be concurrent with memory accesses on a GrowableSharedArrayBuffer, the constraints of the <emu-xref href="#sec-memory-model"><a href="https://tc39.es/ecma262/#sec-memory-model">memory model</a></emu-xref> require that even unordered accesses do not "tear" (bits of their values will not be mixed). In practice, this means the underlying data block of a GrowableSharedArrayBuffer cannot be grown by being copied without stopping the world. We do not recommend stopping the world as an implementation strategy because it introduces a serialization point and is slow.</p>
    <p>If a host does not have virtual memory, such as those running on embedded devices, we recommend ignoring the <var>requestedMaxByteLength</var> parameter, throwing on calling GorwableSharedArrayBuffer.prototype.grow, and communicating to users that GrowableSharedArrayBuffers cannot be grown.</p>
  </div></emu-note>
</emu-clause>

<emu-clause id="omitted-for-brevity">
  <h1><span class="secnum">12</span> Mechanical Changes Omitted for Brevity</h1>
  <ul>
    <li><p>Uses of [[ArrayLength]] on <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">Integer</a></emu-xref>-Indexed exotic objects are replaced with calls to <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_197"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>.</p></li>
    <li><p>Uses of [[ByteLength]] on <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">Integer</a></emu-xref>-Indexed exotic objects are replaced with calls to IntegerIndexedByteLength.</p></li>
    <li><p>Uses of [[ArrayBufferByteLength]] on buffer objects that may be GrowableSharedArrayBuffers are replaced with calls to <emu-xref aoid="ArrayBufferByteLength" id="_ref_198"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>.</p></li>
    <li><p>Additions of <emu-xref href="#sec-resizablearraybuffer-constructor" id="_ref_199"><a href="#sec-resizablearraybuffer-constructor">%ResizableArrayBuffer%</a></emu-xref> and <emu-xref href="#sec-growablesharedarraybuffer-constructor" id="_ref_200"><a href="#sec-growablesharedarraybuffer-constructor">%GrowableSharedArrayBuffer%</a></emu-xref> to the intrinsics table.</p></li>
  </ul>
</emu-clause>
</div></body>