<!doctype html>
<head><meta charset="utf-8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/styles/base16/solarized-light.min.css"><link rel="stylesheet" href="ecmarkup.css">
<title>Resizable ArrayBuffer and growable SharedArrayBuffer</title>
</head><body><div id="menu-toggle"><svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%; stroke:currentColor" viewBox="0 0 120 120">
      <title>Menu</title>
      <path stroke-width="10" stroke-linecap="round" d="M30,60 h60  M30,30 m0,5 h60  M30,90 m0,-5 h60"></path>
    </svg></div><div id="menu-spacer"></div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-pins"><div class="menu-pane-header">Pins</div><ul id="menu-pins-list"></ul></div><div class="menu-pane-header">Table of Contents</div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Resizable ArrayBuffer and growable SharedArrayBuffer">Resizable ArrayBuffer and growable SharedArrayBuffer</a></li><li><span class="item-toggle">‚ó¢</span><a href="#sec-arraybuffer-objects-mods" title="Modifications to ArrayBuffer Objects"><span class="secnum">1</span> Modifications to ArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle">‚ó¢</span><a href="#sec-abstract-operations-for-arraybuffer-objects-mods" title="Modifications to Abstract Operations for ArrayBuffer Objects"><span class="secnum">1.1</span> Modifications to Abstract Operations for ArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-detacharraybuffer" title="DetachArrayBuffer ( arrayBuffer [ , key ] )"><span class="secnum">1.1.1</span> DetachArrayBuffer ( <var>arrayBuffer</var> [ , <var>key</var> ] )</a></li><li><span class="item-toggle-none"></span><a href="#sec-allocatearraybuffer" title="AllocateArrayBuffer ( constructor, byteLength [ , maxByteLength ] )"><span class="secnum">1.1.2</span> AllocateArrayBuffer ( <var>constructor</var>, <var>byteLength</var> [ , <var>maxByteLength</var> ] )</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybufferlength" title="ArrayBufferByteLength ( arrayBuffer, order )"><span class="secnum">1.1.3</span> ArrayBufferByteLength ( <var>arrayBuffer</var>, <var>order</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-makeidempotentarraybufferbytelengthgetter" title="MakeIdempotentArrayBufferByteLengthGetter ( order )"><span class="secnum">1.1.4</span> MakeIdempotentArrayBufferByteLengthGetter ( <var>order</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isresizablearraybuffer" title="IsResizableArrayBuffer ( arrayBuffer )"><span class="secnum">1.1.5</span> IsResizableArrayBuffer ( <var>arrayBuffer</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-getarraybuffermaxbytelengthoption" title="GetArrayBufferMaxByteLengthOption ( options )"><span class="secnum">1.1.6</span> GetArrayBufferMaxByteLengthOption ( <var>options</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-hostresizearraybuffer" title="HostResizeArrayBuffer ( buffer, newByteLength )"><span class="secnum">1.1.7</span> HostResizeArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</a></li></ol></li><li><span class="item-toggle">‚ó¢</span><a href="#sec-arraybuffer-constructor" title="The ArrayBuffer Constructor"><span class="secnum">1.2</span> The ArrayBuffer Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer-length" title="ArrayBuffer ( length[ , options ] )"><span class="secnum">1.2.1</span> ArrayBuffer ( <var>length</var><ins>[ , <var>options</var> ]</ins> )</a></li></ol></li><li><span class="item-toggle">‚ó¢</span><a href="#sec-properties-of-the-arraybuffer-prototype-object-mods" title="Modifications to the Properties of the ArrayBuffer Prototype Object"><span class="secnum">1.3</span> Modifications to the Properties of the ArrayBuffer Prototype Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-arraybuffer-@@species" title="get ArrayBuffer [ @@species ]"><span class="secnum">1.3.1</span> get ArrayBuffer [ @@species ]</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-arraybuffer.prototype.maxbytelength" title="get ArrayBuffer.prototype.maxByteLength"><span class="secnum">1.3.2</span> get ArrayBuffer.prototype.maxByteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-arraybuffer.prototype.resizable" title="get ArrayBuffer.prototype.resizable"><span class="secnum">1.3.3</span> get ArrayBuffer.prototype.resizable</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer.prototype.slice" title="ArrayBuffer.prototype.slice ( start, end )"><span class="secnum">1.3.4</span> ArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer.prototype.resize" title="ArrayBuffer.prototype.resize ( newLength )"><span class="secnum">1.3.5</span> ArrayBuffer.prototype.resize ( <var>newLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer.prototype.transfer" title="ArrayBuffer.prototype.transfer ( [ newLength ] )"><span class="secnum">1.3.6</span> ArrayBuffer.prototype.transfer ( [ <var>newLength</var> ] )</a></li></ol></li></ol></li><li><span class="item-toggle">‚ó¢</span><a href="#sec-sharedarraybuffer-objects-mods" title="Modifications to SharedArrayBuffer Objects"><span class="secnum">2</span> Modifications to SharedArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle">‚ó¢</span><a href="#sec-abstract-operations-for-sharedarraybuffer-objects-mods" title="Modifications to Abstract Operations for SharedArrayBuffer Objects"><span class="secnum">2.1</span> Modifications to Abstract Operations for SharedArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-allocatesharedarraybuffer" title="AllocateSharedArrayBuffer ( constructor, byteLength [ , maxByteLength ] )"><span class="secnum">2.1.1</span> AllocateSharedArrayBuffer ( <var>constructor</var>, <var>byteLength</var> [ , <var>maxByteLength</var> ] )</a></li><li><span class="item-toggle-none"></span><a href="#sec-hostgrowsharedarraybuffer" title="HostGrowSharedArrayBuffer ( buffer, newByteLength )"><span class="secnum">2.1.2</span> HostGrowSharedArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</a></li></ol></li><li><span class="item-toggle">‚ó¢</span><a href="#sec-sharedarraybuffer-constructor" title="The SharedArrayBuffer Constructor"><span class="secnum">2.2</span> The SharedArrayBuffer Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-sharedarraybuffer-length" title="SharedArrayBuffer ( length[ , options ] )"><span class="secnum">2.2.1</span> SharedArrayBuffer ( <var>length</var><ins>[ , <var>options</var> ]</ins> )</a></li></ol></li><li><span class="item-toggle">‚ó¢</span><a href="#sec-properties-of-the-sharedarraybuffer-prototype-object-mods" title="Modifications to the Properties of the SharedArrayBuffer Prototype Object"><span class="secnum">2.3</span> Modifications to the Properties of the SharedArrayBuffer Prototype Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-sharedarraybuffer.prototype.bytelength" title="get SharedArrayBuffer.prototype.byteLength"><span class="secnum">2.3.1</span> get SharedArrayBuffer.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-sharedarraybuffer.prototype.growable" title="get SharedArrayBuffer.prototype.growable"><span class="secnum">2.3.2</span> get SharedArrayBuffer.prototype.growable</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-sharedarraybuffer.prototype.maxbytelength" title="get SharedArrayBuffer.prototype.maxByteLength"><span class="secnum">2.3.3</span> get SharedArrayBuffer.prototype.maxByteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-sharedarraybuffer.prototype.grow" title="SharedArrayBuffer.prototype.grow ( newLength )"><span class="secnum">2.3.4</span> SharedArrayBuffer.prototype.grow ( <var>newLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-sharedarraybuffer.prototype.slice" title="SharedArrayBuffer.prototype.slice ( start, end )"><span class="secnum">2.3.5</span> SharedArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</a></li></ol></li></ol></li><li><span class="item-toggle">‚ó¢</span><a href="#sec-integer-indexed-exotic-objects-mods" title="Modifications to Integer-Indexed Exotic Objects"><span class="secnum">3</span> Modifications to Integer-Indexed Exotic Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-integer-indexed-exotic-objects-ownpropertykeys" title="[[OwnPropertyKeys]] ( )"><span class="secnum">3.1</span> [[OwnPropertyKeys]] ( )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isvalidintegerindex" title="IsValidIntegerIndex ( O, index )"><span class="secnum">3.2</span> IsValidIntegerIndex ( <var>O</var>, <var>index</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-integerindexedobjectbytelength" title="IntegerIndexedObjectByteLength ( O, getBufferByteLength )"><span class="secnum">3.3</span> IntegerIndexedObjectByteLength ( <var>O</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-integerindexedobjectlength" title="IntegerIndexedObjectLength ( O, getBufferByteLength )"><span class="secnum">3.4</span> IntegerIndexedObjectLength ( <var>O</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isintegerindexedobjectoutofbounds" title="IsIntegerIndexedObjectOutOfBounds ( O, getBufferByteLength )"><span class="secnum">3.5</span> IsIntegerIndexedObjectOutOfBounds ( <var>O</var>, <var>getBufferByteLength</var> )</a></li></ol></li><li><span class="item-toggle">‚ó¢</span><a href="#sec-typedarray-objects-mods" title="Modifications to TypedArray Objects"><span class="secnum">4</span> Modifications to TypedArray Objects</a><ol class="toc"><li><span class="item-toggle">‚ó¢</span><a href="#sec-properties-of-the-%typedarrayprototype%-object-mods" title="Modifications to Properties of the %TypedArray.prototype% Object"><span class="secnum">4.1</span> Modifications to Properties of the %TypedArray.prototype% Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-validatetypedarray" title="ValidateTypedArray ( O )"><span class="secnum">4.1.1</span> ValidateTypedArray ( <var>O</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-%typedarray%.prototype.bytelength" title="get %TypedArray%.prototype.byteLength"><span class="secnum">4.1.2</span> get %TypedArray%.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-%typedarray%.prototype.byteoffset" title="get %TypedArray%.prototype.byteOffset"><span class="secnum">4.1.3</span> get %TypedArray%.prototype.byteOffset</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-%typedarray%.prototype.length" title="get %TypedArray%.prototype.length"><span class="secnum">4.1.4</span> get %TypedArray%.prototype.length</a></li><li><span class="item-toggle-none"></span><a href="#sec-%typedarray%.prototype.copywithin" title="%TypedArray%.prototype.copyWithin ( target, start [ , end ] )"><span class="secnum">4.1.5</span> %TypedArray%.prototype.copyWithin ( <var>target</var>, <var>start</var> [ , <var>end</var> ] )</a></li><li><span class="item-toggle-none"></span><a href="#sec-%typedarray%.prototype.fill" title="%TypedArray%.prototype.fill ( value [ , start [ , end ] ] )"><span class="secnum">4.1.6</span> %TypedArray%.prototype.fill ( <var>value</var> [ , <var>start</var> [ , <var>end</var> ] ] )</a></li><li><span class="item-toggle-none"></span><a href="#sec-settypedarrayfromarraylike" title="SetTypedArrayFromArrayLike ( target, targetOffset, source )"><span class="secnum">4.1.7</span> SetTypedArrayFromArrayLike ( <var>target</var>, <var>targetOffset</var>, <var>source</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-%typedarray%.prototype.slice" title="%TypedArray%.prototype.slice ( start, end )"><span class="secnum">4.1.8</span> %TypedArray%.prototype.slice ( <var>start</var>, <var>end</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-%typedarray%.prototype.sort" title="%TypedArray%.prototype.sort ( comparefn )"><span class="secnum">4.1.9</span> %TypedArray%.prototype.sort ( <var>comparefn</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-settypedarrayfromtypedarray" title="SetTypedArrayFromTypedArray ( target, targetOffset, source )"><span class="secnum">4.1.10</span> SetTypedArrayFromTypedArray ( <var>target</var>, <var>targetOffset</var>, <var>source</var> )</a></li></ol></li><li><span class="item-toggle">‚ó¢</span><a href="#sec-typedarray-constructors-mods" title="Modifications to the TypedArray Constructors"><span class="secnum">4.2</span> Modifications to the <var>TypedArray</var> Constructors</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-initializetypedarrayfromtypedarray" title="InitializeTypedArrayFromTypedArray ( O, srcArray )"><span class="secnum">4.2.1</span> InitializeTypedArrayFromTypedArray ( <var>O</var>, <var>srcArray</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-initializetypedarrayfromarraybuffer" title="InitializeTypedArrayFromArrayBuffer ( O, buffer, byteOffset, length )"><span class="secnum">4.2.2</span> InitializeTypedArrayFromArrayBuffer ( <var>O</var>, <var>buffer</var>, <var>byteOffset</var>, <var>length</var> )</a></li></ol></li></ol></li><li><span class="item-toggle">‚ó¢</span><a href="#sec-dataview-objects-mods" title="Modifications to DataView Objects"><span class="secnum">5</span> Modifications to DataView Objects</a><ol class="toc"><li><span class="item-toggle">‚ó¢</span><a href="#sec-abstract-operations-for-dataview-objects-mods" title="Modifications to Abstract Operations For DataView Objects"><span class="secnum">5.1</span> Modifications to Abstract Operations For DataView Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-getviewbytelength" title="GetViewByteLength ( view, getBufferByteLength )"><span class="secnum">5.1.1</span> GetViewByteLength ( <var>view</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isviewoutofbounds" title="IsViewOutOfBounds ( view, getBufferByteLength )"><span class="secnum">5.1.2</span> IsViewOutOfBounds ( <var>view</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-getviewvalue" title="GetViewValue ( view, requestIndex, isLittleEndian, type )"><span class="secnum">5.1.3</span> GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-setviewvalue" title="SetViewValue ( view, requestIndex, isLittleEndian, type, value )"><span class="secnum">5.1.4</span> SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> )</a></li></ol></li><li><span class="item-toggle">‚ó¢</span><a href="#sec-dataview-constructor-mods" title="Modifications to the DataView Constructor"><span class="secnum">5.2</span> Modifications to the DataView Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-dataview-buffer-byteoffset-bytelength" title="DataView ( buffer [ , byteOffset [ , byteLength ] ] )"><span class="secnum">5.2.1</span> DataView ( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>byteLength</var> ] ] )</a></li></ol></li><li><span class="item-toggle">‚ó¢</span><a href="#sec-properties-of-the-dataview-prototype-object-mods" title="Modifications to Properties of the DataView Prototype Object"><span class="secnum">5.3</span> Modifications to Properties of the DataView Prototype Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-dataview.prototype.bytelength" title="get DataView.prototype.byteLength"><span class="secnum">5.3.1</span> get DataView.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-dataview.prototype.byteoffset" title="get DataView.prototype.byteOffset"><span class="secnum">5.3.2</span> get DataView.prototype.byteOffset</a></li></ol></li></ol></li><li><span class="item-toggle">‚ó¢</span><a href="#sec-abstract-operations-for-atomics-mods" title="Modifications to Abstract Operations for Atomics"><span class="secnum">6</span> Modifications to Abstract Operations for Atomics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-validateatomicaccess" title="ValidateAtomicAccess ( typedArray, requestIndex )"><span class="secnum">6.1</span> ValidateAtomicAccess ( <var>typedArray</var>, <var>requestIndex</var> )</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#sec-maxbytelength-guidelines" title="Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines"><span class="secnum">7</span> Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines</a></li><li><span class="item-toggle-none"></span><a href="#omitted-for-brevity" title="Mechanical Changes Omitted for Brevity"><span class="secnum">8</span> Mechanical Changes Omitted for Brevity</a></li></ol></div></div><div id="spec-container"><h1 class="version">Stage 3 Draft / February 1, 2022</h1>
<emu-intro id="intro">
  <h1>Resizable ArrayBuffer and growable SharedArrayBuffer</h1>
  <p>We extend the <code>ArrayBuffer</code> and <code>SharedArrayBuffer</code> constructors to take an additional maximum byte length, which would construct dynamically resizable and growable array buffers, respectively. In addition, a <code>transfer</code> method is added to the <code>ArrayBuffer</code> prototype.</p>
</emu-intro>

<emu-clause id="sec-arraybuffer-objects-mods">
  <h1><span class="secnum">1</span> Modifications to ArrayBuffer Objects</h1>

  <emu-clause id="sec-abstract-operations-for-arraybuffer-objects-mods">
    <h1><span class="secnum">1.1</span> Modifications to Abstract Operations for ArrayBuffer Objects</h1>

    <emu-clause id="sec-detacharraybuffer" type="abstract operation" aoid="DetachArrayBuffer">
      <h1><span class="secnum">1.1.1</span> DetachArrayBuffer ( <var>arrayBuffer</var> [ , <var>key</var> ] )</h1>
      <p>The abstract operation DetachArrayBuffer takes argument <var>arrayBuffer</var> (an ArrayBuffer) and optional argument <var>key</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="Type" id="_ref_1"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>arrayBuffer</var>) is Object and it has [[ArrayBufferData]], [[ArrayBufferByteLength]], and [[ArrayBufferDetachKey]] internal slots.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="IsSharedArrayBuffer" id="_ref_2"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>If <var>key</var> is not present, set <var>key</var> to <emu-val>undefined</emu-val>.</li><li>If <emu-xref aoid="SameValue" id="_ref_3"><a href="https://tc39.es/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>arrayBuffer</var>.[[ArrayBufferDetachKey]], <var>key</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Set <var>arrayBuffer</var>.[[ArrayBufferData]] to <emu-val>null</emu-val>.</li><li>Set <var>arrayBuffer</var>.[[ArrayBufferByteLength]] to 0.</li><li>Return <emu-xref aoid="NormalCompletion" id="_ref_4"><a href="https://tc39.es/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-val>null</emu-val>).</li></ol></emu-alg>
      <emu-note><span class="note">Note</span><div class="note-contents">
        <p>Detaching an ArrayBuffer instance disassociates the <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> used as its backing store from the instance and sets the byte length of the buffer to 0. <del>No operations defined by this specification use the DetachArrayBuffer abstract operation. However, an ECMAScript host or implementation may define such operations.</del></p>
      </div></emu-note>
    </emu-clause>

    <emu-clause id="sec-allocatearraybuffer" type="abstract operation" aoid="AllocateArrayBuffer">
      <h1><span class="secnum">1.1.2</span> AllocateArrayBuffer ( <var>constructor</var>, <var>byteLength</var> [ , <var>maxByteLength</var> ] )</h1>
      <p>The abstract operation AllocateArrayBuffer takes arguments <var>constructor</var> and <var>byteLength</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref>) and optional argument <ins><var>maxByteLength</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref>)</ins>. It is used to create an ArrayBuffer. It performs the following steps when called:</p>
      <emu-alg><ol><li><ins>Let <var>slots</var> be ¬´ [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] ¬ª.</ins></li><li><ins>If <var>maxByteLength</var> is present, append [[ArrayBufferMaxByteLength]] to <var>slots</var>.</ins></li><li>Let <var>obj</var> be ?&nbsp;<emu-xref aoid="OrdinaryCreateFromConstructor" id="_ref_5"><a href="https://tc39.es/ecma262/#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(<var>constructor</var>, <emu-val>"%ArrayBuffer.prototype%"</emu-val>, <del>¬´ [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] ¬ª</del><ins><var>slots</var></ins>).</li><li>Let <var>block</var> be ?&nbsp;<emu-xref aoid="CreateByteDataBlock" id="_ref_6"><a href="https://tc39.es/ecma262/#sec-createbytedatablock">CreateByteDataBlock</a></emu-xref>(<var>byteLength</var>).</li><li>Set <var>obj</var>.[[ArrayBufferData]] to <var>block</var>.</li><li>Set <var>obj</var>.[[ArrayBufferByteLength]] to <var>byteLength</var>.</li><li><ins>If <var>maxByteLength</var> is present, then</ins><ol><li><ins><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>byteLength</var> ‚â§ <var>maxByteLength</var>.</ins></li><li><ins>If it is not possible to create a <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> <var>block</var> consisting of <var>maxByteLength</var> bytes, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li><ins>NOTE: Resizable ArrayBuffers are designed to be implementable with in-place growth. Implementations reserve the right to throw if, for example, virtual memory cannot be reserved up front.</ins></li><li><ins>Set <var>obj</var>.[[ArrayBufferMaxByteLength]] to <var>maxByteLength</var>.</ins></li></ol></li><li>Return <var>obj</var>.</li></ol></emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-arraybufferlength" type="abstract operation" aoid="ArrayBufferByteLength">
      <h1><span class="secnum">1.1.3</span> ArrayBufferByteLength ( <var>arrayBuffer</var>, <var>order</var> )</h1>
      <p>The abstract operation ArrayBufferByteLength takes arguments <var>arrayBuffer</var> (an ArrayBuffer) and <var>order</var> (<emu-const>SeqCst</emu-const> or <emu-const>Unordered</emu-const>). It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="Type" id="_ref_7"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>arrayBuffer</var>) is Object and <var>arrayBuffer</var> has an [[ArrayBufferData]] internal slot.</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_8"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val> and <var>arrayBuffer</var> has an [[ArrayBufferByteLengthData]] internal slot, then<ol><li>Let <var>bufferByteLengthBlock</var> be <var>O</var>.[[ArrayBufferByteLengthData]].</li><li>Return <emu-xref href="#‚Ñù"><a href="https://tc39.es/ecma262/#‚Ñù">‚Ñù</a></emu-xref>(<emu-xref aoid="GetValueFromBuffer" id="_ref_9"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>bufferByteLengthBlock</var>, 0, <emu-const>BigUint64</emu-const>, <emu-val>true</emu-val>, <var>order</var>)).</li></ol></li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="IsDetachedBuffer" id="_ref_10"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>Return <var>arrayBuffer</var>.[[ArrayBufferByteLength]].</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-makeidempotentarraybufferbytelengthgetter" type="abstract operation" aoid="MakeIdempotentArrayBufferByteLengthGetter">
      <h1><span class="secnum">1.1.4</span> MakeIdempotentArrayBufferByteLengthGetter ( <var>order</var> )</h1>
      <p>The abstract operation MakeIdempotentArrayBufferByteLengthGetter takes argument <var>order</var> (<emu-const>SeqCst</emu-const> or <emu-const>Unordered</emu-const>). The returned Abstract Closure helps ensure that there there is a single shared memory read event of the byte length data block in the calling operation. It performs the following steps when called:</p>
      <emu-alg><ol><li>NOTE: The [[ArrayBuffer]] slot is used for editorial clarity only, that a getter should only be used with a single ArrayBuffer.</li><li>Let <var>lengthStorage</var> be { [[ArrayBuffer]]: <emu-const>empty</emu-const>, [[ByteLength]]: <emu-const>empty</emu-const> }.</li><li>Let <var>getter</var> be a new Abstract Closure with parameters (<var>buffer</var>) that captures <var>lengthStorage</var> and <var>order</var> and performs the following steps when called:<ol><li>If <var>lengthStorage</var>.[[ByteLength]] is <emu-const>empty</emu-const>, then<ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>lengthStorage</var>.[[ArrayBuffer]] is <emu-const>empty</emu-const>.</li><li>Set <var>lengthStorage</var>.[[ArrayBuffer]] to <var>buffer</var>.</li><li>Set <var>lengthStorage</var>.[[ByteLength]] to <emu-xref aoid="ArrayBufferByteLength" id="_ref_11"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>buffer</var>, <var>order</var>).</li></ol></li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="SameValue" id="_ref_12"><a href="https://tc39.es/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>lengthStorage</var>.[[ArrayBuffer]], <var>buffer</var>) is <emu-val>true</emu-val>.</li><li>Return <var>lengthStorage</var>.[[ByteLength]].</li></ol></li><li>Return <var>getter</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-isresizablearraybuffer" type="abstract operation" aoid="IsResizableArrayBuffer">
      <h1><span class="secnum">1.1.5</span> IsResizableArrayBuffer ( <var>arrayBuffer</var> )</h1>
      <p>The abstract operation IsResizableArrayBuffer takes argument <var>arrayBuffer</var> (an ArrayBuffer). It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="Type" id="_ref_13"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>arrayBuffer</var>) is Object and <var>arrayBuffer</var> has an [[ArrayBufferData]] internal slot.</li><li>If <var>buffer</var> has an [[ArrayBufferMaxByteLength]] internal slot, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-getarraybuffermaxbytelengthoption" type="abstract operation">
      <h1><span class="secnum">1.1.6</span> GetArrayBufferMaxByteLengthOption ( <var>options</var> )</h1>
      <p>The abstract operation GetArrayBufferMaxByteLengthOption takes argument <var>options</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li>If <emu-xref aoid="Type" id="_ref_14"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>options</var>) is not Object, return <emu-const>empty</emu-const>.</li><li>Let <var>maxByteLength</var> be ?&nbsp;<emu-xref aoid="Get" id="_ref_15"><a href="https://tc39.es/ecma262/#sec-get-o-p">Get</a></emu-xref>(<var>options</var>, <code>"maxByteLength"</code>).</li><li>If <var>maxByteLength</var> is <emu-val>undefined</emu-val>, return <emu-const>empty</emu-const>.</li><li>Return ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_16"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>maxByteLength</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-hostresizearraybuffer" type="host-defined abstract operation" aoid="HostResizeArrayBuffer">
      <h1><span class="secnum">1.1.7</span> HostResizeArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</h1>
      <p>The host-defined abstract operation HostResizeArrayBuffer takes arguments <var>buffer</var> (an ArrayBuffer) and <var>newByteLength</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref>). The host-defined abstract operation HostResizeArrayBuffer takes arguments <var>buffer</var> (an ArrayBuffer object) and <var>newByteLength</var>. It gives the host an opportunity to perform implementation-defined resizing of <var>buffer</var>. If the host chooses not to handle resizing of <var>buffer</var>, it may return <emu-const>unhandled</emu-const> for the default behavior.</p>

      <p>The implementation of HostResizeArrayBuffer must conform to the following requirements:</p>
      <ul>
        <li>The abstract operation must return either <emu-xref aoid="NormalCompletion" id="_ref_17"><a href="https://tc39.es/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-const>handled</emu-const>), <emu-xref aoid="NormalCompletion" id="_ref_18"><a href="https://tc39.es/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-const>unhandled</emu-const>), or an abrupt throw completion.</li>
        <li>The abstract operation does not detach <var>buffer</var>.</li>
        <li>If the abstract operation completes normally with <emu-const>handled</emu-const>, <var>buffer</var>.[[ArrayBufferByteLength]] is <var>newByteLength</var>.</li>
      </ul>

      <p>The default implementation of HostResizeArrayBuffer is to return <emu-const>unhandled</emu-const>.</p>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-arraybuffer-constructor">
    <h1><span class="secnum">1.2</span> The ArrayBuffer Constructor</h1>

    <emu-clause id="sec-arraybuffer-length">
      <h1><span class="secnum">1.2.1</span> ArrayBuffer ( <var>length</var><ins>[ , <var>options</var> ]</ins> )</h1>
      <p>When the <code>ArrayBuffer</code> function is called with argument <var>length</var><ins> and optional argument <var>options</var></ins>, the following steps are taken:</p>
      <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>byteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_19"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>length</var>).</li><li><ins>Let <var>requestedMaxByteLength</var> be ?&nbsp;GetArrayBufferMaxByteLengthOption(<var>options</var>).</ins></li><li><ins>If <var>requestedMaxByteLength</var> is <emu-const>empty</emu-const>, then</ins><ol><li><ins>Return ?&nbsp;<emu-xref aoid="AllocateArrayBuffer" id="_ref_20"><a href="#sec-allocatearraybuffer">AllocateArrayBuffer</a></emu-xref>(NewTarget, <var>byteLength</var>).</ins></li></ol></li><li><ins>If <var>byteLength</var> &gt; <var>requestedMaxByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li>Return ?&nbsp;<emu-xref aoid="AllocateArrayBuffer" id="_ref_21"><a href="#sec-allocatearraybuffer">AllocateArrayBuffer</a></emu-xref>(NewTarget, <var>byteLength</var><ins>, <var>requestedMaxByteLength</var></ins>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object-mods">
    <h1><span class="secnum">1.3</span> Modifications to the Properties of the ArrayBuffer Prototype Object</h1>

    <emu-clause id="sec-get-arraybuffer-@@species">
      <h1><span class="secnum">1.3.1</span> get ArrayBuffer [ @@species ]</h1>
      <p><code>ArrayBuffer[@@species]</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Return the <emu-val>this</emu-val> value.</li></ol></emu-alg>
      <p>The value of the <emu-val>"name"</emu-val> property of this function is <emu-val>"get [Symbol.species]"</emu-val>.</p>
      <emu-note><span class="note">Note</span><div class="note-contents">
        <p>ArrayBuffer prototype methods normally use their <emu-val>this</emu-val> value's <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref> to create a derived object. However, a subclass <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref> may over-ride that default behaviour <ins>for the <emu-xref href="#sec-arraybuffer.prototype.slice" title="" id="_ref_0"><a href="#sec-arraybuffer.prototype.slice">ArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</a></emu-xref> method</ins> by redefining its @@species property.</p>
      </div></emu-note>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-get-arraybuffer.prototype.maxbytelength">
      <h1><span class="secnum">1.3.2</span> get ArrayBuffer.prototype.maxByteLength</h1>
      <p><code>ArrayBuffer.prototype.maxByteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_22"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_23"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_24"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>ùîΩ</sub>.</li><li>If <emu-xref aoid="IsResizableArrayBuffer" id="_ref_25"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferMaxByteLength]].</li></ol></li><li>Else,<ol><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferByteLength]].</li></ol></li><li>Return <emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-arraybuffer.prototype.resizable">
      <h1><span class="secnum">1.3.3</span> get ArrayBuffer.prototype.resizable</h1>
      <p><code>ArrayBuffer.prototype.resizable</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_26"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_27"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <emu-xref aoid="IsResizableArrayBuffer" id="_ref_28"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>).</li></ol></emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-arraybuffer.prototype.slice">
      <h1><span class="secnum">1.3.4</span> ArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_29"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_30"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_31"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>len</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Let <var>relativeStart</var> be ?&nbsp;ToIntegerOrInfinity(<var>start</var>).</li><li>If <var>relativeStart</var> is -‚àû, let <var>first</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>first</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>first</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;ToIntegerOrInfinity(<var>end</var>).</li><li>If <var>relativeEnd</var> is -‚àû, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>newLen</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>final</var> - <var>first</var>, 0).</li><li>Let <var>ctor</var> be ?&nbsp;<emu-xref aoid="SpeciesConstructor" id="_ref_32"><a href="https://tc39.es/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>O</var>, <emu-xref href="#sec-arraybuffer-constructor" id="_ref_33"><a href="#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li><li>Let <var>new</var> be ?&nbsp;<emu-xref aoid="Construct" id="_ref_34"><a href="https://tc39.es/ecma262/#sec-construct">Construct</a></emu-xref>(<var>ctor</var>, ¬´ <emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>newLen</var>) ¬ª).</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_35"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>new</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_36"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>new</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_37"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>new</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="SameValue" id="_ref_38"><a href="https://tc39.es/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>new</var>, <var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>new</var>.[[ArrayBufferByteLength]] &lt; <var>newLen</var>, throw a <emu-val>TypeError</emu-val> exception.</li><li>NOTE: Side-effects of the above steps may have detached <ins>or resized </ins><var>O</var>.</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_39"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>fromBuf</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBuf</var> be <var>new</var>.[[ArrayBufferData]].</li><li><ins>If <var>first</var> &lt; <var>O</var>.[[ArrayBufferByteLength]], then</ins><ol><li>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_40"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBuf</var>, 0, <var>fromBuf</var>, <var>first</var>, <ins><emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>O</var>.[[ArrayBufferByteLenth]], </ins><var>newLen</var><ins>)</ins>).</li></ol></li><li>Return <var>new</var>.</li></ol></emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-arraybuffer.prototype.resize">
      <h1><span class="secnum">1.3.5</span> ArrayBuffer.prototype.resize ( <var>newLength</var> )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_41"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_42"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_43"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>newByteLength</var> be ?&nbsp;ToIntegerOrInfinity(<var>newLength</var>).</li><li>If <var>newByteLength</var> &lt; 0 or <var>newByteLength</var> &gt; <var>O</var>.[[ArrayBufferMaxByteLength]], throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>hostHandled</var> be ?&nbsp;<emu-xref aoid="HostResizeArrayBuffer" id="_ref_44"><a href="#sec-hostresizearraybuffer">HostResizeArrayBuffer</a></emu-xref>(<var>O</var>, <var>newByteLength</var>).</li><li>If <var>hostHandled</var> is <emu-const>handled</emu-const>, return <emu-val>undefined</emu-val>.</li><li>Let <var>oldBlock</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>newBlock</var> be ?&nbsp;<emu-xref aoid="CreateByteDataBlock" id="_ref_45"><a href="https://tc39.es/ecma262/#sec-createbytedatablock">CreateByteDataBlock</a></emu-xref>(<var>newByteLength</var>).</li><li>Let <var>copyLength</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>newByteLength</var>, <var>O</var>.[[ArrayBufferByteLength]]).</li><li>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_46"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>newBlock</var>, 0, <var>oldBlock</var>, 0, <var>copyLength</var>).</li><li>NOTE: Neither creation of the new <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> nor copying from the old <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> are observable. Implementations reserve the right to implement this method as in-place growth or shrinkage.</li><li>Set <var>O</var>.[[ArrayBufferData]] to <var>newBlock</var>.</li><li>Set <var>O</var>.[[ArrayBufferByteLength]] to <var>newLength</var>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-arraybuffer.prototype.transfer">
      <h1><span class="secnum">1.3.6</span> ArrayBuffer.prototype.transfer ( [ <var>newLength</var> ] )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_47"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_48"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_49"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>newLength</var> is <emu-val>undefined</emu-val>, let <var>newByteLength</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Else, let <var>newByteLength</var> be ?&nbsp;ToIntegerOrInfinity(<var>newLength</var>).</li><li>Let <var>new</var> be ?&nbsp;<emu-xref aoid="Construct" id="_ref_50"><a href="https://tc39.es/ecma262/#sec-construct">Construct</a></emu-xref>(<emu-xref href="#sec-arraybuffer-constructor" id="_ref_51"><a href="#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>, ¬´ <emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>newByteLength</var>) ¬ª).</li><li>NOTE: This method returns a fixed-length ArrayBuffer.</li><li>Let <var>copyLength</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>newByteLength</var>, <var>O</var>.[[ArrayBufferByteLength]]).</li><li>Let <var>fromBlock</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBlock</var> be <var>new</var>.[[ArrayBufferData]].</li><li>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_52"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBlock</var>, 0, <var>fromBlock</var>, 0, <var>copyLength</var>).</li><li>NOTE: Neither creation of the new <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> nor copying from the old <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> are observable. Implementations reserve the right to implement this method as a zero-copy move or a <code>realloc</code>.</li><li>Perform ?&nbsp;<emu-xref aoid="DetachArrayBuffer" id="_ref_53"><a href="#sec-detacharraybuffer">DetachArrayBuffer</a></emu-xref>(<var>O</var>).</li><li>Return <var>new</var>.</li></ol></emu-alg>
      <emu-note><span class="note">Note</span><div class="note-contents">
        <p>The <code>transfer</code> method intentionally does not honor the @@species property when creating derived objects.</p>
      </div></emu-note>
    </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-sharedarraybuffer-objects-mods">
  <h1><span class="secnum">2</span> Modifications to SharedArrayBuffer Objects</h1>

  <emu-clause id="sec-abstract-operations-for-sharedarraybuffer-objects-mods">
    <h1><span class="secnum">2.1</span> Modifications to Abstract Operations for SharedArrayBuffer Objects</h1>

    <emu-clause id="sec-allocatesharedarraybuffer" type="abstract operation" aoid="AllocateSharedArrayBuffer">
      <h1><span class="secnum">2.1.1</span> AllocateSharedArrayBuffer ( <var>constructor</var>, <var>byteLength</var> [ , <var>maxByteLength</var> ] )</h1>
      <p>The abstract operation AllocateSharedArrayBuffer takes arguments <var>constructor</var> and <var>byteLength</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref>) and optional argument <ins><var>maxByteLength</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref>)</ins>. It is used to create a SharedArrayBuffer. It performs the following steps when called:</p>
      <emu-alg><ol><li><ins>Let <var>slots</var> be ¬´ [[ArrayBufferData]] ¬ª.</ins></li><li><ins>If <var>maxByteLength</var> is present, append [[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to <var>slots</var>.</ins></li><li><ins>Else, append [[ArrayBufferByteLength]] to <var>slots</var>.</ins></li><li>Let <var>obj</var> be ?&nbsp;<emu-xref aoid="OrdinaryCreateFromConstructor" id="_ref_54"><a href="https://tc39.es/ecma262/#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(<var>constructor</var>, <emu-val>"%SharedArrayBuffer.prototype%"</emu-val>, <del>¬´ [[ArrayBufferData]], [[ArrayBufferByteLength]] ¬ª</del><ins><var>slots</var></ins>).</li><li><ins>If <var>maxByteLength</var> is present, then let <var>allocLength</var> be <var>maxByteLength</var>.</ins></li><li><ins>Else, let <var>allocLength</var> be <var>byteLength</var></ins></li><li>Let <var>block</var> be ?&nbsp;<emu-xref aoid="CreateSharedByteDataBlock" id="_ref_55"><a href="https://tc39.es/ecma262/#sec-createsharedbytedatablock">CreateSharedByteDataBlock</a></emu-xref>(<del><var>byteLength</var></del><ins><var>allocLength</var></ins>).</li><li><ins>NOTE: Growable SharedArrayBuffers must be implemented as in-place growable. Creation of a <var>maxByteLength</var> sized <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> is a specification mechanism. It may be implemented as committing a <var>byteLength</var> sized buffer while reserving <var>maxByteLength</var> in virtual memory.</ins></li><li>Set <var>obj</var>.[[ArrayBufferData]] to <var>block</var>.</li><li><ins>If <var>maxByteLength</var> is present, then</ins><ol><li><ins><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>byteLength</var> ‚â§ <var>maxByteLength</var>.</ins></li><li><ins>Let <var>byteLengthBlock</var> be ?&nbsp;<emu-xref aoid="CreateSharedByteDataBlock" id="_ref_56"><a href="https://tc39.es/ecma262/#sec-createsharedbytedatablock">CreateSharedByteDataBlock</a></emu-xref>(8).</ins></li><li><ins>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_57"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>byteLengthBlock</var>, 0, <emu-const>BigUint64</emu-const>, ‚Ñ§(<var>byteLength</var>), <emu-val>true</emu-val>, <emu-const>SeqCst</emu-const>).</ins></li><li><ins>Set <var>obj</var>.[[ArrayBufferByteLengthData]] to <var>byteLengthBlock</var>.</ins></li><li><ins>Set <var>obj</var>.[[ArrayBufferMaxByteLength]] to <var>maxByteLength</var>.</ins></li></ol></li><li><ins>Else,</ins><ol><li>Set <var>obj</var>.[[ArrayBufferByteLength]] to <var>byteLength</var>.</li></ol></li><li>Return <var>obj</var>.</li></ol></emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-hostgrowsharedarraybuffer" type="host-defined abstract operation" aoid="HostGrowSharedArrayBuffer">
      <h1><span class="secnum">2.1.2</span> HostGrowSharedArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</h1>
      <p>The host-defined abstract operation HostGrowSharedArrayBuffer takes arguments <var>buffer</var> and <var>newByteLength</var>. It gives the host an opportunity to perform implementation-defined growing of <var>buffer</var>. If the host chooses not to handle resizing of <var>buffer</var>, it may return <emu-const>unhandled</emu-const> for the default behavior.</p>
      <p>The implementation of HostGrowSharedArrayBuffer must conform to the following requirements:</p>
      <ul>
         <li>The abstract operation must return either <emu-xref aoid="NormalCompletion" id="_ref_58"><a href="https://tc39.es/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-const>handled</emu-const>), <emu-xref aoid="NormalCompletion" id="_ref_59"><a href="https://tc39.es/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-const>unhandled</emu-const>), or an abrupt throw completion.</li>
         <li>If the abstract operation does not complete normally with <emu-const>unhandled</emu-const>, and <var>newByteLength</var> &lt; the current byte length of the <var>buffer</var> or <var>newByteLength</var> &gt; <var>buffer</var>.[[ArrayBufferMaxByteLength]], throw a <emu-val>RangeError</emu-val> exception.</li>
         <li>Let <var>isLittleEndian</var> be the value of the [[LittleEndian]] field of the <emu-xref href="#surrounding-agent"><a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a></emu-xref>'s <emu-xref href="#agent-record"><a href="https://tc39.es/ecma262/#agent-record">Agent Record</a></emu-xref>. If the abstract operation completes normally with <emu-const>handled</emu-const>, a <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">WriteSharedMemory</a></emu-xref> or <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">ReadModifyWriteSharedMemory</a></emu-xref> event whose [[Order]] is <emu-const>SeqCst</emu-const>, [[Payload]] is <emu-xref aoid="NumericToRawBytes" id="_ref_60"><a href="https://tc39.es/ecma262/#sec-numerictorawbytes">NumericToRawBytes</a></emu-xref>(<emu-const>BigUint64</emu-const>, <var>newByteLength</var>, <var>isLittleEndian</var>), [[Block]] is <var>buffer</var>.[[ArrayBufferByteLengthData]], [[ByteIndex]] is 0, and [[ElementSize]] is 8 is added to the <emu-xref href="#surrounding-agent"><a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a></emu-xref>'s <emu-xref href="#sec-candidate-executions"><a href="https://tc39.es/ecma262/#sec-candidate-executions">candidate execution</a></emu-xref> such that racing calls to <code>SharedArrayBuffer.prototype.grow</code> are not "lost", i.e. silently do nothing.</li>
      </ul>

      <p>The default implementation of HostGrowSharedArrayBuffer is to return <emu-const>unhandled</emu-const>.</p>

      <emu-note><span class="note">Note</span><div class="note-contents">
        <p>The second requirement above is intentionally vague about how or when the current byte length of <var>buffer</var> is read. Because the byte length must be updated via an atomic read-modify-write operation on the underlying hardware, architectures that use load-link/store-conditional or load-exclusive/store-exclusive instruction pairs may wish to keep the paired instructions close in the instruction stream. As such, SharedArrayBuffer.prototype.grow itself does not perform bounds checking on <var>newByteLength</var> before calling HostGrowSharedArrayBuffer, nor is there a requirement on when the current byte length is read.</p>
        <p>This is in contrast with <emu-xref aoid="HostResizeArrayBuffer" id="_ref_61"><a href="#sec-hostresizearraybuffer">HostResizeArrayBuffer</a></emu-xref>, which is guaranteed that the value of <var>newByteLength</var> is ‚â• 0 and ‚â§ <var>buffer</var>.[[ArrayBufferMaxByteLength]].</p>
      </div></emu-note>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer-constructor">
    <h1><span class="secnum">2.2</span> The SharedArrayBuffer Constructor</h1>

    <emu-clause id="sec-sharedarraybuffer-length">
      <h1><span class="secnum">2.2.1</span> SharedArrayBuffer ( <var>length</var><ins>[ , <var>options</var> ]</ins> )</h1>
      <p>When the <code>SharedArrayBuffer</code> function is called with argument <var>length</var><ins> and optional argument <var>options</var></ins>, the following steps are taken:</p>
      <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>byteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_62"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>length</var>).</li><li><ins>Let <var>requestedMaxByteLength</var> be ?&nbsp;GetArrayBufferMaxByteLengthOption(<var>options</var>).</ins></li><li><ins>If <var>requestedMaxByteLength</var> is <emu-const>empty</emu-const>, then</ins><ol><li><ins>Return ?&nbsp;<emu-xref aoid="AllocateSharedArrayBuffer" id="_ref_63"><a href="#sec-allocatesharedarraybuffer">AllocateSharedArrayBuffer</a></emu-xref>(NewTarget, <var>byteLength</var>).</ins></li></ol></li><li><ins>If <var>byteLength</var> &gt; <var>requestedMaxByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li>Return ?&nbsp;<emu-xref aoid="AllocateSharedArrayBuffer" id="_ref_64"><a href="#sec-allocatesharedarraybuffer">AllocateSharedArrayBuffer</a></emu-xref>(NewTarget, <var>byteLength</var><ins>, <var>requestedMaxByteLength</var></ins>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-sharedarraybuffer-prototype-object-mods">
    <h1><span class="secnum">2.3</span> Modifications to the Properties of the SharedArrayBuffer Prototype Object</h1>

    <emu-clause id="sec-get-sharedarraybuffer.prototype.bytelength">
      <h1><span class="secnum">2.3.1</span> get SharedArrayBuffer.prototype.byteLength</h1>
      <p><code>SharedArrayBuffer.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_65"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_66"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><del>Let <var>length</var> be <var>O</var>.[[ArrayBufferByteLength]].</del></li><li><ins>Let <var>length</var> be <emu-xref aoid="ArrayBufferByteLength" id="_ref_67"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>O</var>, <emu-const>SeqCst</emu-const>).</ins></li><li>Return <emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-get-sharedarraybuffer.prototype.growable">
      <h1><span class="secnum">2.3.2</span> get SharedArrayBuffer.prototype.growable</h1>
      <p><code>SharedArrayBuffer.prototype.growable</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_68"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_69"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <emu-xref aoid="IsResizableArrayBuffer" id="_ref_70"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-sharedarraybuffer.prototype.maxbytelength">
      <h1><span class="secnum">2.3.3</span> get SharedArrayBuffer.prototype.maxByteLength</h1>
      <p><code>SharedArrayBuffer.prototype.maxByteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_71"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_72"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsResizableArrayBuffer" id="_ref_73"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferMaxByteLength]].</li></ol></li><li>Else,<ol><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferByteLength]].</li></ol></li><li>Return <emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-sharedarraybuffer.prototype.grow">
      <h1><span class="secnum">2.3.4</span> SharedArrayBuffer.prototype.grow ( <var>newLength</var> )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_74"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_75"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>newByteLength</var> to ?&nbsp;ToIntegerOrInfinity(<var>newLength</var>).</li><li>Let <var>hostHandled</var> be ?&nbsp;<emu-xref aoid="HostGrowSharedArrayBuffer" id="_ref_76"><a href="#sec-hostgrowsharedarraybuffer">HostGrowSharedArrayBuffer</a></emu-xref>(<var>O</var>, <var>newByteLength</var>).</li><li>If <var>hostHandled</var> is <emu-const>handled</emu-const>, return <emu-val>undefined</emu-val>.</li><li>Let <var>rawCurrentByteLengthBytesRead</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length 8 whose elements are nondeterministically chosen byte values.</li><li>NOTE: In implementations, <var>rawCurrentByteLengthBytesRead</var> is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the <emu-xref href="#sec-memory-model"><a href="https://tc39.es/ecma262/#sec-memory-model">memory model</a></emu-xref> to describe observable behaviour of hardware with weak consistency.</li><li>Let <var>byteLengthBlock</var> be <var>O</var>.[[ArrayBufferByteLengthData]].</li><li>Let <var>isLittleEndian</var> be the value of the [[LittleEndian]] field of the <emu-xref href="#surrounding-agent"><a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a></emu-xref>'s <emu-xref href="#agent-record"><a href="https://tc39.es/ecma262/#agent-record">Agent Record</a></emu-xref>.</li><li>Let <var>currentByteLength</var> be <emu-xref aoid="RawBytesToNumeric" id="_ref_77"><a href="https://tc39.es/ecma262/#sec-rawbytestonumeric">RawBytesToNumeric</a></emu-xref>(<emu-const>BigUint64</emu-const>, <var>rawCurrentByteLengthBytesRead</var>, <var>isLittleEndian</var>).</li><li>Let <var>growFailed</var> be <emu-val>false</emu-val>.</li><li>If <var>newByteLength</var> &lt; <var>currentByteLength</var> or <var>newByteLength</var> &gt; <var>O</var>.[[ArrayBufferMaxByteLength]], set <var>growFailed</var> to <emu-val>true</emu-val>.</li><li>Let <var>byteLengthDelta</var> be <var>newByteLength</var> - <var>currentByteLength</var>.</li><li>If it is impossible to create a new <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> value consisting of <var>byteLengthDelta</var> bytes, set <var>growFailed</var> to <emu-val>true</emu-val>.</li><li>NOTE: No new <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> is constructed and used here. The observable behaviour of growable SharedArrayBuffers is specified by allocating a max-sized <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> at construction time, and this step is intended to capture the requirement that implementations that run out of memory must throw a <emu-val>RangeError</emu-val>.</li><li>NOTE: The above checks help ensure that concurrent calls to SharedArrayBuffer.prototype.grow are totally ordered. For example, consider two racing calls: <code>sab.grow(10)</code> and <code>sab.grow(20)</code>. One of the two calls is guaranteed to win the race. The call to <code>sab.grow(10)</code> will never shrink <code>sab</code> even if <code>sab.grow(20)</code> happened first.</li><li>If <var>growFailed</var> is <emu-val>false</emu-val> and <var>newByteLength</var> ‚â† <var>currentByteLength</var>, then<ol><li>NOTE: Resizes to the same length explicitly do nothing to avoid gratuitous synchronization.</li><li>Let <var>second</var> be a new read-modify-write modification function with parameters (<var>oldBytes</var>, <var>newBytes</var>) that captures nothing and performs the following steps atomically when called:<ol><li>Return <var>newBytes</var>.</li></ol></li><li>Let <var>newByteLengthBytes</var> be <emu-xref aoid="NumericToRawBytes" id="_ref_78"><a href="https://tc39.es/ecma262/#sec-numerictorawbytes">NumericToRawBytes</a></emu-xref>(<emu-const>BigUint64</emu-const>, ‚Ñ§(<var>newByteLength</var>), <var>isLittleEndian</var>).</li><li>Let <var>event</var> be <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">ReadModifyWriteSharedMemory</a></emu-xref> { [[Order]]: <emu-const>SeqCst</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>byteLengthBlock</var>, [[ByteIndex]]: 0, [[ElementSize]]: 8, [[Payload]]: <var>newByteLengthBytes</var>, [[ModifyOp]]: <var>second</var> }.</li><li>NOTE: The new memory is already zeroed, as a <var>O</var>.[[ArrayBufferMaxByteLength]] sized <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> is already allocated. This is a specification mechanism, an implementation is not required to reserve <var>O</var>.[[ArrayBufferMaxByteLength]] bytes of physical memory.</li></ol></li><li>Else,<ol><li>Let <var>event</var> be <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">ReadSharedMemory</a></emu-xref> { [[Order]]: <emu-const>SeqCst</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>byteLengthBlock</var>, [[ByteIndex]]: 0, [[ElementSize]]: 8 }.</li></ol></li><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href="#surrounding-agent"><a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a></emu-xref>'s <emu-xref href="#agent-record"><a href="https://tc39.es/ecma262/#agent-record">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid="AgentSignifier" id="_ref_79"><a href="https://tc39.es/ecma262/#sec-agentsignifier">AgentSignifier</a></emu-xref>().</li><li>Append <var>event</var> to <var>eventList</var>.</li><li>Append <emu-xref href="#sec-chosen-value-records"><a href="https://tc39.es/ecma262/#sec-chosen-value-records">Chosen Value Record</a></emu-xref> { [[Event]]: <var>event</var>, [[ChosenValue]]: <var>rawCurrentBytesLengthBytesRead</var> } to <var>execution</var>.[[ChosenValues]].</li><li>If <var>growFailed</var> is <emu-val>true</emu-val>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>
      <emu-note><span class="note">Note</span><div class="note-contents">
        <p>Spurious failures of the compare-exchange to update the length are prohibited. If the bounds checking for the new length passes and the implementation is not out of memory, a <emu-xref href="#sec-memory-model-fundamentals"><a href="https://tc39.es/ecma262/#sec-memory-model-fundamentals">ReadModifyWriteSharedMemory</a></emu-xref> event (i.e. a successful compare-exchange) is always added into the <emu-xref href="#sec-candidate-executions"><a href="https://tc39.es/ecma262/#sec-candidate-executions">candidate execution</a></emu-xref>.</p>
        <p>Many of the above steps are shared with the algorithm steps of Atomics.compareExchange and should be refactored when merged into the full specification.</p>
      </div></emu-note>
    </emu-clause>
    </ins>

    <emu-clause id="sec-sharedarraybuffer.prototype.slice">
      <h1><span class="secnum">2.3.5</span> SharedArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_80"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_81"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>len</var> be <del><var>O</var>.[[ArrayBufferByteLength]]</del><ins><emu-xref aoid="ArrayBufferByteLength" id="_ref_82"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>O</var>, <emu-const>SeqCst</emu-const>)</ins>.</li><li>Let <var>relativeStart</var> be ?&nbsp;ToIntegerOrInfinity(<var>start</var>).</li><li>If <var>relativeStart</var> is -‚àû, let <var>first</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>first</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>first</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;ToIntegerOrInfinity(<var>end</var>).</li><li>If <var>relativeEnd</var> is -‚àû, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>newLen</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>final</var> - <var>first</var>, 0).</li><li>Let <var>ctor</var> be ?&nbsp;<emu-xref aoid="SpeciesConstructor" id="_ref_83"><a href="https://tc39.es/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>O</var>, <emu-xref href="#sec-sharedarraybuffer-constructor" id="_ref_84"><a href="#sec-sharedarraybuffer-constructor">%SharedArrayBuffer%</a></emu-xref>).</li><li>Let <var>new</var> be ?&nbsp;<emu-xref aoid="Construct" id="_ref_85"><a href="https://tc39.es/ecma262/#sec-construct">Construct</a></emu-xref>(<var>ctor</var>, ¬´ <emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>newLen</var>) ¬ª).</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_86"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>new</var>, [[ArrayBufferData]]).</li><li><ins>NOTE: Unlike ArrayBuffers, SharedArrayBuffers cannot shrink, so the length does not need to be reloaded.</ins></li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_87"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>new</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>new</var>.[[ArrayBufferData]] and <var>O</var>.[[ArrayBufferData]] are the same <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> values, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>new</var>.[[ArrayBufferByteLength]] &lt; <var>newLen</var>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>fromBuf</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBuf</var> be <var>new</var>.[[ArrayBufferData]].</li><li>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_88"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBuf</var>, 0, <var>fromBuf</var>, <var>first</var>, <var>newLen</var>).</li><li>Return <var>new</var>.</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-integer-indexed-exotic-objects-mods">
  <h1><span class="secnum">3</span> Modifications to Integer-Indexed Exotic Objects</h1>

  <emu-clause id="sec-integer-indexed-exotic-objects-ownpropertykeys">
    <h1><span class="secnum">3.1</span> [[OwnPropertyKeys]] ( )</h1>
    <p>The [[OwnPropertyKeys]] internal method of an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref> <var>O</var> takes no arguments. It performs the following steps when called:</p>
    <emu-alg><ol><li>Let <var>keys</var> be a new empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li><del>If <emu-xref aoid="IsDetachedBuffer" id="_ref_89"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>.[[ViewedArrayBuffer]]) is <emu-val>false</emu-val>, then</del><ol><li><del>For each <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> <var>i</var> starting with 0 such that <var>i</var> &lt; <var>O</var>.[[ArrayLength]], in ascending order, do</del><ol><li><del>Add !&nbsp;<emu-xref aoid="ToString" id="_ref_90"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>i</var>)) as the last element of <var>keys</var>.</del></li></ol></li></ol></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_91"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>Let <var>len</var> be <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_92"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins></li><li><ins>If <var>len</var> is not <emu-const>out-of-bounds</emu-const>, then</ins><ol><li><ins>For each <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> <var>i</var> starting with 0 such that <var>i</var> &lt; <var>len</var>, in ascending order, do</ins><ol><li><ins>Add !&nbsp;<emu-xref aoid="ToString" id="_ref_93"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>i</var>)) as the last element of <var>keys</var>.</ins></li></ol></li></ol></li><li>For each own property key <var>P</var> of <var>O</var> such that <emu-xref aoid="Type" id="_ref_94"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>P</var>) is String and <var>P</var> is not an <emu-xref href="#integer-index"><a href="https://tc39.es/ecma262/#integer-index">integer index</a></emu-xref>, in ascending chronological order of property creation, do<ol><li>Add <var>P</var> as the last element of <var>keys</var>.</li></ol></li><li>For each own property key <var>P</var> of <var>O</var> such that <emu-xref aoid="Type" id="_ref_95"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>P</var>) is Symbol, in ascending chronological order of property creation, do<ol><li>Add <var>P</var> as the last element of <var>keys</var>.</li></ol></li><li>Return <var>keys</var>.</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-isvalidintegerindex" type="abstract operation" aoid="IsValidIntegerIndex">
    <h1><span class="secnum">3.2</span> IsValidIntegerIndex ( <var>O</var>, <var>index</var> )</h1>
    <p>The abstract operation IsValidIntegerIndex takes arguments <var>O</var> (an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>) and <var>index</var> (a Number). It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li><del>If <emu-xref aoid="IsDetachedBuffer" id="_ref_96"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>.[[ViewedArrayBuffer]]) is <emu-val>true</emu-val>, return <emu-val>false</emu-val>.</del></li><li>If !&nbsp;IsIntegralNumber(<var>index</var>) is <emu-val>false</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>index</var> is <emu-val>-0</emu-val><sub>ùîΩ</sub>, return <emu-val>false</emu-val>.</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_97"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>O</var>'s backing buffer is a growable SharedArrayBuffer.</ins></li><li><ins>Let <var>length</var> be <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_98"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins></li><li>If <ins><var>length</var> is <emu-const>out-of-bounds</emu-const> or</ins> <emu-xref href="#‚Ñù"><a href="https://tc39.es/ecma262/#‚Ñù">‚Ñù</a></emu-xref>(<var>index</var>) &lt; 0 or <emu-xref href="#‚Ñù"><a href="https://tc39.es/ecma262/#‚Ñù">‚Ñù</a></emu-xref>(<var>index</var>) ‚â• <del><var>O</var>.[[ArrayLength]]</del><ins><var>length</var></ins>, return <emu-val>false</emu-val>.</li><li>Return <emu-val>true</emu-val>.</li></ol></emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-integerindexedobjectbytelength" type="abstract operation" aoid="IntegerIndexedObjectByteLength">
    <h1><span class="secnum">3.3</span> IntegerIndexedObjectByteLength ( <var>O</var>, <var>getBufferByteLength</var> )</h1>
    <p>The abstract operation IntegerIndexedObjectByteLength takes arguments <var>O</var> (an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>) and <var>getBufferByteLength</var> (an Abstract Closure). It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li>Let <var>length</var> be <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_99"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</li><li>If <var>length</var> is <emu-const>out-of-bounds</emu-const> or <var>length</var> = 0, return 0.</li><li>If <var>O</var>.[[ByteLength]] is not <emu-const>auto</emu-const>, return <var>O</var>.[[ByteLength]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>O</var>.[[TypedArrayName]].</li><li>Return <var>length</var> √ó <var>elementSize</var>.</li></ol></emu-alg>
    </emu-clause>

  <emu-clause id="sec-integerindexedobjectlength" type="abstract operation" aoid="IntegerIndexedObjectLength">
    <h1><span class="secnum">3.4</span> IntegerIndexedObjectLength ( <var>O</var>, <var>getBufferByteLength</var> )</h1>
    <p>The abstract operation IntegerIndexedObjectLength takes arguments <var>O</var> (an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>) and <var>getBufferByteLength</var> (an Abstract Closure). It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_100"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, return <emu-const>out-of-bounds</emu-const>.</li><li>If <var>O</var>.[[ArrayLength]] is not <emu-const>auto</emu-const>, return <var>O</var>.[[ArrayLength]].</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>Let <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="IsResizableArrayBuffer" id="_ref_101"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>.</li><li>Let <var>byteOffset</var> be <var>O</var>.[[ByteOffset]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>O</var>.[[TypedArrayName]].</li><li>Let <var>length</var> be <emu-xref aoid="floor"><a href="https://tc39.es/ecma262/#eqn-floor">floor</a></emu-xref>((<var>bufferByteLength</var> - <var>byteOffset</var>) / <var>elementSize</var>).</li><li>Return <var>length</var>.</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-isintegerindexedobjectoutofbounds" type="abstract operation" aoid="IsIntegerIndexedObjectOutOfBounds">
    <h1><span class="secnum">3.5</span> IsIntegerIndexedObjectOutOfBounds ( <var>O</var>, <var>getBufferByteLength</var> )</h1>
    <p>The abstract operation IsIntegerIndexedObjectOutOfBounds takes arguments <var>O</var> (an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>) and <var>getBufferByteLength</var> (an Abstract Closure). It checks if any of the object's numeric properties reference a value at an index not contained within the underlying data block's bounds. It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_102"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>.[[ViewedArrayBuffer]]) is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li><li>Let <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</li><li>Let <var>byteOffsetStart</var> be <var>O</var>.[[ByteOffset]].</li><li>If <var>O</var>.[[ArrayLength]] is <emu-const>auto</emu-const>, then<ol><li>Let <var>byteOffsetEnd</var> be <var>bufferByteLength</var>.</li></ol></li><li>Else,<ol><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>O</var>.[[TypedArrayName]].</li><li>Let <var>byteOffsetEnd</var> be <var>byteOffsetStart</var> + <var>O</var>.[[ArrayLength]] √ó <var>elementSize</var>.</li></ol></li><li>If <var>byteOffsetStart</var> &gt; <var>bufferByteLength</var> or <var>byteOffsetEnd</var> &gt; <var>bufferByteLength</var>, then return <emu-val>true</emu-val>.</li><li>NOTE: 0-length TypedArrays are not considered out-of-bounds.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
  </emu-clause>
  </ins>
</emu-clause>

<emu-clause id="sec-typedarray-objects-mods">
  <h1><span class="secnum">4</span> Modifications to TypedArray Objects</h1>

  <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object-mods">
    <h1><span class="secnum">4.1</span> Modifications to Properties of the %TypedArray.prototype% Object</h1>

    <emu-clause id="sec-validatetypedarray" type="abstract operation" aoid="ValidateTypedArray">
      <h1><span class="secnum">4.1.1</span> ValidateTypedArray ( <var>O</var> )</h1>
      <p>The abstract operation ValidateTypedArray takes argument <var>O</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_103"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer" id="_ref_104"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_105"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_106"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Return <var>buffer</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.bytelength">
      <h1><span class="secnum">4.1.2</span> get %TypedArray%.prototype.byteLength</h1>
      <p><emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_107"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_108"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>ùîΩ</sub>.</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_109"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>size</var> be <del><var>O</var>.[[ByteLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectByteLength" id="_ref_110"><a href="#sec-integerindexedobjectbytelength">IntegerIndexedObjectByteLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Return <emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>size</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.byteoffset">
      <h1><span class="secnum">4.1.3</span> get %TypedArray%.prototype.byteOffset</h1>
      <p><emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.byteOffset</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_111"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer" id="_ref_112"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>ùîΩ</sub>.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_113"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_114"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>ùîΩ</sub>.</ins></li><li>Let <var>offset</var> be <var>O</var>.[[ByteOffset]].</li><li>Return <emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>offset</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.length">
      <h1><span class="secnum">4.1.4</span> get %TypedArray%.prototype.length</h1>
      <p><emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.length</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_115"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer" id="_ref_116"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>ùîΩ</sub>.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_117"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>length</var> be <del><var>O</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_118"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li><ins>If <var>length</var> is <emu-const>out-of-bounds</emu-const>, set <var>length</var> to 0.</ins></li><li>Return <emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
      <p>This function is not generic. The <emu-val>this</emu-val> value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-%typedarray%.prototype.copywithin">
      <h1><span class="secnum">4.1.5</span> %TypedArray%.prototype.copyWithin ( <var>target</var>, <var>start</var> [ , <var>end</var> ] )</h1>
      <p>The interpretation and use of the arguments of <emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.copyWithin</code> are the same as for <code>Array.prototype.copyWithin</code> as defined in <emu-xref href="#sec-array.prototype.copywithin"><a href="https://tc39.es/ecma262/#sec-array.prototype.copywithin">22.1.3.3</a></emu-xref>.</p>
      <p>When the <code>copyWithin</code> method is called, the following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="ValidateTypedArray" id="_ref_119"><a href="#sec-validatetypedarray">ValidateTypedArray</a></emu-xref>(<var>O</var>).</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_120"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>len</var> be <del><var>O</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_121"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins>.</li><li><ins><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>len</var> is not <emu-const>out-of-bounds</emu-const>.</ins></li><li>Let <var>relativeTarget</var> be ?&nbsp;ToIntegerOrInfinity(<var>target</var>).</li><li>If <var>relativeTarget</var> is -‚àû, let <var>to</var> be 0.</li><li>Else if <var>relativeTarget</var> &lt; 0, let <var>to</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeTarget</var>, 0).</li><li>Else, let <var>to</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeTarget</var>, <var>len</var>).</li><li>Let <var>relativeStart</var> be ?&nbsp;ToIntegerOrInfinity(<var>start</var>).</li><li>If <var>relativeStart</var> is -‚àû, let <var>from</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>from</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>from</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;ToIntegerOrInfinity(<var>end</var>).</li><li>If <var>relativeEnd</var> is -‚àû, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>count</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>final</var> - <var>from</var>, <var>len</var> - <var>to</var>).</li><li>If <var>count</var> &gt; 0, then<ol><li>NOTE: The copying must be performed in a manner that preserves the bit-level encoding of the source data.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><ins>Set <var>getBufferByteLength</var> to <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_122"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>Set <var>len</var> to <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_123"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins></li><li>If <del><emu-xref aoid="IsDetachedBuffer" id="_ref_124"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val></del><ins><var>len</var> is <emu-const>out-of-bounds</emu-const></ins>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>typedArrayName</var> be the String value of <var>O</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>typedArrayName</var>.</li><li><ins>Let <var>bufferByteLen</var> be <var>len</var> √ó <var>elementSize</var>.</ins></li><li>Let <var>byteOffset</var> be <var>O</var>.[[ByteOffset]].</li><li>Let <var>toByteIndex</var> be <var>to</var> √ó <var>elementSize</var> + <var>byteOffset</var>.</li><li>Let <var>fromByteIndex</var> be <var>from</var> √ó <var>elementSize</var> + <var>byteOffset</var>.</li><li>Let <var>countBytes</var> be <var>count</var> √ó <var>elementSize</var>.</li><li>If <var>fromByteIndex</var> &lt; <var>toByteIndex</var> and <var>toByteIndex</var> &lt; <var>fromByteIndex</var> + <var>countBytes</var>, then<ol><li>Let <var>direction</var> be -1.</li><li>Set <var>fromByteIndex</var> to <var>fromByteIndex</var> + <var>countBytes</var> - 1.</li><li>Set <var>toByteIndex</var> to <var>toByteIndex</var> + <var>countBytes</var> - 1.</li></ol></li><li>Else,<ol><li>Let <var>direction</var> be 1.</li></ol></li><li>Repeat, while <var>countBytes</var> &gt; 0,<ol><li><ins>If <var>fromByteIndex</var> &lt; <var>bufferByteLen</var> and <var>toByteIndex</var> &lt; <var>bufferByteLen</var>, then</ins><ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer" id="_ref_125"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>buffer</var>, <var>fromByteIndex</var>, <emu-const>Uint8</emu-const>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_126"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>buffer</var>, <var>toByteIndex</var>, <emu-const>Uint8</emu-const>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>fromByteIndex</var> to <var>fromByteIndex</var> + <var>direction</var>.</li><li>Set <var>toByteIndex</var> to <var>toByteIndex</var> + <var>direction</var>.</li></ol></li><li>Set <var>countBytes</var> to <var>countBytes</var> - 1.</li></ol></li></ol></li><li>Return <var>O</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-%typedarray%.prototype.fill">
      <h1><span class="secnum">4.1.6</span> %TypedArray%.prototype.fill ( <var>value</var> [ , <var>start</var> [ , <var>end</var> ] ] )</h1>
      <p>The interpretation and use of the arguments of <emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.fill</code> are the same as for <code>Array.prototype.fill</code> as defined in <emu-xref href="#sec-array.prototype.fill"><a href="https://tc39.es/ecma262/#sec-array.prototype.fill">22.1.3.6</a></emu-xref>.</p>
      <p>When the <code>fill</code> method is called, the following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="ValidateTypedArray" id="_ref_127"><a href="#sec-validatetypedarray">ValidateTypedArray</a></emu-xref>(<var>O</var>).</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_128"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>len</var> be <del><var>O</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_129"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins>.</li><li><ins><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>len</var> is not <emu-const>out-of-bounds</emu-const>.</ins></li><li>If <var>O</var>.[[ContentType]] is <emu-const>BigInt</emu-const>, set <var>value</var> to ?&nbsp;<emu-xref aoid="ToBigInt" id="_ref_130"><a href="https://tc39.es/ecma262/#sec-tobigint">ToBigInt</a></emu-xref>(<var>value</var>).</li><li>Otherwise, set <var>value</var> to ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_131"><a href="https://tc39.es/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>value</var>).</li><li>Let <var>relativeStart</var> be ?&nbsp;ToIntegerOrInfinity(<var>start</var>).</li><li>If <var>relativeStart</var> is -‚àû, let <var>k</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>k</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>k</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;ToIntegerOrInfinity(<var>end</var>).</li><li>If <var>relativeEnd</var> is -‚àû, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_132"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>.[[ViewedArrayBuffer]]) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Set <var>getBufferByteLength</var> to <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_133"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>Set <var>len</var> to <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_134"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins></li><li><ins>If <var>len</var> is <emu-const>out-of-bounds</emu-const>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li><ins>Set <var>final</var> to <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>final</var>, <var>len</var>).</ins></li><li>Repeat, while <var>k</var> &lt; <var>final</var>,<ol><li>Let <var>Pk</var> be !&nbsp;<emu-xref aoid="ToString" id="_ref_135"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>k</var>)).</li><li>Perform !&nbsp;<emu-xref aoid="Set" id="_ref_136"><a href="https://tc39.es/ecma262/#sec-set-o-p-v-throw">Set</a></emu-xref>(<var>O</var>, <var>Pk</var>, <var>value</var>, <emu-val>true</emu-val>).</li><li>Set <var>k</var> to <var>k</var> + 1.</li></ol></li><li>Return <var>O</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-settypedarrayfromarraylike" type="abstract operation" oldids="sec-%typedarray%.prototype.set-array-offset" aoid="SetTypedArrayFromArrayLike"><span id="sec-%typedarray%.prototype.set-array-offset"></span>
      <h1><span class="secnum">4.1.7</span> SetTypedArrayFromArrayLike ( <var>target</var>, <var>targetOffset</var>, <var>source</var> )</h1>
      <p>The abstract operation SetTypedArrayFromArrayLike takes arguments <var>target</var> (a TypedArray), <var>targetOffset</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> or +‚àû), and <var>source</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>, but not a TypedArray). It sets multiple values in <var>target</var>, starting at index <var>targetOffset</var>, reading the values from <var>source</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li>Let <var>targetBuffer</var> be <var>target</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_137"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>targetBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>targetLength</var> be <var>target</var>.[[ArrayLength]].</li><li><del>Let <var>targetName</var> be the String value of <var>target</var>.[[TypedArrayName]].</del></li><li><del>Let <var>targetElementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>targetName</var>.</del></li><li><del>Let <var>targetType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>targetName</var>.</del></li><li><del>Let <var>targetByteOffset</var> be <var>target</var>.[[ByteOffset]].</del></li><li>Let <var>src</var> be ?&nbsp;<emu-xref aoid="ToObject" id="_ref_138"><a href="https://tc39.es/ecma262/#sec-toobject">ToObject</a></emu-xref>(<var>source</var>).</li><li>Let <var>srcLength</var> be ?&nbsp;<emu-xref aoid="LengthOfArrayLike" id="_ref_139"><a href="https://tc39.es/ecma262/#sec-lengthofarraylike">LengthOfArrayLike</a></emu-xref>(<var>src</var>).</li><li>If <var>targetOffset</var> is +‚àû, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>srcLength</var> + <var>targetOffset</var> &gt; <var>targetLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li><del>Let <var>targetByteIndex</var> be <var>targetOffset</var> √ó <var>targetElementSize</var> + <var>targetByteOffset</var>.</del></li><li><del>Let <var>limit</var> be <var>targetByteIndex</var> + <var>targetElementSize</var> √ó <var>srcLength</var>.</del></li><li>Let <var>k</var> be 0.</li><li>Repeat, while <del><var>targetByteIndex</var></del><ins><var>k</var></ins> &lt; <del><var>limit</var></del><ins><var>srcLength</var></ins>,<ol><li>Let <var>Pk</var> be !&nbsp;<emu-xref aoid="ToString" id="_ref_140"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>k</var>)).</li><li>Let <var>value</var> be ?&nbsp;<emu-xref aoid="Get" id="_ref_141"><a href="https://tc39.es/ecma262/#sec-get-o-p">Get</a></emu-xref>(<var>src</var>, <var>Pk</var>).</li><li><del>If <var>target</var>.[[ContentType]] is <emu-const>BigInt</emu-const>, set <var>value</var> to ?&nbsp;<emu-xref aoid="ToBigInt" id="_ref_142"><a href="https://tc39.es/ecma262/#sec-tobigint">ToBigInt</a></emu-xref>(<var>value</var>).</del></li><li><del>Otherwise, set <var>value</var> to ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_143"><a href="https://tc39.es/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>value</var>).</del></li><li><del>If <emu-xref aoid="IsDetachedBuffer" id="_ref_144"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>targetBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><del>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_145"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <var>targetType</var>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</del></li><li><ins>Let <var>targetIndex</var> be !&nbsp;<emu-xref aoid="ToString" id="_ref_146"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>targetOffset</var> + <var>k</var>)).</ins></li><li><ins>Perform ?&nbsp;<emu-xref aoid="Set" id="_ref_147"><a href="https://tc39.es/ecma262/#sec-set-o-p-v-throw">Set</a></emu-xref>(<var>target</var>, <var>targetIndex</var>, <var>value</var>, <emu-val>true</emu-val>).</ins></li><li>Set <var>k</var> to <var>k</var> + 1.</li><li><del>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + <var>targetElementSize</var>.</del></li></ol></li></ol></emu-alg>
      <emu-note type="editor"><span class="note">Editor's Note</span><div class="note-contents">This AO is used when <emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref>.prototype.set is passed an Array-like value. The above change is currently being proposed <a href="https://github.com/tc39/ecma262/pull/2646">upstream</a>.</div></emu-note>
    </emu-clause>

    <emu-clause id="sec-%typedarray%.prototype.slice">
      <h1><span class="secnum">4.1.8</span> %TypedArray%.prototype.slice ( <var>start</var>, <var>end</var> )</h1>
      <p>The interpretation and use of the arguments of <emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.slice</code> are the same as for <code>Array.prototype.slice</code> as defined in <emu-xref href="#sec-array.prototype.slice"><a href="https://tc39.es/ecma262/#sec-array.prototype.slice">22.1.3.25</a></emu-xref>. The following steps are taken:</p>
      <p>When the <code>slice</code> method is called, the following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="ValidateTypedArray" id="_ref_148"><a href="#sec-validatetypedarray">ValidateTypedArray</a></emu-xref>(<var>O</var>).</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_149"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>len</var> be <del><var>O</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_150"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins>.</li><li>Let <var>relativeStart</var> be ?&nbsp;ToIntegerOrInfinity(<var>start</var>).</li><li>If <var>relativeStart</var> is -‚àû, let <var>k</var> be 0.</li><li>Else if <var>relativeStart</var> &lt; 0, let <var>k</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeStart</var>, 0).</li><li>Else, let <var>k</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ?&nbsp;ToIntegerOrInfinity(<var>end</var>).</li><li>If <var>relativeEnd</var> is -‚àû, let <var>final</var> be 0.</li><li>Else if <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>len</var> + <var>relativeEnd</var>, 0).</li><li>Else, let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>count</var> be <emu-xref aoid="max"><a href="https://tc39.es/ecma262/#eqn-max">max</a></emu-xref>(<var>final</var> - <var>k</var>, 0).</li><li>Let <var>A</var> be ?&nbsp;<emu-xref aoid="TypedArraySpeciesCreate" id="_ref_151"><a href="https://tc39.es/ecma262/#typedarray-species-create">TypedArraySpeciesCreate</a></emu-xref>(<var>O</var>, ¬´ <emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>count</var>) ¬ª).</li><li>If <var>count</var> &gt; 0, then<ol><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_152"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>.[[ViewedArrayBuffer]]) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Set <var>getBufferByteLength</var> to <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_153"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>Set <var>len</var> to <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_154"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins></li><li><ins>If <var>len</var> is <emu-const>out-of-bounds</emu-const>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li><ins>Set <var>final</var> to <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>final</var>, <var>len</var>).</ins></li><li>Let <var>srcName</var> be the String value of <var>O</var>.[[TypedArrayName]].</li><li>Let <var>srcType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>targetName</var> be the String value of <var>A</var>.[[TypedArrayName]].</li><li>Let <var>targetType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>targetName</var>.</li><li>If <var>srcType</var> is different from <var>targetType</var>, then<ol><li>Let <var>n</var> be 0.</li><li>Repeat, while <var>k</var> &lt; <var>final</var>,<ol><li>Let <var>Pk</var> be !&nbsp;<emu-xref aoid="ToString" id="_ref_155"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>k</var>)).</li><li>Let <var>kValue</var> be !&nbsp;<emu-xref aoid="Get" id="_ref_156"><a href="https://tc39.es/ecma262/#sec-get-o-p">Get</a></emu-xref>(<var>O</var>, <var>Pk</var>).</li><li>Perform !&nbsp;<emu-xref aoid="Set" id="_ref_157"><a href="https://tc39.es/ecma262/#sec-set-o-p-v-throw">Set</a></emu-xref>(<var>A</var>, !&nbsp;<emu-xref aoid="ToString" id="_ref_158"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>n</var>)), <var>kValue</var>, <emu-val>true</emu-val>).</li><li>Set <var>k</var> to <var>k</var> + 1.</li><li>Set <var>n</var> to <var>n</var> + 1.</li></ol></li></ol></li><li>Else,<ol><li>Let <var>srcBuffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>Let <var>targetBuffer</var> be <var>A</var>.[[ViewedArrayBuffer]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for Element Type <var>srcType</var>.</li><li>NOTE: If <var>srcType</var> and <var>targetType</var> are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.</li><li>Let <var>srcByteOffset</var> be <var>O</var>.[[ByteOffset]].</li><li>Let <var>targetByteIndex</var> be <var>A</var>.[[ByteOffset]].</li><li>Let <var>srcByteIndex</var> be (<var>k</var> √ó <var>elementSize</var>) + <var>srcByteOffset</var>.</li><li>Let <var>limit</var> be <ins><emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(</ins><var>targetByteIndex</var> + <var>count</var> √ó <var>elementSize</var><ins>, <var>len</var> √ó <var>elementSize</var>)</ins>.</li><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var>,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer" id="_ref_159"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <emu-const>Uint8</emu-const>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_160"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <emu-const>Uint8</emu-const>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + 1.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + 1.</li></ol></li></ol></li></ol></li><li>Return <var>A</var>.</li></ol></emu-alg>
      <p>This function is not generic. The <emu-val>this</emu-val> value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-%typedarray%.prototype.sort">
      <h1><span class="secnum">4.1.9</span> %TypedArray%.prototype.sort ( <var>comparefn</var> )</h1>
      <p><emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.sort</code> is a distinct function that, except as described below, implements the same requirements as those of <code>Array.prototype.sort</code> as defined in <emu-xref href="#sec-array.prototype.sort"><a href="https://tc39.es/ecma262/#sec-array.prototype.sort">22.1.3.27</a></emu-xref>. The implementation of the <emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.sort</code> specification may be optimized with the knowledge that the <emu-val>this</emu-val> value is an object that has a fixed length and whose <emu-xref href="#integer-index"><a href="https://tc39.es/ecma262/#integer-index">integer-indexed</a></emu-xref> properties are not sparse.</p>
      <p>This function is not generic. The <emu-val>this</emu-val> value must be an object with a [[TypedArrayName]] internal slot.</p>
      <p>Upon entry, the following steps are performed to initialize evaluation of the <code>sort</code> function. These steps are used instead of steps <emu-xref href="#step-array-sort-comparefn"></emu-xref>‚Äì<emu-xref href="#step-array-sort-len"></emu-xref> in <emu-xref href="#sec-array.prototype.sort"><a href="https://tc39.es/ecma262/#sec-array.prototype.sort">22.1.3.27</a></emu-xref>:</p>
      <emu-alg><ol><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val> and <emu-xref aoid="IsCallable" id="_ref_161"><a href="https://tc39.es/ecma262/#sec-iscallable">IsCallable</a></emu-xref>(<var>comparefn</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>obj</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="ValidateTypedArray" id="_ref_162"><a href="#sec-validatetypedarray">ValidateTypedArray</a></emu-xref>(<var>obj</var>).</li><li>Let <var>buffer</var> be <var>obj</var>.[[ViewedArrayBuffer]].</li><li>Let <var>len</var> be <var>obj</var>.[[ArrayLength]].</li></ol></emu-alg>
      <p>The following version of <emu-xref aoid="SortCompare" id="_ref_163"><a href="https://tc39.es/ecma262/#sec-sortcompare">SortCompare</a></emu-xref> is used by <emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.sort</code>. It performs a numeric comparison rather than the string comparison used in <emu-xref href="#sec-array.prototype.sort"><a href="https://tc39.es/ecma262/#sec-array.prototype.sort">22.1.3.27</a></emu-xref>.</p>
      <p>The abstract operation TypedArraySortCompare takes arguments <var>x</var> and <var>y</var>. It also has access to the <ins><var>obj</var>, </ins><var>comparefn</var><ins>,</ins> and <var>buffer</var> values of the current invocation of the <code>sort</code> method. It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: Both <emu-xref aoid="Type" id="_ref_164"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) and <emu-xref aoid="Type" id="_ref_165"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>y</var>) are Number or both are BigInt.</li><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>v</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_166"><a href="https://tc39.es/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(? <emu-xref aoid="Call" id="_ref_167"><a href="https://tc39.es/ecma262/#sec-call">Call</a></emu-xref>(<var>comparefn</var>, <emu-val>undefined</emu-val>, ¬´ <var>x</var>, <var>y</var> ¬ª)).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_168"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_169"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_170"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>obj</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>If <var>v</var> is <emu-val>NaN</emu-val>, return <emu-val>+0</emu-val><sub>ùîΩ</sub>.</li><li>Return <var>v</var>.</li></ol></li><li>If <var>x</var> and <var>y</var> are both <emu-val>NaN</emu-val>, return <emu-val>+0</emu-val><sub>ùîΩ</sub>.</li><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>1</emu-val><sub>ùîΩ</sub>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>-1</emu-val><sub>ùîΩ</sub>.</li><li>If <var>x</var> &lt; <var>y</var>, return <emu-val>-1</emu-val><sub>ùîΩ</sub>.</li><li>If <var>x</var> &gt; <var>y</var>, return <emu-val>1</emu-val><sub>ùîΩ</sub>.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>ùîΩ</sub> and <var>y</var> is <emu-val>+0</emu-val><sub>ùîΩ</sub>, return <emu-val>-1</emu-val><sub>ùîΩ</sub>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>ùîΩ</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>ùîΩ</sub>, return <emu-val>1</emu-val><sub>ùîΩ</sub>.</li><li>Return <emu-val>+0</emu-val><sub>ùîΩ</sub>.</li></ol></emu-alg>
      <emu-note><span class="note">Note</span><div class="note-contents">
        <p>Because <emu-val>NaN</emu-val> always compares greater than any other value, <emu-val>NaN</emu-val> property values always sort to the end of the result when <var>comparefn</var> is not provided.</p>
      </div></emu-note>
    </emu-clause>

    <emu-clause id="sec-settypedarrayfromtypedarray" type="abstract operation" oldids="sec-%typedarray%.prototype.set-typedarray-offset" aoid="SetTypedArrayFromTypedArray"><span id="sec-%typedarray%.prototype.set-typedarray-offset"></span>
      <h1><span class="secnum">4.1.10</span> SetTypedArrayFromTypedArray ( <var>target</var>, <var>targetOffset</var>, <var>source</var> )</h1>
      <p>The abstract operation SetTypedArrayFromTypedArray takes arguments <var>target</var> (a TypedArray), <var>targetOffset</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> or +‚àû), and <var>source</var> (a TypedArray). It sets multiple values in <var>target</var>, starting at index <var>targetOffset</var>, reading the values from <var>source</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>source</var> is an Object that has a [[TypedArrayName]] internal slot.</li><li>Let <var>targetBuffer</var> be <var>target</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_171"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>targetBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getSrcBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_172"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>targetLength</var> be <del><var>target</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_173"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>target</var>, <var>getSrcBufferByteLength</var>)</ins>.</li><li><ins>If <var>targetLength</var> is <emu-const>out-of-bounds</emu-const>, set <var>targetLength</var> to 0.</ins></li><li>Let <var>srcBuffer</var> be <var>source</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer" id="_ref_174"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>srcBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_175"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>target</var>, <var>getSrcBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>targetName</var> be the String value of <var>target</var>.[[TypedArrayName]].</li><li>Let <var>targetType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetElementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetByteOffset</var> be <var>target</var>.[[ByteOffset]].</li><li>Let <var>srcName</var> be the String value of <var>source</var>.[[TypedArrayName]].</li><li>Let <var>srcType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcElementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcLength</var> be <var>source</var>.[[ArrayLength]].</li><li>Let <var>srcByteOffset</var> be <var>source</var>.[[ByteOffset]].</li><li>If <var>targetOffset</var> is +‚àû, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>srcLength</var> + <var>targetOffset</var> &gt; <var>targetLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>target</var>.[[ContentType]] ‚â† <var>source</var>.[[ContentType]], throw a <emu-val>TypeError</emu-val> exception.</li><li>If both <emu-xref aoid="IsSharedArrayBuffer" id="_ref_176"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>srcBuffer</var>) and <emu-xref aoid="IsSharedArrayBuffer" id="_ref_177"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>targetBuffer</var>) are <emu-val>true</emu-val>, then<ol><li>If <var>srcBuffer</var>.[[ArrayBufferData]] and <var>targetBuffer</var>.[[ArrayBufferData]] are the same <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> values, let <var>same</var> be <emu-val>true</emu-val>; else let <var>same</var> be <emu-val>false</emu-val>.</li></ol></li><li>Else, let <var>same</var> be <emu-xref aoid="SameValue" id="_ref_178"><a href="https://tc39.es/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcBuffer</var>, <var>targetBuffer</var>).</li><li>If <var>same</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>srcByteLength</var> be <del><var>source</var>.[[ByteLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectByteLength" id="_ref_179"><a href="#sec-integerindexedobjectbytelength">IntegerIndexedObjectByteLength</a></emu-xref>(<var>source</var>, <var>getSrcBufferByteLength</var>)</ins>.</li><li>Set <var>srcBuffer</var> to ?&nbsp;<emu-xref aoid="CloneArrayBuffer" id="_ref_180"><a href="https://tc39.es/ecma262/#sec-clonearraybuffer">CloneArrayBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteOffset</var>, <var>srcByteLength</var>, <emu-xref href="#sec-arraybuffer-constructor" id="_ref_181"><a href="#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li><li>NOTE: <emu-xref href="#sec-arraybuffer-constructor" id="_ref_182"><a href="#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref> is used to clone <var>srcBuffer</var> because is it known to not have any observable side-effects.</li><li>Let <var>srcByteIndex</var> be 0.</li></ol></li><li>Else, let <var>srcByteIndex</var> be <var>srcByteOffset</var>.</li><li>Let <var>targetByteIndex</var> be <var>targetOffset</var> √ó <var>targetElementSize</var> + <var>targetByteOffset</var>.</li><li>Let <var>limit</var> be <var>targetByteIndex</var> + <var>targetElementSize</var> √ó <var>srcLength</var>.</li><li>If <var>srcType</var> is the same as <var>targetType</var>, then<ol><li>NOTE: If <var>srcType</var> and <var>targetType</var> are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.</li><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var>,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer" id="_ref_183"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <emu-const>Uint8</emu-const>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_184"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <emu-const>Uint8</emu-const>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + 1.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + 1.</li></ol></li></ol></li><li>Else,<ol><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var>,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer" id="_ref_185"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <var>srcType</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_186"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <var>targetType</var>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + <var>srcElementSize</var>.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + <var>targetElementSize</var>.</li></ol></li></ol></li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-constructors-mods">
    <h1><span class="secnum">4.2</span> Modifications to the <var>TypedArray</var> Constructors</h1>

    <emu-clause id="sec-initializetypedarrayfromtypedarray" type="abstract operation" oldids="sec-typedarray-typedarray" aoid="InitializeTypedArrayFromTypedArray"><span id="sec-typedarray-typedarray"></span>
      <h1><span class="secnum">4.2.1</span> InitializeTypedArrayFromTypedArray ( <var>O</var>, <var>srcArray</var> )</h1>
      <p>The abstract operation InitializeTypedArrayFromTypedArray takes arguments <var>O</var> (a TypedArray) and <var>srcArray</var> (a TypedArray). It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an Object that has a [[TypedArrayName]] internal slot.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>srcArray</var> is an Object that has a [[TypedArrayName]] internal slot.</li><li>Let <var>srcData</var> be <var>srcArray</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_187"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>srcData</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>constructorName</var> be the String value of <var>O</var>.[[TypedArrayName]].</li><li>Let <var>elementType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>constructorName</var>.</li><li><ins>Let <var>getSrcBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_188"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>elementLength</var> be <del><var>srcArray</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_189"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>srcArray</var>, <var>getSrcBufferByteLength</var>)</ins>.</li><li><ins>If <var>elementLength</var> is <emu-const>out-of-bounds</emu-const>, set <var>elementLength</var> to 0.</ins></li><li>Let <var>srcName</var> be the String value of <var>srcArray</var>.[[TypedArrayName]].</li><li>Let <var>srcType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcElementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcByteOffset</var> be <var>srcArray</var>.[[ByteOffset]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>constructorName</var>.</li><li>Let <var>byteLength</var> be <var>elementSize</var> √ó <var>elementLength</var>.</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_190"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>srcData</var>) is <emu-val>false</emu-val>, then<ol><li>Let <var>bufferConstructor</var> be ?&nbsp;<emu-xref aoid="SpeciesConstructor" id="_ref_191"><a href="https://tc39.es/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>srcData</var>, <emu-xref href="#sec-arraybuffer-constructor" id="_ref_192"><a href="#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li></ol></li><li>Else,<ol><li>Let <var>bufferConstructor</var> be <emu-xref href="#sec-arraybuffer-constructor" id="_ref_193"><a href="#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>.</li></ol></li><li><ins>Let <var>data</var> be ?&nbsp;<emu-xref aoid="AllocateArrayBuffer" id="_ref_194"><a href="#sec-allocatearraybuffer">AllocateArrayBuffer</a></emu-xref>(<var>bufferConstructor</var>, <var>byteLength</var>).</ins></li><li><ins>Set <var>getSrcBufferByteLength</var> to <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_195"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_196"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>srcArray</var>, <var>getSrcBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li><ins>Set <var>elementLength</var> to <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_197"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>srcArray</var>, <var>getSrcBufferByteLength</var>).</ins></li><li><ins>Set <var>byteLength</var> to <var>elementSize</var> √ó <var>elementLength</var>.</ins></li><li>If <var>elementType</var> is the same as <var>srcType</var>, then<ol><li><del>Let <var>data</var> be ?&nbsp;<emu-xref aoid="CloneArrayBuffer" id="_ref_198"><a href="https://tc39.es/ecma262/#sec-clonearraybuffer">CloneArrayBuffer</a></emu-xref>(<var>srcData</var>, <var>srcByteOffset</var>, <var>byteLength</var>, <var>bufferConstructor</var>).</del></li><li><ins>Let <var>srcBlock</var> be <var>srcData</var>.[[ArrayBufferData]].</ins></li><li><ins>Let <var>targetBlock</var> be <var>data</var>.[[ArrayBufferData]].</ins></li><li><ins>Let <var>numBytesToCopy</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>byteLength</var>, <var>data</var>.[[ArrayBufferByteLength]]).</ins></li><li><ins>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_199"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>targetBlock</var>, 0, <var>srcBlock</var>, <var>srcByteOffset</var>, <var>numBytesToCopy</var>).</ins></li></ol></li><li>Else,<ol><li><del>Let <var>data</var> be ?&nbsp;<emu-xref aoid="AllocateArrayBuffer" id="_ref_200"><a href="#sec-allocatearraybuffer">AllocateArrayBuffer</a></emu-xref>(<var>bufferConstructor</var>, <var>byteLength</var>).</del></li><li><del>If <emu-xref aoid="IsDetachedBuffer" id="_ref_201"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>srcData</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li>If <var>srcArray</var>.[[ContentType]] ‚â† <var>O</var>.[[ContentType]], throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>srcByteIndex</var> be <var>srcByteOffset</var>.</li><li>Let <var>targetByteIndex</var> be 0.</li><li>Let <var>count</var> be <var>elementLength</var>.</li><li>Repeat, while <var>count</var> &gt; 0,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer" id="_ref_202"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcData</var>, <var>srcByteIndex</var>, <var>srcType</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_203"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>data</var>, <var>targetByteIndex</var>, <var>elementType</var>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + <var>srcElementSize</var>.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + <var>elementSize</var>.</li><li>Set <var>count</var> to <var>count</var> - 1.</li></ol></li></ol></li><li>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>data</var>.</li><li>Set <var>O</var>.[[ByteLength]] to <var>byteLength</var>.</li><li>Set <var>O</var>.[[ByteOffset]] to 0.</li><li>Set <var>O</var>.[[ArrayLength]] to <var>elementLength</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-initializetypedarrayfromarraybuffer" type="abstract operation" oldids="sec-typedarray-buffer-byteoffset-length" aoid="InitializeTypedArrayFromArrayBuffer"><span id="sec-typedarray-buffer-byteoffset-length"></span>
      <h1><span class="secnum">4.2.2</span> InitializeTypedArrayFromArrayBuffer ( <var>O</var>, <var>buffer</var>, <var>byteOffset</var>, <var>length</var> )</h1>
      <p>The abstract operation InitializeTypedArrayFromArrayBuffer takes arguments <var>O</var> (a TypedArray), <var>buffer</var> (an ArrayBuffer or a SharedArrayBuffer), <var>byteOffset</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>), and <var>length</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>). It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an Object that has a [[TypedArrayName]] internal slot.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>buffer</var> is an Object that has an [[ArrayBufferData]] internal slot.</li><li>Let <var>constructorName</var> be the String value of <var>O</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>constructorName</var>.</li><li>Let <var>offset</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_204"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>byteOffset</var>).</li><li>If <var>offset</var> <emu-xref aoid="modulo"><a href="https://tc39.es/ecma262/#eqn-modulo">modulo</a></emu-xref> <var>elementSize</var> ‚â† 0, throw a <emu-val>RangeError</emu-val> exception</li><li><ins>Let <var>bufferIsResizable</var> be <emu-xref aoid="IsResizableArrayBuffer" id="_ref_205"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>buffer</var>).</ins>.</li><li>If <var>length</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>newLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_206"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>length</var>).</li></ol></li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_207"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>bufferByteLength</var> be <del><var>buffer</var>.[[ArrayBufferByteLength]]</del><ins><emu-xref aoid="ArrayBufferByteLength" id="_ref_208"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>buffer</var>, <emu-const>SeqCst</emu-const>).</ins>.</li><li><ins>If <var>length</var> is <emu-val>undefined</emu-val> and <var>bufferIsResizable</var> is <emu-val>true</emu-val>, then</ins><ol><li><ins>If <var>offset</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li><ins>Set <var>O</var>.[[ByteLength]] to <emu-const>auto</emu-const>.</ins></li><li><ins>Set <var>O</var>.[[ArrayLength]] to <emu-const>auto</emu-const>.</ins></li></ol></li><li><ins>Else,</ins><ol><li>If <var>length</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>bufferByteLength</var> <emu-xref aoid="modulo"><a href="https://tc39.es/ecma262/#eqn-modulo">modulo</a></emu-xref> <var>elementSize</var> ‚â† 0, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>newByteLength</var> be <var>bufferByteLength</var> - <var>offset</var>.</li><li>If <var>newByteLength</var> &lt; 0, throw a <emu-val>RangeError</emu-val> exception.</li></ol></li><li>Else,<ol><li>Let <var>newByteLength</var> be <var>newLength</var> √ó <var>elementSize</var>.</li><li>If <var>offset</var> + <var>newByteLength</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li></ol></li><li><del>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>buffer</var>.</del></li><li>Set <var>O</var>.[[ByteLength]] to <var>newByteLength</var>.</li><li><del>Set <var>O</var>.[[ByteOffset]] to <var>offset</var>.</del></li><li>Set <var>O</var>.[[ArrayLength]] to <var>newByteLength</var> / <var>elementSize</var>.</li></ol></li><li><ins>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>buffer</var>.</ins></li><li><ins>Set <var>O</var>.[[ByteOffset]] to <var>offset</var>.</ins></li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-dataview-objects-mods">
  <h1><span class="secnum">5</span> Modifications to DataView Objects</h1>

  <emu-clause id="sec-abstract-operations-for-dataview-objects-mods">
    <h1><span class="secnum">5.1</span> Modifications to Abstract Operations For DataView Objects</h1>

    <ins class="block">
    <emu-clause id="sec-getviewbytelength" type="abstract operation" aoid="GetViewByteLength">
      <h1><span class="secnum">5.1.1</span> GetViewByteLength ( <var>view</var>, <var>getBufferByteLength</var> )</h1>
      <p>The abstract operation GetViewByteLength takes arguments <var>view</var> (a DataView) and <var>getBufferByteLength</var> (an Abstract Closure). It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="Type" id="_ref_209"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>view</var>) is Object and <var>view</var> has a [[DataView]] internal slot.</li><li>If <var>view</var>.[[ByteLength]] is not <emu-const>auto</emu-const>, then return <var>view</var>.[[ByteLength]].</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li>Let <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</li><li>Return <var>bufferByteLength</var> - <var>view</var>.[[ByteOffset]].</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-isviewoutofbounds" type="abstract operation" aoid="IsViewOutOfBounds">
      <h1><span class="secnum">5.1.2</span> IsViewOutOfBounds ( <var>view</var>, <var>getBufferByteLength</var> )</h1>
      <p>The abstract operation IsViewOutOfBounds takes arguments <var>view</var> (a DataView) and <var>getBufferByteLength</var> (an Abstract Closure). It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="Type" id="_ref_210"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>view</var>) is Object and <var>view</var> has a [[DataView]] internal slot.</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_211"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li><li>Let <var>byteLength</var> be <emu-xref aoid="GetViewByteLength" id="_ref_212"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>).</li><li>If <var>byteLength</var> &lt; 0, then return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-getviewvalue" type="abstract operation" aoid="GetViewValue">
      <h1><span class="secnum">5.1.3</span> GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> )</h1>
      <p>The abstract operation GetViewValue takes arguments <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, and <var>type</var>. It is used by functions on DataView instances to retrieve values from the view's buffer. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_213"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>view</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>view</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>getIndex</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_214"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>requestIndex</var>).</li><li>Set <var>isLittleEndian</var> to !&nbsp;<emu-xref aoid="ToBoolean" id="_ref_215"><a href="https://tc39.es/ecma262/#sec-toboolean">ToBoolean</a></emu-xref>(<var>isLittleEndian</var>).</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer" id="_ref_216"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_217"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>view</var>'s backing buffer is a growable SharedArrayBuffer.</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_218"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>viewOffset</var> be <var>view</var>.[[ByteOffset]].</li><li>Let <var>viewSize</var> be <del><var>view</var>.[[ByteLength]]</del><ins><emu-xref aoid="GetViewByteLength" id="_ref_219"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>getIndex</var> + <var>elementSize</var> &gt; <var>viewSize</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>bufferIndex</var> be <var>getIndex</var> + <var>viewOffset</var>.</li><li>Return <emu-xref aoid="GetValueFromBuffer" id="_ref_220"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>buffer</var>, <var>bufferIndex</var>, <var>type</var>, <emu-val>false</emu-val>, <emu-const>Unordered</emu-const>, <var>isLittleEndian</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-setviewvalue" type="abstract operation" aoid="SetViewValue">
      <h1><span class="secnum">5.1.4</span> SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> )</h1>
      <p>The abstract operation SetViewValue takes arguments <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, and <var>value</var>. It is used by functions on DataView instances to store values into the view's buffer. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_221"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>view</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>view</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>getIndex</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_222"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>requestIndex</var>).</li><li>If !&nbsp;<emu-xref aoid="IsBigIntElementType" id="_ref_223"><a href="https://tc39.es/ecma262/#sec-isbigintelementtype">IsBigIntElementType</a></emu-xref>(<var>type</var>) is <emu-val>true</emu-val>, let <var>numberValue</var> be ?&nbsp;<emu-xref aoid="ToBigInt" id="_ref_224"><a href="https://tc39.es/ecma262/#sec-tobigint">ToBigInt</a></emu-xref>(<var>value</var>).</li><li>Otherwise, let <var>numberValue</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_225"><a href="https://tc39.es/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>value</var>).</li><li>Set <var>isLittleEndian</var> to !&nbsp;<emu-xref aoid="ToBoolean" id="_ref_226"><a href="https://tc39.es/ecma262/#sec-toboolean">ToBoolean</a></emu-xref>(<var>isLittleEndian</var>).</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer" id="_ref_227"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_228"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>view</var>'s backing buffer is a growable SharedArrayBuffer.</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_229"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>viewOffset</var> be <var>view</var>.[[ByteOffset]].</li><li>Let <var>viewSize</var> be <del><var>view</var>.[[ByteLength]]</del><ins><emu-xref aoid="GetViewByteLength" id="_ref_230"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>getIndex</var> + <var>elementSize</var> &gt; <var>viewSize</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>bufferIndex</var> be <var>getIndex</var> + <var>viewOffset</var>.</li><li>Return <emu-xref aoid="SetValueInBuffer" id="_ref_231"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>buffer</var>, <var>bufferIndex</var>, <var>type</var>, <var>numberValue</var>, <emu-val>false</emu-val>, <emu-const>Unordered</emu-const>, <var>isLittleEndian</var>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-constructor-mods">
    <h1><span class="secnum">5.2</span> Modifications to the DataView Constructor</h1>

    <emu-clause id="sec-dataview-buffer-byteoffset-bytelength">
      <h1><span class="secnum">5.2.1</span> DataView ( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>byteLength</var> ] ] )</h1>
      <p>When the <code>DataView</code> function is called with at least one argument <var>buffer</var>, the following steps are taken:</p>
      <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_232"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>buffer</var>, [[ArrayBufferData]]).</li><li>Let <var>offset</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_233"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>byteOffset</var>).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_234"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>bufferByteLength</var> be <del><var>buffer</var>.[[ArrayBufferByteLength]]</del><ins><emu-xref aoid="ArrayBufferByteLength" id="_ref_235"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>buffer</var>, <emu-const>SeqCst</emu-const>).</ins>.</li><li>If <var>offset</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li><ins>Let <var>bufferIsResizable</var> be <emu-xref aoid="IsResizableArrayBuffer" id="_ref_236"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>buffer</var>).</ins></li><li><ins>Let <var>byteLengthChecked</var> be <emu-const>empty</emu-const>.</ins></li><li><ins>If <var>bufferIsResizable</var> is <emu-val>true</emu-val> and <var>byteLength</var> is <emu-val>undefined</emu-val>, then</ins><ol><li><ins>Let <var>viewByteLength</var> be <emu-const>auto</emu-const>.</ins></li></ol></li><li><del>I</del><ins>Else i</ins>f <var>byteLength</var> is <emu-val>undefined</emu-val>, then<ol><li>Let <var>viewByteLength</var> be <var>bufferByteLength</var> - <var>offset</var>.</li></ol></li><li>Else,<ol><li><ins>Set <var>byteLengthChecked</var> to ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_237"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>byteLength</var>)</ins>.</li><li>Let <var>viewByteLength</var> be <del>?&nbsp;<emu-xref aoid="ToIndex" id="_ref_238"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>byteLength</var>)</del><ins><var>byteLengthChecked</var></ins>.</li><li>If <var>offset</var> + <var>viewByteLength</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li></ol></li><li>Let <var>O</var> be ?&nbsp;<emu-xref aoid="OrdinaryCreateFromConstructor" id="_ref_239"><a href="https://tc39.es/ecma262/#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(NewTarget, <emu-val>"%DataView.prototype%"</emu-val>, ¬´ [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] ¬ª).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_240"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_241"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>Set <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</ins></li><li><ins>If <var>offset</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li><ins>If <var>byteLengthChecked</var> is not <emu-const>empty</emu-const>, then</ins><ol><li><ins>If <var>offset</var> + <var>viewByteLength</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li></ol></li><li>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>buffer</var>.</li><li>Set <var>O</var>.[[ByteLength]] to <var>viewByteLength</var>.</li><li>Set <var>O</var>.[[ByteOffset]] to <var>offset</var>.</li><li>Return <var>O</var>.</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-dataview-prototype-object-mods">
    <h1><span class="secnum">5.3</span> Modifications to Properties of the DataView Prototype Object</h1>

    <emu-clause id="sec-get-dataview.prototype.bytelength">
      <h1><span class="secnum">5.3.1</span> get DataView.prototype.byteLength</h1>
      <p><code>DataView.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_242"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer" id="_ref_243"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_244"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_245"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>size</var> be <del><var>O</var>.[[ByteLength]]</del><ins><emu-xref aoid="GetViewByteLength" id="_ref_246"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Return <emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>size</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-dataview.prototype.byteoffset">
      <h1><span class="secnum">5.3.2</span> get DataView.prototype.byteOffset</h1>
      <p><code>DataView.prototype.byteOffset</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_247"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li><del>If <emu-xref aoid="IsDetachedBuffer" id="_ref_248"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</del></li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_249"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_250"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>offset</var> be <var>O</var>.[[ByteOffset]].</li><li>Return <emu-xref href="#ùîΩ"><a href="https://tc39.es/ecma262/#ùîΩ">ùîΩ</a></emu-xref>(<var>offset</var>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations-for-atomics-mods">
  <h1><span class="secnum">6</span> Modifications to Abstract Operations for Atomics</h1>

  <emu-clause id="sec-validateatomicaccess" type="abstract operation" aoid="ValidateAtomicAccess">
    <h1><span class="secnum">6.1</span> ValidateAtomicAccess ( <var>typedArray</var>, <var>requestIndex</var> )</h1>
    <p>The abstract operation ValidateAtomicAccess takes arguments <var>typedArray</var> (a TypedArray) and <var>requestIndex</var>. It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>typedArray</var> is an Object that has a [[ViewedArrayBuffer]] internal slot.</li><li><ins>Let <var>getBufferByteLength</var> be <emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_251"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li>Let <var>length</var> be <del><var>typedArray</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_252"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>typedArray</var>, <var>getBufferByteLength</var>)</ins>.</li><li><ins>If <var>length</var> is <emu-const>out-of-bounds</emu-const>, set <var>length</var> to 0.</ins></li><li>Let <var>accessIndex</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_253"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>requestIndex</var>).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>accessIndex</var> ‚â• 0.</li><li>If <var>accessIndex</var> ‚â• <var>length</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Return (<var>accessIndex</var> √ó <var>elementSize</var>) + <var>offset</var>.</li></ol></emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-maxbytelength-guidelines">
  <h1><span class="secnum">7</span> Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines</h1>
  <emu-note><span class="note">Note 1</span><div class="note-contents">
    <p>The following are guidelines for ECMAScript programmers working with resizable ArrayBuffer and growable SharedArrayBuffer.</p>
    <p>We recommend that programs be tested in their deployment environments where possible. The amount of available physical memory differ greatly between hardware devices. Similarly, virtual memory subsystems also differ greatly between hardware devices as well as operating systems. An application that runs without out-of-memory errors on a 64-bit desktop web browser could run out of memory on a 32-bit mobile web browser.</p>
    <p>When choosing a value for the <code>"maxByteLength"</code> option for resizable ArrayBuffer and growable SharedArrayBuffer, we recommend that the smallest possible size for the application be chosen. We recommend that <code>"maxByteLength"</code> does not exceed 1073741824, or 1GiB.</p>
    <p>Please note that successfully constructing a ResizableArrayBuffer or a growable SharedArrayBuffer for a particular maximum size does not guarantee that future resizes and grows will succeed.</p>
  </div></emu-note>

  <emu-note><span class="note">Note 2</span><div class="note-contents">
    <p>The following are guidelines for ECMAScript implementers implementing resizable ArrayBuffer.</p>
    <p>Resizable ArrayBuffer can be implemented as copying upon resize, as in-place growth via reserving virtual memory up front, or as a combination of both for different values of the <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref>'s <code>"maxByteLength"</code> option.</p>
    <p>If a host is multi-tenanted (i.e. it runs many JavaScript applications simultaneously), such as a web browser, and its implementations choose to implement in-place growth by reserving virtual memory, we recommend that both 32-bit and 64-bit implementations throw for values of <code>"maxByteLength"</code> ‚â• 1GiB to 1.5GiB. This is to reduce the likelihood a single application can exhaust the virtual memory address space and to reduce interoperability risks.</p>
    <p>If a host does not have virtual memory, such as those running on embedded devices without an MMU, or if a host only implements resizing by copying, it may accept any <emu-xref href="#number-value"><a href="https://tc39.es/ecma262/#number-value">Number value</a></emu-xref> for the <code>"maxByteLength"</code> option. However, we recommend a <emu-val>RangeError</emu-val> be thrown if a memory block of the requested size can never be allocated. For example, if the requested size is greater than the maximium amount of usable memory on the device.</p>
  </div></emu-note>

  <emu-note><span class="note">Note 3</span><div class="note-contents">
    <p>The following are guidelines for ECMAScript implementers implementing growable SharedArrayBuffer.</p>
    <p>We recommend growable SharedArrayBuffer be implemented as in-place growth via reserving virtual memory up front.</p>
    <p>Because grow operations can be concurrent with memory accesses on a growable SharedArrayBuffer, the constraints of the <emu-xref href="#sec-memory-model"><a href="https://tc39.es/ecma262/#sec-memory-model">memory model</a></emu-xref> require that even unordered accesses do not "tear" (bits of their values will not be mixed). In practice, this means the underlying data block of a growable SharedArrayBuffer cannot be grown by being copied without stopping the world. We do not recommend stopping the world as an implementation strategy because it introduces a serialization point and is slow.</p>
    <p>Grown memory must appear zeroed from the moment of its creation, including to any racy concurrent accesses. This can be accomplished via zero-filled-on-demand virtual memory pages, or careful synchronization if manually zeroing memory.</p>
    <p>In practice it is difficult to implement growable SharedArrayBuffer by copying on hosts that do not have virtual memory, such as those running on embedded devices without an MMU. Memory usage behaviour of growable SharedArrayBuffers on such hosts may significantly differ from that of hosts with virtual memory. Such hosts should clearly communicate memory usage expectations to users.</p>
  </div></emu-note>
</emu-clause>

<emu-clause id="omitted-for-brevity">
  <h1><span class="secnum">8</span> Mechanical Changes Omitted for Brevity</h1>
  <ul>
    <li><p>Uses of [[ArrayLength]] on <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">Integer</a></emu-xref>-Indexed exotic objects are replaced with calls to <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_254"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>.</p></li>
    <li><p>Uses of [[ByteLength]] on <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">Integer</a></emu-xref>-Indexed exotic objects are replaced with calls to IntegerIndexedByteLength.</p></li>
    <li><p>Uses of [[ArrayBufferByteLength]] on buffer objects that may be growable SharedArrayBuffers are replaced with calls to <emu-xref aoid="ArrayBufferByteLength" id="_ref_255"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>.</p></li>
  </ul>
</emu-clause>
</div></body>